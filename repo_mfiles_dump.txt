% ===== FILE: DiscProbe_3D_Coordinate_Regression.m =====
% ===== START =====
function DiscProbe_3D_Coordinate_Regression(DATES)
% Fits a 3D Poisson GLM to all trials using LMS coordinates.
% Uses defensive programming to handle inconsistent naming (satID vs satVal).

    clc;
    rootDir = fileparts(mfilename('fullpath'));
    addpath(genpath(rootDir));
    
    config = load_config();
    COL    = load_color_metadata(config);
    
    % 1. Create the Master Color Mapping with STANDARDIZED names
    ColorMap = get_standardized_color_table(config);
    
    % 2. Handle Dates
    if nargin < 1 || isempty(DATES), DATES = 'all'; end
    if ischar(DATES) || isstring(DATES)
        if strcmpi(DATES, 'all')
            d = dir(config.paths.base);
            names = {d([d.isdir]).name};
            validIdx = cellfun(@(s) ~isempty(regexp(s, '\d{6}', 'once')), names) & ...
                       ~ismember(names, {'.','..'});
            DATES = sort(names(validIdx));
        else
            DATES = {char(DATES)};
        end
    end

    timeWin = [0.05 0.20]; 
    allUnitsResults = [];

    for d = 1:numel(DATES)
        targetStr = char(DATES{d});
        sessionFolder = resolve_session_folder(config.paths.base, targetStr);
        
        if isempty(sessionFolder)
            warning('Could not find folder for %s. Skipping.', targetStr);
            continue;
        end
        
        fprintf('\n=== 3D Regression Analysis: %s ===\n', sessionFolder);

        try
            S = load_session(sessionFolder, config);
        catch ME
            fprintf('  Load failed: %s\n', ME.message);
            continue;
        end
        
        % Generate the Trial Index Table
        T = make_trial_index_table(S, COL, config);
        
        % --- DEFENSIVE RENAMING FOR T ---
        T = standardize_table_names(T);
        
        % Now the join is guaranteed to find 'hueID', 'satVal', and 'elevID'
        try
            T_full = join(T, ColorMap, 'Keys', {'hueID','satVal','elevID'});
        catch ME
            warning('Join failed for %s. Check variable names: %s', ...
                sessionFolder, ME.message);
            continue;
        end

        for cc = 1:S.nUnits
            phyID = S.unitIDs(cc);
            uType = S.unitTypes{cc};
            unitLabel = sprintf('%s%d', uType, phyID);

            % 1. Count spikes
            y = cellfun(@(x) sum(x >= timeWin(1) & x <= timeWin(2)), S.spk{cc});
            y = y(:); 

            % 2. Predictor Matrix: L, M, S
            X = [T_full.L, T_full.M, T_full.S];
            
            validRows = all(isfinite(X), 2);
            X_fit = X(validRows, :);
            y_fit = y(validRows);

            if numel(y_fit) < 50, continue; end

            try
                % Fit Poisson GLM (Log-Link)
                [b, dev, stats] = glmfit(X_fit, y_fit, 'poisson', 'link', 'log');
                
                % Pseudo-R2
                R2 = 1 - (dev / stats.null_dev);
                
                fprintf('  %s | R2: %.3f | Weights: L:%.2f M:%.2f S:%.2f\n', ...
                    unitLabel, R2, b(2), b(3), b(4));
                
                allUnitsResults = [allUnitsResults; struct(...
                    'session', sessionFolder, 'unit', unitLabel, ...
                    'R2_3D', R2, 'b0', b(1), 'bL', b(2), 'bM', b(3), 'bS', b(4))]; %#ok<AGROW>
            catch
                fprintf('  %s | GLM fit failed.\n', unitLabel);
            end
        end
    end
    
    % Save Global Results
    if ~isempty(allUnitsResults)
        outDir = fullfile(config.paths.output, 'tables');
        if ~exist(outDir, 'dir'), mkdir(outDir); end
        outPath = fullfile(outDir, 'ALL_3D_Coordinate_Regression.csv');
        writetable(struct2table(allUnitsResults), outPath);
        fprintf('\n✅ Results saved to %s\n', outPath);
    end
end

% -------------------------------------------------------------------------
% DEFENSIVE HELPERS (The "Fixers")
% -------------------------------------------------------------------------

function T = standardize_table_names(T)
    % Renames columns to a standard set to prevent join errors
    vars = T.Properties.VariableNames;
    
    % Fix Hue
    if ismember('hueIdx', vars), T.Properties.VariableNames{'hueIdx'} = 'hueID';
    elseif ismember('hue', vars), T.Properties.VariableNames{'hue'} = 'hueID'; end
    
    % Fix Saturation
    if ismember('satID', vars), T.Properties.VariableNames{'satID'} = 'satVal';
    elseif ismember('sat', vars), T.Properties.VariableNames{'sat'} = 'satVal'; end
    
    % Fix Elevation
    if ismember('elevVal', vars), T.Properties.VariableNames{'elevVal'} = 'elevID';
    elseif ismember('elev', vars), T.Properties.VariableNames{'elev'} = 'elevID'; end
end

function ColorTable = get_standardized_color_table(config)
    % Load metadata and ensure columns match the standardization
    colsFile = fullfile(config.paths.code, 'DiscProbeColsUpdated.mat');
    load(colsFile, 'ProbeColIDs'); % [Hue, Sat, Elev]
    
    lmsFile = fullfile(config.paths.code, 'lms.csv');
    LMS_all = readmatrix(lmsFile); % [L, M, S]
    
    % Hard-code names to our internal standard
    ColorTable = table(ProbeColIDs(:,1), ProbeColIDs(:,2), ProbeColIDs(:,3), ...
                       LMS_all(:,1), LMS_all(:,2), LMS_all(:,3), ...
                       'VariableNames', {'hueID','satVal','elevID','L','M','S'});
end

function actualName = resolve_session_folder(basePath, inputStr)
    actualName = '';
    if exist(fullfile(basePath, inputStr), 'dir')
        actualName = inputStr;
        return;
    end
    if regexp(inputStr, '^\d{6}$')
        d = dir(fullfile(basePath, ['*' inputStr '*']));
        isDir = [d.isdir] & ~ismember({d.name}, {'.','..'});
        matches = d(isDir);
        if ~isempty(matches), actualName = matches(1).name; end
    end
end
% ===== END FILE: DiscProbe_3D_Coordinate_Regression.m =====

% ===== FILE: dump_repo_to_text.m =====
% ===== START =====
function dump_repo_to_text(rootDir, outFile)
% Dump all .m files under rootDir into a single text file.

    if nargin < 1 || isempty(rootDir)
        rootDir = pwd;
    end

    if nargin < 2 || isempty(outFile)
        outFile = fullfile(rootDir, 'repo_mfiles_dump.txt');
    end

    files = dir(fullfile(rootDir, '**', '*.m'));

    if isempty(files)
        warning('No .m files found under %s', rootDir);
        return;
    end

    fidOut = fopen(outFile, 'w');
    if fidOut == -1
        error('Could not open output file: %s', outFile);
    end

    cleaner = onCleanup(@() fclose(fidOut));

    for k = 1:numel(files)
        fpath = fullfile(files(k).folder, files(k).name);

        relpath = strrep(fpath, [rootDir filesep], '');

        fprintf(fidOut, '%% ===== FILE: %s =====\n', relpath);
        fprintf(fidOut, '%% ===== START =====\n');

        fidIn = fopen(fpath, 'r');
        if fidIn == -1
            fprintf(fidOut, '%% [Could not open file]\n\n');
            continue;
        end

        tline = fgetl(fidIn);
        while ischar(tline)
            fprintf(fidOut, '%s\n', tline);
            tline = fgetl(fidIn);
        end
        fclose(fidIn);

        fprintf(fidOut, '%% ===== END FILE: %s =====\n\n', relpath);
    end

    fprintf('Wrote %d files into %s\n', numel(files), outFile);
end
% ===== END FILE: dump_repo_to_text.m =====

% ===== FILE: run_discprobe_analysis.m =====
% ===== START =====
function run_discprobe_analysis(DATES)
clc;
set(0,'DefaultFigureVisible','off');
rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

% --- CONFIG ---
config = load_discprobe_config(); 
COL    = load_color_metadata(config);

% default if nothing passed in
if nargin < 1 || isempty(DATES)
    DATES = {'250513'};
end

% handle 'all' and string vs cell input
if ischar(DATES) || isstring(DATES)
    ds = strtrim(char(DATES));
    if strcmpi(ds, 'all')
        if ~isfield(config, 'paths') || ~isfield(config.paths, 'base') || isempty(config.paths.base)
            error('run_discprobe_analysis:NoBasePath', ...
                  'config.paths.base is missing or empty; cannot resolve ''all'' dates.');
        end
        baseRoot = config.paths.base;
        if ~isfolder(baseRoot)
            error('run_discprobe_analysis:BadBasePath', ...
                  'Base path does not exist: %s', baseRoot);
        end
        dInfo = dir(baseRoot);
        names = {dInfo.name};
        
        % Allow Monkey_Date format
        isDateDir = [dInfo.isdir] & ...
                    ~ismember(names, {'.','..'}) & ...
                    ~cellfun(@isempty, regexp(names, '(\d{6})$', 'once'));
                    
        dateNames = names(isDateDir);
        if isempty(dateNames)
            error('run_discprobe_analysis:NoDateFolders', ...
                  'No valid date folders found under %s', baseRoot);
        end
        DATES = sort(dateNames);
    else
        DATES = {ds};
    end
end
DATES = normalize_dates(DATES);

% RNG setup
if isfield(config, 'pt') && isfield(config.pt, 'seed') && numel(config.pt.seed) == 1
    rng(config.pt.seed);
end

% global "overall" discprobe roots
if isfield(config,'paths') && isfield(config.paths,'output') && ~isempty(config.paths.output)
    overallFigRoot    = fullfile(config.paths.output, 'figs',   'discprobe');
    overallTableRoot  = fullfile(config.paths.output, 'tables', 'discprobe');
else
    overallFigRoot    = fullfile(rootDir, 'output', 'figs',   'discprobe');
    overallTableRoot  = fullfile(rootDir, 'output', 'tables', 'discprobe');
end
if ~exist(overallFigRoot,   'dir'), mkdir(overallFigRoot);   end
if ~exist(overallTableRoot, 'dir'), mkdir(overallTableRoot); end

config.paths.globalDiscProbeFigRoot   = overallFigRoot;
config.paths.globalDiscProbeTableRoot = overallTableRoot;

doFlag = @(name,default) ...
    ( isfield(config,'do') && isfield(config.do,name) && ...
      all(logical(config.do.(name)(:))) ) ...
    || ( ~isfield(config,'do') && default );

for d = 1:numel(DATES)
    dateStr = char(DATES{d});
    fprintf('\n========== %s ===========\n', dateStr);
    
    % session-level paths
    SPaths = get_session_paths(config, dateStr);
    
    if ~isfolder(SPaths.session), mkdir(SPaths.session); end
    if ~isfolder(SPaths.units),   mkdir(SPaths.units);   end
    if ~isfolder(SPaths.tables),  mkdir(SPaths.tables);  end
    if ~isfolder(SPaths.figs),    mkdir(SPaths.figs);    end
    
    sessFigRoot    = fullfile(SPaths.figs,   'discprobe');
    sessTablesRoot = fullfile(SPaths.tables, 'discprobe');
    
    if ~isfolder(sessFigRoot),    mkdir(sessFigRoot);    end
    if ~isfolder(sessTablesRoot), mkdir(sessTablesRoot); end
    
    % Pass exact unit path to config so helpers can find it
    config.paths.figRoot    = sessFigRoot;
    config.paths.unitsRoot  = SPaths.units; 
    config.paths.tablesRoot = sessTablesRoot;
    
    % load session
    S = load_session(dateStr, config);

    % --- CRITICAL FIX ---
    % Force the Session ID/Date in the struct to match the FOLDER name.
    % This prevents U.dateStr from reverting to "250513" when the folder is "Jacomo_250513"
    S.dateStr   = dateStr; 
    S.sessionID = dateStr; 
    % --------------------
    
    % drop units with 0 spikes
    S = filter_zero_spike_units(S, config);
    
    % trial index table
    T = make_trial_index_table(S, COL, config);
    
    Tall  = table();
    Tpeak = table();
    Tcos  = table();
    
    for unitIdx = 1:S.nUnits
        % Safe ID printing
        if isfield(S, 'phyIDs'), currID = S.phyIDs(unitIdx); 
        elseif isfield(S, 'unitIDs'), currID = S.unitIDs(unitIdx); 
        else, currID = unitIdx; end

        fprintf('  unit %d/%d (ID=%d)\n', unitIdx, S.nUnits, currID);
        U = prepare_unit(S, unitIdx, T, config);
        
        if doFlag('dropOutliers', false)
            U = detect_outliers(U, config);
        end
        
        stats = struct();
        stats.hueMeans = compute_hue_means(U);
        
        if doFlag('permutationTest', false)
            stats.permutation = permutation_test(U, config);
        end
        if doFlag('rayleigh', false)
            stats.rayleigh = rayleigh_test(U, config, COL);
        end
        if doFlag('fourier', false)
            stats.fourier = fourier_analysis(U, config);
        end
        if doFlag('cosineFit', false)
            stats.cosine = cosine_fit(U, config);
            if isfield(stats, 'cosine') && ~isempty(stats.cosine)
                COS = stats.cosine;
                rowC = table;
                rowC.dateStr   = string(U.dateStr);
                rowC.unitID    = U.unitID;
                rowC.unitIdx   = unitIdx;
                rowC.unitType  = string(U.unitType);
                rowC.amp       = COS.amp;
                rowC.prefDeg   = COS.pref_deg;
                rowC.R2        = COS.R2;
                if isfield(COS, 'beta') && numel(COS.beta) >= 3
                    rowC.beta0   = COS.beta(1);
                    rowC.betaCos = COS.beta(2);
                    rowC.betaSin = COS.beta(3);
                else
                    rowC.beta0   = NaN;
                    rowC.betaCos = NaN;
                    rowC.betaSin = NaN;
                end
                Tcos = [Tcos; rowC]; %#ok<AGROW>
            end
        end
        if doFlag('anova', false)
            stats.anova = anova_analysis(U, config);
        end
        if doFlag('peakModel', false)
            stats.peak = peak_model(U, config);
        end
        
        % peak-model summary table
        if isfield(stats, 'peak') && ~isempty(stats.peak)
            P = stats.peak;
            t = table;
            t.dateStr        = string(U.dateStr);
            t.unitID         = U.unitID;
            t.unitIdx        = unitIdx;
            t.unitType       = string(U.unitType);
            if isfield(U, 'phyID')
                t.phyID      = U.phyID;
            else
                t.phyID      = U.unitID;
            end
            if isfield(P, 'class')
                t.class      = string(P.class);
            else
                t.class      = string(missing);
            end
            if isfield(P, 'amp1')
                t.amp1       = P.amp1;
            else
                t.amp1       = NaN;
            end
            if isfield(P, 'amp2')
                t.amp2       = P.amp2;
            else
                t.amp2       = NaN;
            end
            if isfield(P, 'amp_ratio')
                t.amp_ratio  = P.amp_ratio;
            else
                t.amp_ratio  = NaN;
            end
            if isfield(P, 'p_tuned')
                t.p_tuned    = P.p_tuned;
            else
                t.p_tuned    = NaN;
            end
            if isfield(P, 'p_bimodal')
                t.p_bimodal  = P.p_bimodal;
            else
                t.p_bimodal  = NaN;
            end
            if isfield(P, 'prefDeg')
                t.prefDeg    = P.prefDeg;
            elseif isfield(P, 'pref_deg')
                t.prefDeg    = P.pref_deg;
            elseif isfield(P, 'prefDirDeg')
                t.prefDeg    = P.prefDirDeg;
            else
                t.prefDeg    = NaN;
            end
            if isfield(P, 'FWHMDeg')
                t.FWHMDeg    = P.FWHMDeg;
            elseif isfield(P, 'FWHM_deg')
                t.FWHMDeg    = P.FWHM_deg;
            elseif isfield(P, 'fwhm_deg')
                t.FWHMDeg    = P.fwhm_deg;
            else
                t.FWHMDeg    = NaN;
            end
            Tpeak = [Tpeak; t]; %#ok<AGROW>
        end
        
        % === plotting ===
        if doFlag('rasterCanonical', true)
            plot_rasters(U, stats, COL, config, sessFigRoot, "canonical");
        end
        if doFlag('rasterByMean', false)
            plot_rasters(U, stats, COL, config, sessFigRoot, "mean");
        end
        if doFlag('tuningFigure', true)
            plot_tuning_curves(U, stats, COL, config, sessFigRoot);
        end
        if doFlag('rayleigh', false)
            plot_rayleigh(U, stats, COL, config, sessFigRoot);
        end
        if doFlag('fourierFig', false)
            plot_fourier(U, stats, COL, config, sessFigRoot);
        end
        if doFlag('boxPlots', false)
            plot_boxplots(U, stats, COL, config, sessFigRoot);
        end
        if doFlag('spikeAccounting', false)
            plot_spike_accounting(U, stats, COL, config, sessFigRoot);
        end
        if doFlag('dklSuite', true)
            plot_dkl_suite(U, stats, COL, config, sessFigRoot);
        end
        
        % per-unit .mat + quick CSV summary
        save_unit_outputs(config, U, stats);
        
        % simple per-unit summary row
        if isfield(stats, 'hueMeans') && isfield(stats.hueMeans, 'rate_mean')
            row = table;
            row.dateStr         = string(U.dateStr);
            row.unitID          = U.unitID;
            row.unitIdx         = unitIdx;
            row.unitType        = string(U.unitType);
            row.meanRateOverall = mean(stats.hueMeans.rate_mean, 'omitnan');
            Tall = [Tall; row]; %#ok<AGROW>
        end
    end
    
    % per-date unit summary CSV (per-session)
    if ~isempty(Tall)
        sumFile = fullfile(sessTablesRoot, sprintf('%s_unit_summary.csv', dateStr));
        try
            writetable(Tall, sumFile);
        catch ME
            warning('Could not write per-date summary CSV for %s: %s', dateStr, ME.message);
        end
        
        sumFileOverall = fullfile(overallTableRoot, sprintf('%s_unit_summary.csv', dateStr));
        try
            writetable(Tall, sumFileOverall);
        catch ME
            warning('Could not write overall unit summary CSV for %s: %s', dateStr, ME.message);
        end
    end
    
    % per-date peak summary CSV
    if ~isempty(Tpeak)
        peakFile = fullfile(sessTablesRoot, sprintf('%s_peak_summary.csv', dateStr));
        try
            writetable(Tpeak, peakFile);
        catch ME
            warning('Could not write peak summary CSV for %s: %s', dateStr, ME.message);
        end
        
        peakFileOverall = fullfile(overallTableRoot, sprintf('%s_peak_summary.csv', dateStr));
        try
            writetable(Tpeak, peakFileOverall);
        catch ME
            warning('Could not write overall peak summary CSV for %s: %s', dateStr, ME.message);
        end
    end
    
    % per-date cosine-fit summary CSV
    if ~isempty(Tcos)
        cosFile = fullfile(sessTablesRoot, sprintf('%s_cosine_summary.csv', dateStr));
        try
            writetable(Tcos, cosFile);
        catch ME
            warning('Could not write cosine summary CSV for %s: %s', dateStr, ME.message);
        end
        
        cosFileOverall = fullfile(overallTableRoot, sprintf('%s_cosine_summary.csv', dateStr));
        try
            writetable(Tcos, cosFileOverall);
        catch ME
            warning('Could not write overall cosine summary CSV for %s: %s', dateStr, ME.message);
        end
    end
end
fprintf('\nDone.\n');
end
% ===== END FILE: run_discprobe_analysis.m =====

% ===== FILE: run_linearmodel_directfit_dkllms.m =====
% ===== START =====
function run_linearmodel_directfit_dkllms(DATES)
% DiscProbe_STA_LMSLINv6_DirectFit - Fits LMS/DKL models to mean rates.
% Fits models using Grand STA weights projected onto trial stimuli.
%
% SAVES TO:
%   1. output/sta/<Session>/ (CSV summary)
%   2. data/<Session>/sta/   (Local copy)
%   3. output/tables/        (Global summary)

    clc;
    rootDir = fileparts(mfilename('fullpath'));
    addpath(genpath(rootDir));
    
    config = load_config();
    COL    = load_color_metadata(config); 
    
    % --- 1. DATE HANDLING ---
    if nargin < 1 || isempty(DATES)
        DATES = 'all';
    end
    
    if ischar(DATES) || isstring(DATES)
        ds = strtrim(char(DATES));
        if strcmpi(ds, 'all')
            d = dir(config.paths.base);
            names = {d([d.isdir]).name};
            % Filter for folders looking like dates (6 digits) or SessionIDs
            validIdx = cellfun(@(s) ~isempty(regexp(s, '\d{6}', 'once')), names) & ...
                       ~ismember(names, {'.','..'});
            DATES = sort(names(validIdx));
        else
            DATES = {ds};
        end
    else
        DATES = cellstr(DATES);
    end

    warning('off','stats:glmfit:IllConditioned');
    warning('off','stats:glmfit:IterationLimit');
    warning('off','MATLAB:rankDeficientMatrix');

    timeWin     = [0 0.2];
    saturIDs    = [0.33 0.66 1];
    nSat        = numel(saturIDs);
    N_BOOT_REPS = 1000;
    
    allRowsGlobal = [];

    % ------------- Keep List ----------------
    % Pass the OUTPUT/TABLES directory explicitly, or rely on the robust search in the function
    % We try to pass the exact location of the global tables first.
    keepMapDir = fullfile(config.paths.output, 'tables'); 
    keepMap = load_keep_map(keepMapDir); 
    
    if isempty(keepMap)
        % Fallback to base if empty (legacy support)
        keepMap = load_keep_map(config.paths.base);
    end

    % ------------- Color Metadata ----------------
    lmsFile = fullfile(config.paths.code, 'lms.csv');
    if ~isfile(lmsFile), error('Missing lms.csv at %s', lmsFile); end
    LMS_all = readmatrix(lmsFile);
    
    if isfield(COL, 'nHue')
        nHue = COL.nHue;
    else
        colsFile = fullfile(config.paths.code, 'DiscProbeColsUpdated.mat');
        if isfile(colsFile)
            tmp = load(colsFile, 'ProbeColIDs');
            nHue = max(tmp.ProbeColIDs(:,1));
        else
            nHue = 16; 
        end
    end
    
    try
        LMS_satur2 = reshape(LMS_all(1:nSat*nHue,1:3), [nSat, nHue, 3]);
    catch
        error('lms.csv rows (%d) do not match nSat*nHue (%d*%d)', size(LMS_all,1), nSat, nHue);
    end

    % --- OUTPUT PATHS ---
    outRootCentral = fullfile(config.paths.output, 'sta');
    if ~exist(outRootCentral, 'dir'), mkdir(outRootCentral); end
    
    outRootGlobal = fullfile(config.paths.output, 'tables');
    if ~exist(outRootGlobal, 'dir'), mkdir(outRootGlobal); end

    % =====================================================================
    % LOOP OVER SESSIONS
    % =====================================================================
    for idate = 1:numel(DATES)
        targetDateStr = char(DATES{idate});
        
        % Resolve actual folder name (e.g., '250513' -> 'Jacomo_250513')
        sessionFolderName = resolve_session_folder(config.paths.base, targetDateStr);
        if isempty(sessionFolderName)
            warning('Folder for %s not found. Skipping.', targetDateStr);
            continue;
        end
        
        fprintf('\n=== %s: Direct LMS & DKL fitting ===\n', sessionFolderName);

        % --- PATH SETUP ---
        localSessDir  = fullfile(config.paths.base, sessionFolderName);
        
        % 1. Central Output
        outDirCentral = fullfile(outRootCentral, sessionFolderName);
        if ~exist(outDirCentral, 'dir'), mkdir(outDirCentral); end
        
        % 2. Local Output
        outDirLocal = fullfile(localSessDir, 'sta');
        if ~exist(outDirLocal, 'dir'), mkdir(outDirLocal); end

        % --- LOAD SESSION ---
        try
            S = load_session(sessionFolderName, config);
        catch ME
            fprintf('  [%s] Load failed: %s\n', sessionFolderName, ME.message);
            continue;
        end
        
        if isfield(S, 'ExptTrialsDisc')
             T = make_trial_index_table(S, COL, config);
        else
             warning('ExptTrialsDisc missing in S.');
             continue;
        end
        
        nTrials = height(T);
        
        % Robust Column Handling
        if ismember('hueID', T.Properties.VariableNames), hueIdx = T.hueID;
        elseif ismember('hueIdx', T.Properties.VariableNames), hueIdx = T.hueIdx;
        elseif ismember('hue', T.Properties.VariableNames), hueIdx = T.hue;
        else, warning('T table missing hueID. Skipping.'); continue; end
        
        if ismember('satID', T.Properties.VariableNames), satVal = T.satID;
        elseif ismember('satVal', T.Properties.VariableNames), satVal = T.satVal;
        elseif ismember('sat', T.Properties.VariableNames), satVal = T.sat;
        else, satVal = nan(nTrials,1); end
        
        [satIdx, okSat] = ismember(satVal, saturIDs);
        validStim = okSat & hueIdx >= 1 & hueIdx <= nHue;
        
        % LMS Matrix
        trial_LMS = nan(nTrials, 3);
        for t = 1:nTrials
            if validStim(t)
                trial_LMS(t,:) = squeeze(LMS_satur2(satIdx(t), hueIdx(t), :));
            end
        end

        % Count Spikes
        spkcounts_all = nan(nTrials, S.nUnits);
        for cc = 1:S.nUnits
            unitSpikes = S.spk{cc};
            for t = 1:nTrials
                spks = unitSpikes{t};
                n = sum(spks >= timeWin(1) & spks < timeWin(2));
                spkcounts_all(t, cc) = n;
            end
        end

        allRows = [];
        
        % --- LOOP OVER UNITS ---
        for cc = 1:S.nUnits
            phyID = S.unitIDs(cc);
            if isfield(S, 'unitTypes')
                unitType = S.unitTypes{cc};
            else
                unitType = '?'; 
            end
            unitLabel = sprintf('%s%d', unitType, phyID);

            % --- CHECK KEEP LIST ---
            if ~isempty(keepMap)
                % Try key with Full Session Name (e.g. Jacomo_250513_SU1)
                keyFull = sprintf('%s_%s', sessionFolderName, unitLabel);
                
                % Try key with just Date (e.g. 250513_SU1) - fallback match
                keyDate = sprintf('%s_%s', targetDateStr, unitLabel);
                
                keepVal = 0; % Default to drop if map exists but key missing
                
                if isKey(keepMap, keyFull)
                    keepVal = keepMap(keyFull);
                elseif isKey(keepMap, keyDate)
                    keepVal = keepMap(keyDate);
                else
                    % If not in map at all, assume we shouldn't process it (or strictly enforce list)
                    % If your logic is "Only process what is in list", then keepVal=0.
                    % If your logic is "Process unless excluded", change this.
                    % Based on previous context: "Keep list" implies strict inclusion.
                    keepVal = 0; 
                end
                
                if keepVal == 0
                    % fprintf('Skipping %s (Not in keep list)\n', keyFull);
                    continue; 
                end
            end
            
            % Locate STA
            staFileInfo = find_sta_file(localSessDir, unitType, phyID);
            if isempty(staFileInfo), continue; end
            
            try
                [w_chan, chanNames_sta] = grand_sta_per_color(staFileInfo.fullpath);
            catch ME
                fprintf('  [%s] %s: STA load failed: %s\n', sessionFolderName, unitLabel, ME.message);
                continue;
            end
            
            idxL = find(strcmpi(chanNames_sta,'L'),1);
            idxM = find(strcmpi(chanNames_sta,'M'),1);
            idxS = find(strcmpi(chanNames_sta,'S'),1);
            
            if isempty(idxL) || isempty(idxM), continue; end
            
            wL = w_chan(idxL); 
            wM = w_chan(idxM);
            hasS = ~isempty(idxS); 
            if hasS, wS = w_chan(idxS); end
            
            L_disc_all = trial_LMS(:,1);
            M_disc_all = trial_LMS(:,2);
            if hasS, S_disc_all = trial_LMS(:,3); end
            
            y_all = spkcounts_all(:, cc);
            
            if hasS
                valid = validStim & isfinite(L_disc_all) & isfinite(M_disc_all) & isfinite(S_disc_all) & isfinite(y_all);
            else
                valid = validStim & isfinite(L_disc_all) & isfinite(M_disc_all) & isfinite(y_all);
            end
            
            if nnz(valid) < 20, continue; end
            
            y = y_all(valid);
            L_disc = L_disc_all(valid);
            M_disc = M_disc_all(valid);
            if hasS, S_disc = S_disc_all(valid); end
            
            stimID = sub2ind([nSat nHue], satIdx(valid), hueIdx(valid));
            nStim  = nSat * nHue;
            
            % --- LMS Direct Fit ---
            gL = wL * L_disc; gM = wM * M_disc;
            if hasS
                gS = wS * S_disc;
                G_LMS = [gL, gM, gS]; chanNames_LMS = {'L','M','S'};
            else
                G_LMS = [gL, gM]; chanNames_LMS = {'L','M'};
            end
            
            [~, bestChan_LMS, ~, ~, ~, ~, LMS_b0, LMS_betas, R2_best_stim_LMS, R2_all_stim_LMS] = ...
                compute_space_stats_direct(G_LMS, y, stimID, nSat, nHue, chanNames_LMS, N_BOOT_REPS, nStim);
            
            LMS_bL=NaN; LMS_bM=NaN; LMS_bS=NaN;
            for ii=1:numel(chanNames_LMS)
                switch upper(chanNames_LMS{ii})
                    case 'L', LMS_bL=LMS_betas(ii);
                    case 'M', LMS_bM=LMS_betas(ii);
                    case 'S', LMS_bS=LMS_betas(ii);
                end
            end
            
            % --- DKL Direct Fit ---
            bestChan_DKL=''; R2_best_stim_DKL=NaN; R2_all_stim_DKL=NaN;
            DKL_b0=NaN; DKL_bLmM=NaN; DKL_bSLpM=NaN;
            
            if hasS
                g_LmM = wL*L_disc - wM*M_disc;
                g_S_LpM = wS*S_disc - (wL*L_disc + wM*M_disc);
                G_DKL = [g_LmM, g_S_LpM];
                chanNames_DKL = {'L_minus_M', 'S_minus_LpM'};
                
                [~, bestChan_DKL, ~, ~, ~, ~, DKL_b0, DKL_betas, R2_best_stim_DKL, R2_all_stim_DKL] = ...
                    compute_space_stats_direct(G_DKL, y, stimID, nSat, nHue, chanNames_DKL, N_BOOT_REPS, nStim);
                
                for ii=1:numel(chanNames_DKL)
                    switch chanNames_DKL{ii}
                        case 'L_minus_M', DKL_bLmM=DKL_betas(ii);
                        case 'S_minus_LpM', DKL_bSLpM=DKL_betas(ii);
                    end
                end
            end
            
            fprintf('  [%s] %s | LMS best=%s R2=%.2f | DKL best=%s R2=%.2f\n', ...
                sessionFolderName, unitLabel, bestChan_LMS, R2_all_stim_LMS, bestChan_DKL, R2_all_stim_DKL);
                
            allRows = [allRows; struct(...
                'date', sessionFolderName, 'unit', unitLabel, 'unit_type', unitType, 'phy_id', phyID, ...
                'LMS_best_channel', bestChan_LMS, 'LMS_R2_best_stim', R2_best_stim_LMS, 'LMS_R2_all_stim', R2_all_stim_LMS, ...
                'LMS_b0', LMS_b0, 'LMS_bL', LMS_bL, 'LMS_bM', LMS_bM, 'LMS_bS', LMS_bS, ...
                'DKL_best_channel', bestChan_DKL, 'DKL_R2_best_stim', R2_best_stim_DKL, 'DKL_R2_all_stim', R2_all_stim_DKL, ...
                'DKL_b0', DKL_b0, 'DKL_bLmM', DKL_bLmM, 'DKL_bSLpM', DKL_bSLpM)];
        end
        
        % --- SAVE PER SESSION ---
        if ~isempty(allRows)
            T = struct2table(allRows);
            csvName = sprintf('%s_STA_LMS_DKL_summary_directfit.csv', sessionFolderName);
            writetable(T, fullfile(outDirCentral, csvName));
            writetable(T, fullfile(outDirLocal, csvName));
            fprintf('  > Saved CSV to: %s\n', outDirCentral);
            allRowsGlobal = [allRowsGlobal; allRows];
        end
    end
    
    % --- SAVE GLOBAL SUMMARY ---
    if ~isempty(allRowsGlobal)
        T_all = struct2table(allRowsGlobal);
        globalCSV = fullfile(outRootGlobal, 'ALL_STA_LMS_DKL_summary_directfit.csv');
        writetable(T_all, globalCSV);
        fprintf('\n✅ Wrote Global Summary (%d rows) to %s\n', height(T_all), globalCSV);
    end
    fprintf('\nDone.\n');
end

% ... [KEEP THE HELPER FUNCTIONS FROM BEFORE: resolve_session_folder, find_sta_file, grand_sta_per_color, etc] ...
% (Include the helpers from my previous response here)

function actualName = resolve_session_folder(basePath, inputStr)
    actualName = '';
    if exist(fullfile(basePath, inputStr), 'dir')
        actualName = inputStr;
        return;
    end
    if regexp(inputStr, '^\d{6}$')
        d = dir(fullfile(basePath, ['*' inputStr '*']));
        isDir = [d.isdir] & ~ismember({d.name}, {'.','..'});
        matches = d(isDir);
        if ~isempty(matches)
            actualName = matches(1).name;
        end
    end
end

function info = find_sta_file(sessionDir, unitType, phyID)
    info = struct('fullpath','','name','');
    staDir = fullfile(sessionDir, 'STAs');
    if ~exist(staDir,'dir'), return; end
    
    phyTag = sprintf('phy%05d', phyID);
    if strcmpi(unitType, 'SU')
        umTag = 'SU';
    else
        umTag = 'MU';
    end
    
    d = dir(fullfile(staDir, sprintf('*%s_%s*_STA.mat', phyTag, umTag)));
    if isempty(d)
        d = dir(fullfile(staDir, sprintf('*%s*_STA.mat', phyTag)));
    end
    
    if ~isempty(d)
        info.fullpath = fullfile(staDir, d(1).name);
        info.name = d(1).name;
    end
end

function [w_chan, chanNames] = grand_sta_per_color(staPath)
    S = load(staPath);
    if ~isfield(S,'STA'), error('STA variable not found in %s', staPath); end
    STA = S.STA;
    if numel(STA)>1, STA = STA(1); end
    if ~isfield(STA,'sta_flat') || ~isfield(STA,'color_channels')
        error('STA.sta_flat or color_channels missing.');
    end
    sta_flat = STA.sta_flat;
    chanNames = cellstr(STA.color_channels);
    nColor = numel(chanNames);
    [~, nCols] = size(sta_flat);
    
    if nCols == nColor
        w_chan = mean(sta_flat,1);
    elseif mod(nCols,nColor)==0
        nPix = nCols/nColor;
        sta_resh = reshape(sta_flat,[],nPix,nColor);
        w_chan = squeeze(sum(sum(sta_resh,1),2));
        w_chan = w_chan(:)';
    else
        warning('STA format unexpected (%d cols, %d colors). Using column means.', nCols, nColor);
        w_chan = mean(sta_flat,1);
    end
    
    names_upper = upper(strtrim(chanNames(:)));
    isRGB = (nColor==3) && all(ismember(names_upper,{'R','G','B'}));
    if isRGB
        [tL,tM,tS] = get_gun_LMS_weights();
        % Reorder transform to match channel order
        wL_val = 0; wM_val = 0; wS_val = 0;
        for i=1:3
            nm = names_upper{i};
            val = w_chan(i);
            switch nm
                case 'R', wL_val=wL_val+val*tL(1); wM_val=wM_val+val*tM(1); wS_val=wS_val+val*tS(1);
                case 'G', wL_val=wL_val+val*tL(2); wM_val=wM_val+val*tM(2); wS_val=wS_val+val*tS(2);
                case 'B', wL_val=wL_val+val*tL(3); wM_val=wM_val+val*tM(3); wS_val=wS_val+val*tS(3);
            end
        end
        w_chan = [wL_val, wM_val, wS_val];
        chanNames = {'L','M','S'};
    end
end

function [tL,tM,tS] = get_gun_LMS_weights()
    rx=0.6280; ry=0.3310; gx=0.3059; gy=0.5826; bx=0.1639; by=0.0617;
    Wr=18.6469/2; Wg=75.8449/2; Wb=10.5313/2;
    R=cie2lms(rx,ry); G=cie2lms(gx,gy); B=cie2lms(bx,by);
    M = [R;G;B]' * diag([Wr Wg Wb]);
    tL=M(1,:)'; tM=M(2,:)'; tS=M(3,:)';
end

function v = cie2lms(a,b)
    x=a; y=b; z=1-x-y;
    M = [.15514 .54316 -.03286; -.15514 .45684 .03286; 0 0 .01608];
    lms = (M*[x;y;z])';
    den = lms(1)+lms(2);
    v = [lms(1)/den, lms(2)/den, lms(3)/den];
end

function [bestIdx, bestName, R2_best_trial, R2_all_trial, ...
          R2_all_boot_mean, R2_all_boot_ci, ...
          tf_intercept, tf_betas, ...
          R2_best_stim, R2_all_stim] = ...
    compute_space_stats_direct(G_trial, y, stimID, nSat, nHue, ...
                               chanNames, N_BOOT_REPS, nStim)

    if nargin < 7 || isempty(N_BOOT_REPS), N_BOOT_REPS = 1000; end
    if nargin < 8 || isempty(nStim), nStim = nSat * nHue; end
    
    nChan   = size(G_trial,2);
    bestIdx = NaN; bestName = '';
    R2_best_trial = NaN; R2_all_trial = NaN;
    R2_best_stim  = NaN; R2_all_stim  = NaN;
    R2_all_boot_mean = NaN; R2_all_boot_ci = [NaN NaN];
    tf_intercept = NaN; tf_betas = nan(1,nChan);
    
    if isempty(G_trial) || isempty(y) || isempty(stimID), return; end
    
    y_stim_full = accumarray(stimID, y, [nStim 1], @mean, NaN);
    G_stim_full = nan(nStim, nChan);
    for c = 1:nChan
        gc = double(G_trial(:,c));
        G_stim_full(:,c) = accumarray(stimID, gc, [nStim 1], @mean, NaN);
    end
    
    goodStim = isfinite(y_stim_full) & any(isfinite(G_stim_full), 2);
    if nnz(goodStim) < 5, return; end
    
    y_stim = y_stim_full(goodStim);
    G_stim = G_stim_full(goodStim, :);
    
    R2_each_stim = nan(1,nChan);
    for c = 1:nChan
        gs = G_stim(:,c);
        good_c = isfinite(y_stim) & isfinite(gs);
        if nnz(good_c) < 5, continue; end
        
        ys = y_stim(good_c);
        gs_good = gs(good_c);
        Xs = [ones(nnz(good_c),1) gs_good];
        
        bs = Xs \ ys;
        yhat = Xs * bs;
        
        SST = sum((ys - mean(ys)).^2);
        SSE = sum((ys - yhat).^2);
        R2_each_stim(c) = 1 - SSE / max(SST, eps);
    end
    
    [~, idxMax] = max(R2_each_stim);
    if ~isempty(idxMax) && isfinite(R2_each_stim(idxMax))
        bestIdx = idxMax;
        bestName = chanNames{bestIdx};
        R2_best_stim = R2_each_stim(bestIdx);
    end
    
    good_all = isfinite(y_stim) & all(isfinite(G_stim),2);
    if nnz(good_all) >= 5
        ys_all = y_stim(good_all);
        Xs_all = [ones(nnz(good_all),1) G_stim(good_all,:)];
        
        bs_all = Xs_all \ ys_all;
        tf_intercept = bs_all(1);
        tf_betas = bs_all(2:end).';
        
        yhat_all = Xs_all * bs_all;
        SST = sum((ys_all - mean(ys_all)).^2);
        SSE = sum((ys_all - yhat_all).^2);
        R2_all_stim = 1 - SSE / max(SST, eps);
    end
    
    R2_best_trial = R2_best_stim;
    R2_all_trial = R2_all_stim;
    
    idxValid = find(good_all);
    nValidStim = numel(idxValid);
    if nValidStim < 10, return; end
    
    R2_boot = nan(N_BOOT_REPS,1);
    for r = 1:N_BOOT_REPS
        bootSel = idxValid(randi(nValidStim, nValidStim, 1));
        boot_y = y_stim_full(bootSel);
        boot_G = G_stim_full(bootSel,:);
        
        good_b = isfinite(boot_y) & all(isfinite(boot_G),2);
        if nnz(good_b) < 5, continue; end
        
        yb = boot_y(good_b);
        Xb = [ones(nnz(good_b),1) boot_G(good_b,:)];
        try
            bb = Xb \ yb;
            yhat_b = Xb * bb;
            SST_b = sum((yb - mean(yb)).^2);
            SSE_b = sum((yb - yhat_b).^2);
            R2_boot(r) = 1 - SSE_b / max(SST_b, eps);
        catch
            R2_boot(r) = NaN;
        end
    end
    
    if sum(isfinite(R2_boot)) >= 10
        R2_all_boot_mean = mean(R2_boot,'omitnan');
        R2_all_boot_ci = prctile(R2_boot(isfinite(R2_boot)),[2.5 97.5]);
    end
end
% ===== END FILE: run_linearmodel_directfit_dkllms.m =====

% ===== FILE: run_sphere_slicer.m =====
% ===== START =====
function run_sphere_slicer(sessionID, config)
% Sphere Slicer: Generates tuning figures for DiscProbe data.
% SPEED OPTIMIZED: Removed redundant plotting loops.
% STABILITY: Streaming Mode (Writes to disk immediately).

    % --- 1. GLOBAL SILENCE START ---
    origVis = get(0, 'DefaultFigureVisible');
    set(0, 'DefaultFigureVisible', 'off');
    set(0, 'DefaultFigureWindowStyle', 'normal');
    cleanupObj = onCleanup(@() set(0, 'DefaultFigureVisible', origVis));

    if nargin < 2 || isempty(config)
        config = load_sphere_config();
    end
    
    % Force the config flag for good measure
    if ~isfield(config, 'plot'), config.plot = struct(); end
    config.plot.makePlots = false; 

    if nargin < 1 || isempty(sessionID)
        sessionID = config.sphere.defaultSession;
    end

    COL = load_color_metadata(config);
    S = load_session(sessionID, config);
    
    if ~isfield(S, 'sessionID'), S.sessionID = sessionID; end
    if ~isfield(S, 'dateStr')
        tok = regexp(sessionID, '\d{6}', 'match', 'once');
        if ~isempty(tok), S.dateStr = tok; else, S.dateStr = sessionID; end
    end

    Tidx = load_or_make_trial_index(S, COL, config);
    nUnits = numel(S.spk);

    % Output Paths
    SessPaths = get_session_paths(config, S.sessionID);
    csvDir = fullfile(SessPaths.tables, 'sphere_slices');
    if ~exist(csvDir, 'dir'), mkdir(csvDir); end
    csvFile = fullfile(csvDir, sprintf('%s_sphere_slices.csv', S.sessionID));

    % --- STREAMING SETUP: Start Fresh ---
    if exist(csvFile, 'file')
        fprintf('[sphere_slicer] Deleting old CSV to start fresh stream: %s\n', csvFile);
        delete(csvFile);
    end

    sessFigRoot = fullfile(SessPaths.figs, 'sphere_slices');
    
    fprintf('[sphere_slicer] Session %s: Found %d units. Starting Stream...\n', S.sessionID, nUnits);

    % --- QC SETTINGS ---
    doOutliers = false;
    if isfield(config, 'qc') && isfield(config.qc, 'removeOutliers')
        doOutliers = logical(config.qc.removeOutliers);
    end
    minTrialsSlice = 10;
    if isfield(config, 'trials') && isfield(config.trials, 'minTrialsSlice')
        minTrialsSlice = config.trials.minTrialsSlice;
    end
    
    % This helper allows 'dklSuite' to default to TRUE if not found in config
    checkFlag = @(field) (~isfield(config, 'sphere') || ~isfield(config.sphere, 'do') || ...
                          ~isfield(config.sphere.do, field) || config.sphere.do.(field));

    % --- UNIT LOOP ---
    for uu = 1:nUnits
        
        % Safe ID printing
        if isfield(S, 'phyIDs'), currID = S.phyIDs(uu); 
        elseif isfield(S, 'unitIDs'), currID = S.unitIDs(uu); 
        else, currID = uu; end

        fprintf('  Processing Unit %d / %d (ID: %d)... ', uu, nUnits, currID);
        
        % Local batch for this unit ONLY
        unit_batch = {}; 
        
        try
            U = prepare_unit(S, uu, Tidx, config);
        catch
            fprintf('Skipped (Load Error)\n');
            continue;
        end
        if doOutliers, U = detect_outliers(U, config); end

        if ~isfield(U, 'trials') || isempty(U.trials) || ...
           ~all(ismember({'hueID','satID','elevID'}, U.trials.Properties.VariableNames))
            fprintf('Skipped (No Trials)\n');
            continue;
        end

        hueID = U.trials.hueID; satID = U.trials.satID; elevID = U.trials.elevID;
        satVals = unique(satID(~isnan(satID))); 
        elevVals = unique(elevID(~isnan(elevID)));

        if isempty(satVals) || isempty(elevVals)
            fprintf('Skipped (No Valid Conditions)\n');
            continue; 
        end
        
        fprintf('OK\n'); 

        unitFolderName = sprintf('%s%d', U.unitType, U.unitID);

        % --- ELEVATION LOOP (PLOTTING) ---
        for ei = 1:numel(elevVals)
            eVal = elevVals(ei);
            usePlane = elevID == eVal & ~isnan(hueID) & ~isnan(satID);
            if nnz(usePlane) < minTrialsSlice, continue; end

            Uplane = U;
            Uplane.spk = U.spk(usePlane); Uplane.mrk = U.mrk(usePlane);
            Uplane.trials = U.trials(usePlane,:); Uplane.nTrials = numel(Uplane.spk);

            % --- SINGLE SAVE DESTINATION ---
            planeSubDir = fullfile('isoluminant_planes', sprintf('elev_%0.2f', eVal));
            saveDir     = fullfile(sessFigRoot, planeSubDir);
            
            if ~exist(saveDir, 'dir'), mkdir(saveDir); end
            
            % Ensure sibling "hues" folder exists (for spike accounting)
            [isoPath, ~] = fileparts(saveDir); 
            [rootPath, ~] = fileparts(isoPath); 
            if ~exist(fullfile(rootPath, 'hues'), 'dir'), mkdir(fullfile(rootPath, 'hues')); end

            plotConfig = config;
            if ~isfield(plotConfig, 'plot'), plotConfig.plot = struct(); end
            plotConfig.plot.makePlots = false; 

            % --- PLOT 1: RAYLEIGH ---
            if checkFlag('rayleighPlot')
                set(0, 'DefaultFigureVisible', 'off');
                try
                    plot_rayleigh(Uplane, struct(), COL, plotConfig, saveDir);
                    close all; 
                catch ME
                    fprintf('  !!! ERROR in plot_rayleigh for Unit %d: %s\n', currID, ME.message);
                    close all;
                end
            end

            % --- PLOT 2: SPIKE ACCOUNTING ---
            if checkFlag('spikeAccounting')
                set(0, 'DefaultFigureVisible', 'off');
                try
                    plot_spike_accounting(Uplane, struct(), COL, plotConfig, saveDir, '');
                    close all; 
                catch ME
                     fprintf('  !!! ERROR in plot_spike_accounting for Unit %d: %s\n', currID, ME.message);
                     close all;
                end
            end

            % --- PLOT 3: DKL SUITE (NEW) ---
            if checkFlag('dklSuite')
                set(0, 'DefaultFigureVisible', 'off');
                try
                    % Plots DKL bars for this specific elevation plane
                    plot_dkl_suite(Uplane, struct(), COL, plotConfig, saveDir);
                    close all; 
                catch ME
                     fprintf('  !!! ERROR in plot_dkl_suite for Unit %d: %s\n', currID, ME.message);
                     close all;
                end
            end
            
            clear Uplane;
        end

        % --- CALC STATS (SLICES) ---
        for si = 1:numel(satVals)
            sVal = satVals(si);
            for ei = 1:numel(elevVals)
                eVal = elevVals(ei);
                useSlice = satID == sVal & elevID == eVal & ~isnan(hueID);
                if nnz(useSlice) < minTrialsSlice, continue; end

                Usub = U;
                Usub.spk = U.spk(useSlice); Usub.mrk = U.mrk(useSlice);
                Usub.trials = U.trials(useSlice,:); Usub.nTrials = numel(Usub.spk);
                
                hm = []; P = []; COS = []; RY = [];

                if checkFlag('hueMeans')
                    try hm = compute_hue_means(Usub); catch, hm = []; end
                end
                
                if isempty(hm) && checkFlag('hueMeans'), continue; end
                
                if checkFlag('peakModel')
                    try P = peak_model_harmonic(Usub, config); catch, P = []; end
                end
                if checkFlag('cosineFit')
                    try COS = cosine_fit(Usub, config); catch, COS = []; end
                end
                if checkFlag('rayleighStats')
                    try RY = rayleigh_test(Usub, config, COL); catch, RY = []; end
                end

                % --- BUILD ROW ---
                row = struct();
                row.sessionID = S.sessionID; row.dateStr = S.dateStr; row.monkey = S.monkey;
                row.unitIdx = U.idx; row.unitID = U.unitID; row.unitType = U.unitType;
                row.satID = sVal; row.elevID = eVal; row.nTrials = Usub.nTrials;
                
                if ~isempty(hm)
                    row.hues = hm.hues; 
                    row.rate_mean = hm.rate_mean;
                    if isfield(hm, 'rate_sem'), row.rate_sem = hm.rate_sem; else, row.rate_sem = []; end
                else
                    row.hues = []; row.rate_mean = []; row.rate_sem = [];
                end

                if ~isempty(P)
                    row.peakClass = P.class;
                    if isfield(P,'p_tuned'), row.p_tuned = P.p_tuned; else, row.p_tuned = NaN; end
                    if isfield(P,'p_bimodal'), row.p_bimodal = P.p_bimodal; else, row.p_bimodal = NaN; end
                    if isfield(P,'r2_flat'), row.r2_flat = P.r2_flat; else, row.r2_flat = NaN; end
                    if isfield(P,'r2_1'), row.r2_1 = P.r2_1; else, row.r2_1 = NaN; end
                    if isfield(P,'r2_12'), row.r2_12 = P.r2_12; else, row.r2_12 = NaN; end
                else
                    row.peakClass = NaN; row.p_tuned = NaN; row.p_bimodal = NaN;
                    row.r2_flat = NaN; row.r2_1 = NaN; row.r2_12 = NaN;
                end

                if ~isempty(COS)
                    if isfield(COS,'pref_deg'), row.cos_pref_deg = COS.pref_deg; else, row.cos_pref_deg = NaN; end
                    if isfield(COS,'amp'), row.cos_amp = COS.amp; else, row.cos_amp = NaN; end
                    if isfield(COS,'R2'), row.cos_R2 = COS.R2; else, row.cos_R2 = NaN; end
                else
                    row.cos_pref_deg = NaN; row.cos_amp = NaN; row.cos_R2 = NaN;
                end

                if ~isempty(RY)
                    if isfield(RY,'R'), row.rayleigh_R = RY.R; else, row.rayleigh_R = NaN; end
                    if isfield(RY,'p'), row.rayleigh_p = RY.p; else, row.rayleigh_p = NaN; end
                    if isfield(RY,'mu_deg'), row.rayleigh_mu = RY.mu_deg; else, row.rayleigh_mu = NaN; end
                else
                    row.rayleigh_R = NaN; row.rayleigh_p = NaN; row.rayleigh_mu = NaN;
                end
                
                unit_batch{end+1} = row;
                clear Usub hm P COS RY;
            end
        end
        
        % --- STREAM TO DISK ---
        if ~isempty(unit_batch)
            try
                T_batch = struct2table([unit_batch{:}]);
                if ~exist(csvFile, 'file')
                    writetable(T_batch, csvFile); 
                else
                    writetable(T_batch, csvFile, 'WriteMode', 'Append'); 
                end
            catch ME
                fprintf('  !!! ERROR writing CSV for Unit %d: %s\n', currID, ME.message);
            end
        end
        
        clear U unit_batch T_batch; 
        if mod(uu, 5) == 0
            java.lang.System.gc();
        end
    end

    fprintf('[sphere_slicer] Done. Slices saved to %s\n', csvFile);
end
% ===== END FILE: run_sphere_slicer.m =====

% ===== FILE: run_vss_peakmodels.m =====
% ===== START =====
function run_vss_peakmodels(DATES)
% RUN_VSS_PEAKMODELS - Wrapper for VSS abstract analysis.
% Fits harmonic peak models (unimodal vs bimodal) to max saturation trials.
% Generates CSV tables for peak classification and hue means.
% SAVES TO: 
%   1. output/vss/<Folder_Name>/tables/
%   2. data/<Folder_Name>/tables/vss/ (Local copy)

    clc;
    % --- 1. SETUP & CONFIG ---
    rootDir = fileparts(mfilename('fullpath'));
    addpath(genpath(rootDir));
    
    config = load_config(); 
    COL    = load_color_metadata(config); 
    
    % --- 2. DATE HANDLING ---
    if nargin < 1 || isempty(DATES)
        DATES = 'all';
    end
    
    % Expand 'all' into list of session folders
    if ischar(DATES) || isstring(DATES)
        ds = strtrim(char(DATES));
        if strcmpi(ds, 'all')
            baseRoot = config.paths.base; 
            dInfo = dir(baseRoot);
            names = {dInfo.name};
            % Find folders that look like dates (6 digits) or SessionIDs (Name_Date)
            isDateDir = [dInfo.isdir] & ~ismember(names, {'.','..'});
            % Filter for folders containing the date pattern
            validIdx = find(isDateDir);
            finalList = {};
            for k = validIdx
                if regexp(names{k}, '\d{6}')
                    finalList{end+1} = names{k}; %#ok<AGROW>
                end
            end
            DATES = sort(finalList);
        else
            DATES = {ds};
        end
    end
    
    % --- 3. FLAGS & SEEDS ---
    if isfield(config, 'pt') && isfield(config.pt, 'seed')
        rng(config.pt.seed);
    end
    
    doFlag = @(name,def) (isfield(config,'analysis') && isfield(config.analysis,name) && ...
                         all(logical(config.analysis.(name)(:)))) || ...
                         (~isfield(config,'analysis') && def);
                     
    DO_DROP_OUTLIERS   = doFlag('dropOutliers', true);
    DO_SAVE_UNIT_MATS  = doFlag('saveVssUnitMats', true);
    DO_BUILD_KEEP_LIST = doFlag('buildVssKeep', true);
    
    allKeepRows = table();

    % --- 4. OUTPUT PATHS (Centralized) ---
    vssRoot = fullfile(config.paths.output, 'vss');
    if ~exist(vssRoot, 'dir'), mkdir(vssRoot); end
    
    globalTableDir = fullfile(config.paths.output, 'tables');
    if ~exist(globalTableDir, 'dir'), mkdir(globalTableDir); end

    % --- 5. SESSION LOOP ---
    for d = 1:numel(DATES)
        % DATES{d} might be '250513' or 'Jacomo_250513'
        % We need to resolve the exact folder name on disk
        targetDateStr = char(DATES{d});
        
        % Helper to find the actual folder name (e.g. transforms '250513' -> 'Jacomo_250513')
        sessionFolderName = resolve_session_folder(config.paths.base, targetDateStr);
        
        if isempty(sessionFolderName)
            warning('Folder for %s not found in %s. Skipping.', targetDateStr, config.paths.base);
            continue;
        end
        
        fprintf('\n=== VSS Peak Model Analysis: %s ===\n', sessionFolderName);
        
        % ---------------- PATH SETUP ----------------
        % 1. Central Output Path: output/vss/<SessionFolder>/tables
        vssSessDir = fullfile(vssRoot, sessionFolderName);
        vssTables  = fullfile(vssSessDir, 'tables');
        vssMats    = fullfile(vssSessDir, 'units');
        
        if ~exist(vssSessDir, 'dir'), mkdir(vssSessDir); end
        if ~exist(vssTables, 'dir'),  mkdir(vssTables);  end
        if DO_SAVE_UNIT_MATS && ~exist(vssMats, 'dir'), mkdir(vssMats); end
        
        % 2. Local Session Path: data/<SessionFolder>/tables/vss
        localSessDir   = fullfile(config.paths.base, sessionFolderName);
        localTablesDir = fullfile(localSessDir, 'tables', 'vss');
        if ~exist(localTablesDir, 'dir'), mkdir(localTablesDir); end
        % --------------------------------------------

        % Load Session (Use the folder name or date string)
        try
            S = load_session(sessionFolderName, config);
        catch ME
            warning('Could not load session %s: %s', sessionFolderName, ME.message);
            continue;
        end
        
        S = filter_zero_spike_units(S, config);
        T = make_trial_index_table(S, COL, config); 
        
        peakRows = table();
        meanRows = table();
        
        alpha = 0.05;
        if isfield(config,'tuning') && isfield(config.tuning,'alphaHarmonic')
            alpha = config.tuning.alphaHarmonic;
        end
        
        % --- UNIT LOOP ---
        for unitIdx = 1:S.nUnits
            if unitIdx > numel(S.unitIDs), break; end
            uID = S.unitIDs(unitIdx);
            
            if isfield(S, 'unitTypes') && numel(S.unitTypes) >= unitIdx
                uType = S.unitTypes{unitIdx};
            else
                uType = '?';
            end
            
            fprintf('  Processing Unit %d/%d (ID=%d %s)...\n', unitIdx, S.nUnits, uID, uType);
            
            U = struct();
            U.dateStr  = sessionFolderName; % Ensure we use the full folder name
            U.unitID   = uID;
            U.unitType = uType;
            U.spk      = S.spk{unitIdx}; 
            U.trials   = T;              
            U.nTrials  = height(T);
            
            if isfield(config,'window') && isfield(config.window,'early')
                U.winEarly = config.window.early;
            else
                U.winEarly = [0.05 0.25]; 
            end

            if DO_DROP_OUTLIERS
                U = detect_outliers(U, config);
            end
            
            U_high = subset_unit_to_max_saturation(U, 1.0);
            
            if ~isfield(U_high,'nTrials') || U_high.nTrials < 10
                continue; 
            end
            
            hm = compute_hue_means(U_high);      
            P  = peak_model_harmonic(U_high, config); 
            
            dateStrStr   = string(sessionFolderName);
            unitTypeStr  = string(U.unitType);
            unitIDVal    = U.unitID;
            unitLabelStr = unitTypeStr + string(unitIDVal);
            
            isTunedFit = isfield(P,'p_tuned') && ~isnan(P.p_tuned) && (P.p_tuned < alpha);
            
            if P.class == "unimodal"
                kMax_fit = 1;
            elseif P.class == "bimodal"
                kMax_fit = 2;
            else
                kMax_fit = NaN;
            end
            fracMax_fit = NaN; 
            
            nH = numel(hm.hues);
            if nH > 0
                newMean = table( ...
                    repmat(dateStrStr,nH,1), repmat(unitTypeStr,nH,1), repmat(unitIDVal,nH,1), ...
                    repmat(unitLabelStr,nH,1), hm.hues(:), hm.rate_mean(:), hm.rate_sem(:), hm.n_trials(:), ...
                    'VariableNames', {'dateStr','unitType','unitID','unitLabel','hueID','rate_mean','rate_sem','n_trials'});
                meanRows = [meanRows; newMean];
            end
            
            peakRow = table(dateStrStr, unitTypeStr, unitIDVal, unitLabelStr, ...
                string(P.class), string(P.class), isTunedFit, kMax_fit, fracMax_fit, ...
                P.amp1, P.amp2, P.amp_ratio, nH, U_high.nTrials, ...
                'VariableNames',{'dateStr','unitType','unitID','unitLabel','peakClass','peakClass_orig',...
                'isTunedFit','kMax_fit','fracMax_fit','amp1','amp2','amp_ratio','nHues','nTrials'});
            
            if isfield(P,'R2'), peakRow.R2 = P.R2; else, peakRow.R2 = NaN; end
            if isfield(P,'p_tuned'), peakRow.p_tuned = P.p_tuned; else, peakRow.p_tuned = NaN; end
            if isfield(P,'p_bimodal'), peakRow.p_bimodal = P.p_bimodal; else, peakRow.p_bimodal = NaN; end
            
            peakRows = [peakRows; peakRow];
            
            if DO_SAVE_UNIT_MATS
                saveName = fullfile(vssMats, sprintf('%s_%s%d_VSS_Peak.mat', sessionFolderName, U.unitType, U.unitID));
                save(saveName, 'U_high', 'hm', 'P');
            end
            
            isKeep = ismember(P.class, ["unimodal","bimodal"]);
            if DO_BUILD_KEEP_LIST && isKeep
                allKeepRows = [allKeepRows; table( ...
                    dateStrStr, unitLabelStr, 1, string(P.class), unitTypeStr, unitIDVal, ...
                    'VariableNames', {'session','unit','keep','peakClass','unitType','unitID'})];
            end
        end
        
        % --- SAVE SESSION TABLES ---
        meanName = sprintf('%s_vss_hueMeans_sat1.csv', sessionFolderName);
        peakName = sprintf('%s_vss_peakModel_sat1.csv', sessionFolderName);
        
        if ~isempty(meanRows)
            writetable(meanRows, fullfile(vssTables, meanName));
            writetable(meanRows, fullfile(localTablesDir, meanName)); 
        end
        if ~isempty(peakRows)
            writetable(peakRows, fullfile(vssTables, peakName));
            writetable(peakRows, fullfile(localTablesDir, peakName)); 
        end
        
        fprintf('  > Saved session tables to: %s\n', vssTables);
        fprintf('  > Saved local copies to:   %s\n', localTablesDir);
    end
    
    % --- 6. SAVE GLOBAL KEEP LIST ---
    if DO_BUILD_KEEP_LIST && ~isempty(allKeepRows)
        keepFile = fullfile(globalTableDir, 'ALL_keep_vss.csv');
        writetable(allKeepRows, keepFile);
        fprintf('\n✅ Wrote Global VSS Keep List to: %s\n', keepFile);
        fprintf('   Total units kept: %d\n', height(allKeepRows));
    end
end

% -------------------------------------------------------------------------
% LOCAL HELPERS
% -------------------------------------------------------------------------

function actualName = resolve_session_folder(basePath, inputStr)
    % Finds the actual folder name matching the input string (date or full name).
    % e.g. input '250513' -> returns 'Jacomo_250513'
    
    actualName = '';
    
    % 1. Check if inputStr is already a valid folder
    if exist(fullfile(basePath, inputStr), 'dir')
        actualName = inputStr;
        return;
    end
    
    % 2. If it looks like a date (6 digits), search for *Date*
    if regexp(inputStr, '^\d{6}$')
        d = dir(fullfile(basePath, ['*' inputStr '*']));
        isDir = [d.isdir] & ~ismember({d.name}, {'.','..'});
        matches = d(isDir);
        
        if ~isempty(matches)
            % If multiple match, prefer one that starts with a name? 
            % For now, take the first one (or the longest one).
            actualName = matches(1).name;
        end
    end
end

function U_out = subset_unit_to_max_saturation(U, maxSatVal)
    U_out = U;
    if ~isfield(U,'trials'), U_out.nTrials=0; return; end
    
    if ismember('satID', U.trials.Properties.VariableNames)
        satCol = U.trials.satID;
    elseif ismember('satVal', U.trials.Properties.VariableNames)
        satCol = U.trials.satVal;
    elseif ismember('sat', U.trials.Properties.VariableNames)
        satCol = U.trials.sat;
    else
        warning('Cannot find saturation column (satID/satVal) in U.trials');
        U_out.nTrials = 0;
        return;
    end
    
    mask = abs(satCol - maxSatVal) < 0.01;
    
    U_out.trials = U.trials(mask, :);
    if isfield(U,'spk') && numel(U.spk) == U.nTrials
        U_out.spk = U.spk(mask);
    end
    U_out.nTrials = sum(mask);
end
% ===== END FILE: run_vss_peakmodels.m =====

% ===== FILE: run_wachtler_analysis.m =====
% ===== START =====
function run_wachtler_analysis(DATES, MODE)
% Wachtler-style color tuning analysis using main DiscProbe pipeline helpers.

clc;

if nargin < 1
    DATES = [];
end
if nargin < 2 || isempty(MODE)
    MODE = 'full';  % 'full' or 'fitsOnly'
end


% make sure repo is on path
rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

% core config + color metadata
config = load_config();
COL    = load_color_metadata(config);
COL    = add_lms_axes(COL);   % uses COL.lms to build L-M / S / Lum

monkey = config.monkey;

% handle DATES / "all" 
if nargin < 1
    DATES = [];
end

if ischar(DATES) || isstring(DATES)
    if strcmpi(strtrim(DATES), 'all')
        DATES = [];
    end
end

PATHS = struct();
PATHS.baseDiscProbeLocal = config.paths.base;
PATHS.baseDiscProbesCode = config.paths.code;
PATHS.baseOut            = config.paths.output;

if isempty(DATES)
    pat = sprintf('%s_*_ExpTrialsDisc.mat', monkey);
    D = dir(fullfile(PATHS.baseDiscProbeLocal, '**', pat));
    if isempty(D)
        error('run_wachtler_analysis:NoSessions', ...
            'No ExpTrialsDisc files found under %s', PATHS.baseDiscProbeLocal);
    end

    dateList = strings(0,1);
    for k = 1:numel(D)
        % look at the *folder* that contains the file
        [~, parentName] = fileparts(D(k).folder);

        % only keep if the folder name is exactly 6 digits, e.g. '250513'
        tok = regexp(parentName, '^\d{6}$', 'match', 'once');
        if ~isempty(tok)
            dateList(end+1,1) = string(tok);
        end
    end

    dateList = unique(dateList);
    if isempty(dateList)
        error('run_wachtler_analysis:NoDateFolders', ...
            'Found ExpTrialsDisc files, but none in 6-digit date folders under %s', ...
            PATHS.baseDiscProbeLocal);
    end
else
    dateList = normalize_dates(DATES);
    dateList = string(dateList(:));
end

% ---------- Wachtler-specific settings ----------
config.tuning.win         = [0.05 0.15];
config.tuning.baselineWin = [-0.15 0];
config.tuning.useSaturIDs = [0.2 0.33 0.5 0.66 0.8 1];

if ~isfield(config, 'tuning') || ~isfield(config.tuning, 'R2_thresh')
    config.tuning.R2_thresh = 0.5;
end

isFitsOnly = strcmpi(MODE, 'fitsOnly');

if isFitsOnly
    config.doPlots.tuningPerUnit    = false;
    config.doPlots.tuningPopulation = false;
else
    config.doPlots.tuningPerUnit    = true;
    config.doPlots.tuningPopulation = true;
end


% ---------- output roots ----------
if isfield(config, 'paths') && isfield(config.paths, 'output') && ~isempty(config.paths.output)
    outRoot = config.paths.output;
else
    outRoot = fullfile(rootDir, 'output');
end

wachtRoot = fullfile(outRoot, 'wachtler');
if ~isfolder(wachtRoot), mkdir(wachtRoot); end

for d = 1:numel(dateList)
    dateStr = char(dateList(d));
    fprintf('\n========== Wachtler analysis %s ==========\n', dateStr);

    sessionRoot = fullfile(wachtRoot, dateStr);
    figRoot     = fullfile(sessionRoot, 'figs');
    tablesRoot  = fullfile(sessionRoot, 'tables');

    if ~isfolder(sessionRoot), mkdir(sessionRoot); end
    if ~isfolder(figRoot),     mkdir(figRoot);     end
    if ~isfolder(tablesRoot),  mkdir(tablesRoot);  end

    config.paths.wachtlerFigRoot    = figRoot;
    config.paths.wachtlerTablesRoot = tablesRoot;

    % ---------- load and prep session ----------
    S = load_session(dateStr, config);
    S = filter_zero_spike_units(S, config);

    T = make_trial_index_table(S, COL, config);

    nUnits = S.nUnits;
    allUnitTuning = cell(nUnits, 1);

    for unitIdx = 1:nUnits
        fprintf('  unit %d/%d (ID=%d)\n', unitIdx, nUnits, S.unitIDs(unitIdx));

        U = prepare_unit(S, unitIdx, T, config);
        U = attach_color_index(U, COL);  % maps trials to color rows

        if isfield(config,'do') && isfield(config.do,'dropOutliers') && config.do.dropOutliers
            U = detect_outliers(U, config);
        end

        unitTuning = compute_unit_color_tuning_wachtler(U, COL, config);
        allUnitTuning{unitIdx} = unitTuning;

        doPerUnit = isfield(config, 'doPlots') && ...
                    isfield(config.doPlots, 'tuningPerUnit') && ...
                    config.doPlots.tuningPerUnit;

        if doPerUnit && ~isempty(unitTuning)
            % classic Wachtler per-unit figure
            H = plot_unit_color_tuning_wachtler(U, unitTuning, COL, config);
            if isfield(H,'fig') && ishghandle(H.fig)
                tag = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);
                outPng = fullfile(figRoot, [tag '_wachtler_tuning.png']);
                try
                    saveas(H.fig, outPng);
                catch ME
                    warning('Could not save Wachtler tuning fig for unit %d: %s', ...
                        U.unitID, ME.message);
                end
                close(H.fig);
            end

            % new: 3D LMS blob for this unit
            tuning3D = compute_unit_tuning_lms(U, COL, config);
            if ~isempty(tuning3D)
                H3 = plot_unit_3d_blob_lms(U, tuning3D, config);
                if isfield(H3,'fig') && ishghandle(H3.fig)
                    tag = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);
                    outPng = fullfile(figRoot, [tag '_wachtler_blob3D.png']);
                    try
                        saveas(H3.fig, outPng);
                    catch ME
                        warning('Could not save Wachtler 3D blob for unit %d: %s', ...
                            U.unitID, ME.message);
                    end
                    close(H3.fig);
                end
            end
        end
    end

    % ---------- build population summary + CSV with fit stats ----------
    if ~isempty(allUnitTuning)
        unitID  = S.unitIDs(:);
        unitNum = (1:numel(unitID)).';

        nU = numel(allUnitTuning);
        R2      = nan(nU,1);
        chi2val = nan(nU,1);
        df      = nan(nU,1);
        pChi2   = nan(nU,1);
        prefDeg = nan(nU,1);
        fwhmDeg = nan(nU,1);

        for ii = 1:nU
            ut = allUnitTuning{ii};
            if isempty(ut) || ~isfield(ut, 'fit') || isempty(ut.fit)
                continue;
            end
            f = ut.fit;

            if isfield(f,'R2'),        R2(ii)      = f.R2;        end
            if isfield(f,'chi2'),      chi2val(ii) = f.chi2;      end
            if isfield(f,'df'),        df(ii)      = f.df;        end
            if isfield(f,'pChi2'),     pChi2(ii)   = f.pChi2;     end
            if isfield(f,'phi0_deg'),  prefDeg(ii) = f.phi0_deg;  end
            if isfield(f,'fwhm_deg'),  fwhmDeg(ii) = f.fwhm_deg;  end
        end

        r2Thresh  = config.tuning.R2_thresh;
        isTunedR2 = R2 >= r2Thresh;

        nMin    = min([numel(unitID), numel(R2)]);
        unitID  = unitID(1:nMin);
        unitNum = unitNum(1:nMin);
        R2      = R2(1:nMin);
        chi2val = chi2val(1:nMin);
        df      = df(1:nMin);
        pChi2   = pChi2(1:nMin);
        prefDeg = prefDeg(1:nMin);
        fwhmDeg = fwhmDeg(1:nMin);
        isTunedR2 = isTunedR2(1:nMin);

        Tfits = table(unitID, unitNum, R2, chi2val, df, pChi2, ...
                      isTunedR2, prefDeg, fwhmDeg, ...
            'VariableNames', {'unitID','unitNum','R2','chi2','df','pChi2', ...
                              'isTunedR2','prefDeg','FWHMDeg'});

        csvFile = fullfile(tablesRoot, sprintf('%s_wachtler_fits.csv', dateStr));
        try
            writetable(Tfits, csvFile);
            fprintf('  Saved Wachtler fits CSV: %s\n', csvFile);
        catch ME
            warning('Could not write Wachtler fits CSV for %s: %s', dateStr, ME.message);
        end

        doPop = isfield(config, 'doPlots') && ...
                isfield(config.doPlots, 'tuningPopulation') && ...
                config.doPlots.tuningPopulation;

        if doPop
            pop = summarize_tuning_population(allUnitTuning, config);
            Hpop = plot_tuning_population_histograms(pop, config);
            if isfield(Hpop,'fig') && ishghandle(Hpop.fig)
                outPng = fullfile(sessionRoot, sprintf('%s_wachtler_population.png', dateStr));
                try
                    saveas(Hpop.fig, outPng);
                catch ME
                    warning('Could not save Wachtler population fig for %s: %s', ...
                        dateStr, ME.message);
                end
                close(Hpop.fig);
            end
        end
    end
end

fprintf('\nDone.\n');

end
% ===== END FILE: run_wachtler_analysis.m =====

% ===== FILE: config/build_extended_color_metadata.m =====
% ===== START =====
function META = build_extended_color_metadata(DATES)
% Scan ExpTrialsDisc files and collect all unique DiscProbe RGBs
% plus which ones are already in DiscProbeColsUpdated and which are new.
%
% This does not change the main analysis. It just writes out a metadata
% .mat and .csv you can use later.

clc;

rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

config = load_config();

if nargin < 1
    DATES = [];
end

monkey = config.monkey;

PATHS = struct();
PATHS.baseDiscProbeLocal = config.paths.base;
PATHS.baseDiscProbesCode = config.paths.code;
PATHS.baseOut            = config.paths.output;

% legacy master from DiscProbeColsUpdated
colsFile = fullfile(config.paths.code, 'DiscProbeColsUpdated.mat');
if ~isfile(colsFile)
    error('Missing DiscProbeColsUpdated.mat at %s', colsFile);
end
S = load(colsFile, 'ProbeCols', 'ProbeColIDs');

legacyRGB = double(S.ProbeCols);    % N0 x 3
legacyIDs = double(S.ProbeColIDs);  % N0 x 6 (hue, sat, elev, ...)

% figure out which dates to scan
if isempty(DATES)
    % auto-detect from any *ExpTrialsDisc.mat under base
    pat = sprintf('%s_*_ExpTrialsDisc.mat', monkey);
    D = dir(fullfile(PATHS.baseDiscProbeLocal, '**', pat));
    if isempty(D)
        error('No ExpTrialsDisc files found under %s', PATHS.baseDiscProbeLocal);
    end
    dateList = strings(numel(D),1);
    for k = 1:numel(D)
        tok = regexp(D(k).name, '\d{6}', 'match', 'once');
        if ~isempty(tok)
            dateList(k) = string(tok);
        end
    end
    dateList = unique(dateList(dateList ~= ""));
else
    dateList = normalize_dates(DATES);
    dateList = string(dateList(:));
end

allRGB      = [];
allDates    = strings(0,1);

fprintf('Scanning %d sessions for DiscprobeColor RGBs...\n', numel(dateList));

for d = 1:numel(dateList)
    dateStr = char(dateList(d));
    try
        expFile = locate_expTrialsDisc(PATHS, monkey, dateStr);
    catch ME
        warning('Skipping %s: %s', dateStr, ME.message);
        continue;
    end

    fprintf('  %s -> %s\n', dateStr, expFile);

    Sexp = load(expFile, 'ExptTrialsDisc');
    if ~isfield(Sexp, 'ExptTrialsDisc')
        warning('  %s: no ExptTrialsDisc in file, skipping.', dateStr);
        continue;
    end

    ExptTrialsDisc = Sexp.ExptTrialsDisc;
    if ~iscell(ExptTrialsDisc) && ~istable(ExptTrialsDisc)
        warning('  %s: ExptTrialsDisc is not a cell/table, skipping.', dateStr);
        continue;
    end

    % pull DiscprobeColor per trial into N x 3 matrix
    try
        if iscell(ExptTrialsDisc)
            trlCols = cell2mat( ...
                cellfun(@(s) double(s.DiscprobeColor(:).'), ...
                        ExptTrialsDisc(:,1), 'UniformOutput', false) );
        else
            % table case: assume a column with structs
            trlCols = cell2mat( ...
                cellfun(@(s) double(s.DiscprobeColor(:).'), ...
                        ExptTrialsDisc.Disc, 'UniformOutput', false) );
        end
    catch ME
        warning('  %s: could not extract DiscprobeColor (%s), skipping.', ...
                dateStr, ME.message);
        continue;
    end

    if isempty(trlCols)
        continue;
    end

    allRGB   = [allRGB; trlCols];                 %#ok<AGROW>
    allDates = [allDates; repmat(string(dateStr), size(trlCols,1), 1)]; %#ok<AGROW>
end

if isempty(allRGB)
    error('Did not collect any DiscprobeColor RGBs from the scanned sessions.');
end

% unique RGBs across all sessions
[uniqRGB, ~, ic] = unique(allRGB, 'rows');
nColors = size(uniqRGB,1);

% how many trials used each RGB
trialCount = accumarray(ic, 1, [nColors 1]);

% earliest date each RGB was seen
firstDate = strings(nColors,1);
for k = 1:nColors
    dks = allDates(ic == k);
    if isempty(dks)
        firstDate(k) = "";
    else
        firstDate(k) = min(dks);
    end
end

% which of these RGBs are already in the legacy ProbeCols table
[isLegacy, legacyRow] = ismember(uniqRGB, legacyRGB, 'rows');

extraRGB      = uniqRGB(~isLegacy,:);
extraCount    = trialCount(~isLegacy);
extraFirst    = firstDate(~isLegacy);

fprintf('\nFound %d unique RGBs total.\n', nColors);
fprintf('  %d already in DiscProbeColsUpdated.\n', sum(isLegacy));
fprintf('  %d new RGBs not in DiscProbeColsUpdated.\n', numel(extraCount));

% pack output struct
META = struct();
META.legacy.ProbeCols   = legacyRGB;
META.legacy.ProbeColIDs = legacyIDs;

META.uniqueRGB      = uniqRGB;
META.uniqueCount    = trialCount;
META.uniqueFirstDate = firstDate;
META.isLegacy       = isLegacy;
META.legacyRow      = legacyRow;

META.extraRGB       = extraRGB;
META.extraCount     = extraCount;
META.extraFirstDate = extraFirst;

% handy table of the new stuff
META.extraTable = table( ...
    extraRGB(:,1), extraRGB(:,2), extraRGB(:,3), ...
    extraCount, extraFirst, ...
    'VariableNames', {'R','G','B','nTrials','firstDate'});

% save to disk for future upgrades
outMat = fullfile(config.paths.code, 'DiscProbeColorMetadata_extended.mat');
outCSV = fullfile(config.paths.code, 'DiscProbe_extra_colors.csv');

try
    save(outMat, 'META');
    fprintf('Saved extended color metadata to %s\n', outMat);
catch ME
    warning('Could not save %s (%s)', outMat, ME.message);
end

try
    writetable(META.extraTable, outCSV);
    fprintf('Saved extra RGB table to %s\n', outCSV);
catch ME
    warning('Could not write %s (%s)', outCSV, ME.message);
end

end
% ===== END FILE: config/build_extended_color_metadata.m =====

% ===== FILE: config/get_color_coords_table.m =====
% ===== START =====
function ColorTable = get_color_coords_table(config)
    % 1. Load IDs
    colsFile = fullfile(config.paths.code, 'DiscProbeColsUpdated.mat');
    load(colsFile, 'ProbeColIDs'); % [Hue, Sat, Elev]
    
    % 2. Load Coordinates
    lmsFile = fullfile(config.paths.code, 'lms.csv');
    LMS_all = readmatrix(lmsFile); % [L, M, S]
    
    % 3. Join them (Assuming rows match 1-to-1)
    % If they don't match, we'd use RGB matching, but usually they are aligned.
    ColorTable = table(ProbeColIDs(:,1), ProbeColIDs(:,2), ProbeColIDs(:,3), ...
                       LMS_all(:,1), LMS_all(:,2), LMS_all(:,3), ...
                       'VariableNames', {'hueID','satVal','elevID','L','M','S'});
end
% ===== END FILE: config/get_color_coords_table.m =====

% ===== FILE: config/load_color_metadata.m =====
% ===== START =====
function COL = load_color_metadata(config)

% load ProbeCols + ProbeColIDs
colsFile = fullfile(config.paths.code, 'DiscProbeColsUpdated.mat');
% this file has hue, saturation, elevation, dkl coords, rgb values
% for the 144 stimuli used in the task

if ~isfile(colsFile)
    error('Missing DiscProbeColsUpdated.mat at %s', colsFile);
end

S = load(colsFile);

COL = struct();

COL.probeCols = sanitize_colors(S.ProbeCols);   % nProbes × 3 RGB
COL.probeIDs  = double(S.ProbeColIDs);          % nProbes × 6: [hue sat elev, dkl]

rgbAll = COL.probeCols;
ids    = COL.probeIDs;

hueID  = ids(:,1); % hue id (should be integer-like)
satID  = ids(:,2); % 0.2, 0.33, 0.5, 0.66, 0.8, 1 or similar
elevID = ids(:,3); % elevation values (e.g. -0.8 ... 0.8)

% make sure hue IDs are integer-ish
hueID_int = round(hueID);
if any(abs(hueID_int - hueID) > 1e-6)
    warning('load_color_metadata: hueID values are not close to integers.');
end
hueID = hueID_int;

COL.nHue = max(hueID(:));

% saturation / elevation levels are value-based, not 1..N indexes
satVals  = unique(satID(~isnan(satID)));
elevVals = unique(elevID(~isnan(elevID)));

COL.nSat      = numel(satVals);
COL.nElev     = numel(elevVals);
COL.satVals   = satVals;
COL.elevVals  = elevVals;

nHue  = COL.nHue;
nSat  = COL.nSat;
nElev = COL.nElev;

% make sure RGB are clean and preallocate lookups
COL.colsSatur = nan(nSat,  nHue, 3);
COL.colsElev  = nan(nElev, nHue, 3);

for k = 1:numel(hueID)
    h   = hueID(k);
    sVal = satID(k);
    eVal = elevID(k);

    if ~isfinite(h) || h < 1 || h > nHue
        continue;
    end

    % map satID/elevID values to index in satVals/elevVals
    sIdx = find(satVals == sVal, 1);
    eIdx = find(elevVals == eVal, 1);

    if ~isempty(sIdx)
        COL.colsSatur(sIdx, h, :) = rgbAll(k,:);
    end
    if ~isempty(eIdx)
        COL.colsElev(eIdx, h, :) = rgbAll(k,:);
    end
end

% load DKL CSV 
dklFile = fullfile(config.paths.code, 'dkl.csv');

if ~isfile(dklFile)
    error('Could not find dkl.csv at %s', dklFile);
end

A = readmatrix(dklFile);
if size(A,2) < 3
    error('dkl.csv must have at least 3 numeric columns, found %d.', size(A,2));
end

DKL = A(:,1:3);

% sanity check row counts
nProbes = size(COL.probeCols,1);
if size(DKL,1) ~= nProbes
    error('dkl.csv row count (%d) does not match ProbeCols (%d).', ...
          size(DKL,1), nProbes);
end

% row-wise DKL for master-row indexing
COL.dklRows = DKL;   % <-- this is what TrialIndex + index_to_dkl will use

% build DKL lookup by saturation × hue (for DKL-plane utilities)
COL.dkl = nan(nSat, nHue, 3);
for k = 1:numel(hueID)
    h   = hueID(k);
    sVal = satID(k);

    if ~isfinite(h) || h < 1 || h > nHue
        continue;
    end

    sIdx = find(satVals == sVal, 1);
    if ~isempty(sIdx)
        COL.dkl(sIdx, h, :) = DKL(k,:);
    end
end

% load LMS CSV 
lmsFile = fullfile(config.paths.code, 'lms.csv');

LMS = [];

if isfile(lmsFile)
    try
        A = readmatrix(lmsFile);
        if size(A,2) < 3
            warning('lms.csv must have at least 3 numeric columns, found %d. LMS will be unavailable.', size(A,2));
        else
            LMS = A(:,1:3);
        end
    catch ME
        warning('Failed to read lms.csv at %s: %s. LMS will be unavailable.', ...
                lmsFile, ME.message);
    end
else
    warning('Could not find lms.csv at %s. LMS will be unavailable.', lmsFile);
end

if ~isempty(LMS)
    if size(LMS,1) ~= nProbes
        warning('lms.csv row count (%d) does not match ProbeCols (%d).', ...
                size(LMS,1), nProbes);
    end

    COL.lms = LMS;

    L     = LMS(:,1);
    M     = LMS(:,2);
    Scone = LMS(:,3);

    denom = L + M;
    denom(denom == 0) = NaN;

    COL.lmsCC = [L./denom, M./denom, Scone./denom]; %normalized lms 
end

end

function A = sanitize_colors(A) %to clip any values that go below or above 0-255
    A = double(A);
    A(~isfinite(A)) = 0;
    A = min(max(A,0),255);
end
% ===== END FILE: config/load_color_metadata.m =====

% ===== FILE: config/load_common_config.m =====
% ===== START =====
function config = load_common_config()
% load_common_config
% shared settings for all wrappers (discprobe, sphere, wachtler)

% --- global identity ---
% config.monkey = 'Jacomo'; 

% --- paths ---
config.paths.base      = '/Users/tellezi2/Documents/DiscProbe';
config.paths.code      = '/Users/tellezi2/Documents/DiscProbeAnalysis';
config.paths.output    = config.paths.base;
config.paths.global    = '/Users/tellezi2/Documents/DiscProbe';

% --- experimental parameters ---
% spike counting windows
config.time.winEarly   = [0.00 0.20];
config.time.winLate    = [0.25 0.40];
config.time.fullWin    = [0.00 0.40];
config.time.winForHz   = 0.40;

% color space definitions
config.space.mode      = 'dkl';
config.space.zeroHue   = 16; 

% --- data processing defaults ---
config.trials.forceRebuildIndex = false;

% outlier detection 
config.qc.removeOutliers = true; 

% --- plotting defaults ---
config.plot.dpi        = 300;
config.plot.makePlots  = false; 
end
% ===== END FILE: config/load_common_config.m =====

% ===== FILE: config/load_config.m =====
% ===== START =====
function config = load_config()

config.sphere.defaultSession= 'Jacomo_250513';


% what figures do we want to do?
% skip tests/figures by setting false
% !!! if you want to drop outliers you have to set these two to true
config.do.boxPlots         = true;
config.do.dropOutliers     = true;

%discprobe "legacy" (the original set of analyses i did)
config.do.tuningFigure     = true; %felix's fig
config.do.rasterCanonical  = true; %raster in rainbow
config.do.rasterByMean     = true; %raster by mean
config.do.permutationTest  = true; %cv permutation test
config.do.spikeAccounting  = true; %cosine fit
config.do.rayleigh         = true; %raylegih
config.do.fourier          = true; % fft
config.do.fourierFig       = true; % to make the 2x2 diagnostic fig
config.do.dklSuite         = true; %polar plots and dome
config.do.swatches         = true; %pantenes

%vss
config.do.peakModel        = true; %fit first and second harmonic

%stas
config.do.stas             = false;

config.plot.makePlots = false;


% Fourier params
config.fourier.maxHarmonics = 8;
config.fourier.useHann      = false;
config.fourier.detrend      = true;

% spike window
config.time.winEarly  = [0.00 0.20];
config.time.winLate   = [0.25 0.40];
config.time.fullWin   = [0.00 0.40];
config.time.winForHz  = 0.40;

% saturation IDs 
config.saturations = [0.33 0.66 1];

% output resolution
config.fig.pngDpi = 300;

% paths 
config.paths.base      = '/Users/tellezi2/Documents/DiscProbe';
config.paths.code      = '/Users/tellezi2/Documents/DiscProbeAnalysis';
config.paths.output    = config.paths.base;


config.trials.forceRebuildIndex = true;


%name ( for filename matching, it needs to be the same) 
% config.monkey = 'Jacomo'; 

%alpha harmonic
config.tuning.alphaHarmonic= 0.05;

% DKL mode or index mode 
config.space.mode = 'dkl';     % or 'index'
config.space.zeroHue = 16;     % which hue sits at 0°

% permutation test settings 
config.pt.nPerm = 1000;
config.pt.alpha = 0.05;
config.pt.seed  = 2025;

% legacy / DiscProbe-v1 style settings
config.legacy.useLegacySats = true;
config.legacy.sats          = [0.33 0.66 1];   % the three main ones
config.legacy.satTol        = 1e-3;            % tolerance for matching

%vss
config.do.saveVssUnitMats  = true;   % turn off per-unit MATs if you want
config.do.buildVssKeep     = true;   % let build_all_keep_vss own ALL_keep_vss.csv
end
% ===== END FILE: config/load_config.m =====

% ===== FILE: config/load_discprobe_config.m =====
% ===== START =====
function config = load_discprobe_config()
% config specifically for run_discprobe_analysis.m

% inherit common settings
config = load_common_config();

% --- analysis flags ---
config.do.tuningFigure     = true;  % felix's fig
config.do.rasterCanonical  = false;  % rainbow raster
config.do.rasterByMean     = false; 
config.do.spikeAccounting  = true;  % cosine fit viz
config.do.rayleigh         = true;  % rayleigh viz
config.do.boxPlots         = true;
config.do.fourierFig       = true;  
config.do.dklSuite         = true;  % polar plots

% --- statistics settings ---
config.do.permutationTest  = true;
config.do.fourier          = true;
config.do.peakModel        = true; 

% --- algorithm parameters ---
% fourier
config.fourier.maxHarmonics = 8;
config.fourier.useHann      = false;
config.fourier.detrend      = true;

% permutation test
config.pt.nPerm = 1000;
config.pt.alpha = 0.05;
config.pt.seed  = 2025;

% tuning fit
config.tuning.alphaHarmonic = 0.05;

% --- legacy support ---
config.legacy.useLegacySats = true;
config.legacy.sats          = [0.33 0.66 1];
end
% ===== END FILE: config/load_discprobe_config.m =====

% ===== FILE: config/load_sphere_config.m =====
% ===== START =====
function config = load_sphere_config()
% config specifically for sphere_slicer.m

% inherit common settings
config = load_common_config();

% --- slicer specifics ---
config.sphere.defaultSession = 'Jacomo_250513';
config.trials.minTrialsSlice = 10;

% --- plotting preferences ---
config.plot.makePlots = false; 
config.plot.suppressSubfolders = true; 
config.plot.saveFigs = false;

% --- analysis flags ---
config.sphere.do.hueMeans        = true;
config.sphere.do.peakModel       = true;
config.sphere.do.cosineFit       = true;
config.sphere.do.rayleighStats   = true;
config.sphere.do.rayleighPlot    = true;
config.sphere.do.spikeAccounting = true;
config.sphere.do.dklSuite = true;

% --- qc ---
config.qc.removeOutliers = true;
end
% ===== END FILE: config/load_sphere_config.m =====

% ===== FILE: config/load_wachtler_config.m =====
% ===== START =====
function config = load_wachtler_config()
% config specifically for run_wachtler_analysis.m

% inherit common settings
config = load_common_config();

% --- wachtler specifics ---
config.wachtler.fitGaussian = true;
config.wachtler.fitDog      = false; 

% specific saturations for fitting
config.wachtler.satsToFit   = [0.33 0.66 1.0]; 
end
% ===== END FILE: config/load_wachtler_config.m =====

% ===== FILE: config/normalize_dates.m =====
% ===== START =====
function dates = normalize_dates(D)
% Normalize various date input formats into a cellstr of 'YYMMDD' char rows.

% single char, like '250513'
if ischar(D)
    dates = {char(D)};
    return;
end

% string or string array
if isstring(D)
    if isscalar(D)
        dates = {char(D)};
    else
        dates = cellstr(D);
    end
    return;
end

% cell array of anything string-like
if iscell(D)
    % convert each element to char
    dates = cellfun(@char, D, 'UniformOutput', false);
    return;
end

% numeric or other weird types – try to be forgiving
if isnumeric(D)
    % assume rows or elements are datenum-like or YYMMDD-ish, convert via num2str
    D = num2cell(D);
    dates = cellfun(@(x) char(string(x)), D, 'UniformOutput', false);
    return;
end

% fallback
dates = {char(string(D))};

end
% ===== END FILE: config/normalize_dates.m =====

% ===== FILE: core/analysis/DiscProbe_STA_LMSLINv5.m =====
% ===== START =====
function DiscProbe_STA_LMSLINv5(DATES)

clc;

% make sure repo is on path (same pattern as run_wachtler_analysis)
rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

% config + paths
config = load_config();
MONKEY = config.monkey;

PATHS = struct();
PATHS.baseDiscProbeLocal = config.paths.base;
PATHS.baseDiscProbesCode = config.paths.code;

% handle DATES: [] or 'all' means "all 6-digit date folders"
if nargin < 1 || isempty(DATES) || ...
        (ischar(DATES)   && strcmpi(strtrim(DATES),'all')) || ...
        (isstring(DATES) && strcmpi(strtrim(DATES),'all'))
    d = dir(PATHS.baseDiscProbeLocal);
    isDir  = [d.isdir];
    names  = {d(isDir).name};
    names  = names(~ismember(names, {'.','..'}));
    isDate = cellfun(@(s) numel(s)==6 && all(isstrprop(s,'digit')), names);
    DATES  = sort(names(isDate));
end

if ischar(DATES) || isstring(DATES)
    DATES = cellstr(DATES);
end

warning('off','stats:glmfit:IllConditioned');
warning('off','stats:glmfit:IterationLimit');

timeWin   = [0 0.2];    % spike counting window
saturIDs  = [0.33 0.66 1];
nSat      = numel(saturIDs);

N_BOOT_REPS = 1000;

% =========================
% keep list (VSS)
% =========================
keepMap  = containers.Map;

% primary: VSS keep list
keepFileVSS = fullfile(PATHS.baseDiscProbeLocal, 'ALL_keep_vss.csv');
% optional fallback: old global keep list
keepFileAll = fullfile(PATHS.baseDiscProbeLocal, 'ALL_keep.csv');

if isfile(keepFileVSS)
    keepFile = keepFileVSS;
elseif isfile(keepFileAll)
    keepFile = keepFileAll;
    warning('VSS keep list not found, falling back to ALL_keep.csv at %s', keepFileAll);
else
    warning('No keep list found (ALL_keep_vss.csv or ALL_keep.csv). Processing ALL units.');
    keepMap = containers.Map;  % empty; later code will skip keep filtering
    % and we just return out of this block
end

if exist('keepFile','var')
    fprintf('Loading keep list from %s...\n', keepFile);
    T_keep = readtable(keepFile);

    names      = T_keep.Properties.VariableNames;
    namesLower = lower(names);

    % session/date column
    sessField = '';
    for cand = {'session','date','datestr'}
        idx = find(strcmp(namesLower, cand{1}), 1);
        if ~isempty(idx)
            sessField = names{idx};
            break;
        end
    end
    if isempty(sessField)
        error('Keep list %s is missing a session/date column.', keepFile);
    end

    % unit label column
    unitField = '';
    for cand = {'unit','unit_label','unitname'}
        idx = find(strcmp(namesLower, cand{1}), 1);
        if ~isempty(idx)
            unitField = names{idx};
            break;
        end
    end
    if isempty(unitField)
        error('Keep list %s is missing a unit column.', keepFile);
    end

    % keep flag column (prefer VSS-specific if present)
    keepField = '';
    for cand = {'keep_vss','keep','keep_flag'}
        idx = find(strcmp(namesLower, cand{1}), 1);
        if ~isempty(idx)
            keepField = names{idx};
            break;
        end
    end
    if isempty(keepField)
        error('Keep list %s is missing a keep flag column.', keepFile);
    end

    for i = 1:height(T_keep)
        uName = string(T_keep.(unitField)(i));

        sVal = T_keep.(sessField)(i);
        if isnumeric(sVal)
            sessStr = sprintf('%06d', sVal);
        else
            sessStr = char(string(sVal));
        end

        key = sprintf('%s_%s', sessStr, uName);
        keepMap(key) = T_keep.(keepField)(i);
    end
end


% % =========================
% % keep list
% % =========================
% keepFile = fullfile(PATHS.baseDiscProbeLocal, 'ALL_keep.csv');
% keepMap  = containers.Map;
% 
% if isfile(keepFile)
%     fprintf('Loading keep list from %s...\n', keepFile);
%     T_keep = readtable(keepFile);
%     for i = 1:height(T_keep)
%         uName = string(T_keep.unit(i));
% 
%         sVal  = T_keep.session(i);
%         if isnumeric(sVal)
%             sessStr = sprintf('%06d', sVal);
%         else
%             sessStr = char(string(sVal));
%         end
% 
%         key = sprintf('%s_%s', sessStr, uName);
%         keepMap(key) = T_keep.keep(i);
%     end
% else
%     warning('ALL_keep.csv not found at %s. Processing ALL units.', keepFile);
% end


% =========================
% LMS table for disc stimuli
% =========================
lmsFile = fullfile(PATHS.baseDiscProbesCode,'lms.csv');
if ~isfile(lmsFile)
    error('Missing lms.csv at %s', lmsFile);
end
LMS_all = readmatrix(lmsFile);

% disc probe color definitions
colsFile = fullfile(PATHS.baseDiscProbesCode, 'DiscProbeColsUpdated.mat');
if ~isfile(colsFile)
    error('Missing DiscProbeColsUpdated.mat at %s', colsFile);
end
load(colsFile, 'ProbeCols', 'ProbeColIDs'); %#ok<NASGU>
nHue = max(ProbeColIDs(:,1));

if size(LMS_all,1) < nSat*nHue || size(LMS_all,2) < 3
    error('lms.csv shape is inconsistent with nSat=%d, nHue=%d', nSat, nHue);
end

% reshape to [nSat × nHue × 3] for L,M,S
LMS_satur2 = reshape(LMS_all(1:nSat*nHue,1:3), [nSat, nHue, 3]);
nColorLMS  = size(LMS_satur2,3);   % should be 3

% =========================
% main loop over sessions
% =========================
for idate = 1:numel(DATES)
    filedate = DATES{idate};
    fprintf('\n=== %s: STA → LMS & DKL vs cosine tuning ===\n', filedate);

    % load trial struct
    expFile = locate_expTrialsDisc(PATHS, MONKEY, filedate);
    if ~isfile(expFile)
        fprintf('  [%s] ExpTrialsDisc file not found, skipping.\n', filedate);
        continue;
    end
    S = load(expFile);
    ExptTrialsDisc = S.ExptTrialsDisc;
    ExptInfo       = S.ExptInfo;

    nSU     = ExptInfo.nSU;
    nMU     = ExptInfo.nMU;
    nTOT    = nSU + nMU;
    unitIDs = [ExptInfo.spk_ID_SU; ExptInfo.spk_ID_MU];

    % trial info
    trialMat = fullfile(PATHS.baseDiscProbeLocal, filedate, ...
                        sprintf('%s_TrialIDs_session.mat', filedate));
    if ~isfile(trialMat)
        fprintf('  [%s] TrialIDs_session.mat not found, skipping.\n', filedate);
        continue;
    end
    T_trials = load(trialMat, 'T_trials');
    T_trials = T_trials.T_trials;
    nTrials  = height(T_trials);

    hueIdx = T_trials.hueIdx;
    satVal = T_trials.satVal;

    % which trials have valid hue/sat
    [satIdx, okSat] = ismember(satVal, saturIDs);
    validStim = okSat & hueIdx >= 1 & hueIdx <= nHue;

    % trial LMS [nTrials × 3] (stimulus LMS, not STA weights)
    trial_LMS = nan(nTrials, nColorLMS);
    for t = 1:nTrials
        if ~validStim(t)
            continue;
        end
        si = satIdx(t);
        hi = hueIdx(t);
        trial_LMS(t,:) = squeeze(LMS_satur2(si, hi, :));
    end

    % spike counts in analysis window
    cols = 10:(9+nTOT);
    spkcell_all = ExptTrialsDisc(:, cols);
    spkcell_all = cellfun(@(x) x(x>=timeWin(1) & x<timeWin(2)), ...
                          spkcell_all, 'UniformOutput', false);
    spkcounts_all = cellfun(@numel, spkcell_all);

    outDir = fullfile(PATHS.baseDiscProbeLocal, filedate, 'STA_LMSchannels');
    if ~exist(outDir,'dir'), mkdir(outDir); end

    allRows = [];

    % -------------------------
    % per-unit loop
    % -------------------------
    for cc = 1:nTOT
        unitType  = iff(cc <= nSU, 'SU', 'MU');
        unitLabel = sprintf('%s%d', unitType, unitIDs(cc));

        % keep filter
        if ~isempty(keepMap)
            key = sprintf('%s_%s', filedate, unitLabel);
            if ~isKey(keepMap, key) || keepMap(key) == 0
                continue;
            end
        end

        % STA file
        phyID = unitIDs(cc);
        staFileInfo = find_sta_file(PATHS, filedate, unitType, phyID);
        if isempty(staFileInfo)
            continue;
        end

        % STA → LMS weights (L,M and compute S if needed)
        try
            [w_chan, chanNames_sta] = grand_sta_per_color(staFileInfo.fullpath);
        catch ME
            fprintf('  [%s] %s: STA load/grand failed: %s\n', ...
                    filedate, unitLabel, ME.message);
            continue;
        end

        idxL = find(strcmpi(chanNames_sta,'L'),1); %grand weight L
        idxM = find(strcmpi(chanNames_sta,'M'),1);
        idxS = find(strcmpi(chanNames_sta,'S'),1);

        if isempty(idxL) || isempty(idxM)
            fprintf('  [%s] %s: STA did not provide L/M weights, skipping.\n', ...
                    filedate, unitLabel);
            continue;
        end
        wL = w_chan(idxL);
        wM = w_chan(idxM);
        hasS = ~isempty(idxS);
        if hasS
            wS = w_chan(idxS);
        end

        if nColorLMS < 2
            fprintf('  [%s] %s: trial LMS has <2 channels, skipping.\n', ...
                    filedate, unitLabel);
            continue;
        end

        % valid trials: good stimulus, finite LMS + spikes
        L_disc_all = trial_LMS(:,1);
        M_disc_all = trial_LMS(:,2);
        if hasS
            S_disc_all = trial_LMS(:,3);
        end
        y_all = spkcounts_all(:, cc);

        if hasS
            valid = validStim & isfinite(L_disc_all) & isfinite(M_disc_all) & ...
                    isfinite(S_disc_all) & isfinite(y_all);
        else
            valid = validStim & isfinite(L_disc_all) & isfinite(M_disc_all) & ...
                    isfinite(y_all);
        end

        if nnz(valid) < 20
            continue;
        end

        y      = y_all(valid);
        L_disc = L_disc_all(valid);
        M_disc = M_disc_all(valid);
        if hasS
            S_disc = S_disc_all(valid);
        end

        % stimulus identity per trial
        stimID = sub2ind([nSat nHue], satIdx(valid), hueIdx(valid));
        nStim  = nSat * nHue;

        % =========================
        % LMS model: channels = L, M, (S)
        % =========================
        gL = wL * L_disc;
        gM = wM * M_disc;
        if hasS
            gS = wS * S_disc;
            G_LMS_trial   = [gL, gM, gS]; %this is the generator matrix
            chanNames_LMS = {'L','M','S'};
        else
            G_LMS_trial   = [gL, gM];
            chanNames_LMS = {'L','M'};
        end

        [bestIdx_LMS, bestChan_LMS, ...
         R2_best_LMS, R2_all_LMS, ...
         R2_all_LMS_boot_mean, R2_all_LMS_boot_ci, ...
         LMS_b0, LMS_betas] = ...
            compute_space_stats(G_LMS_trial, y, stimID, nSat, nHue, ...
                                chanNames_LMS, N_BOOT_REPS, nStim);

        % map LMS betas by name
        LMS_bL = NaN; LMS_bM = NaN; LMS_bS = NaN;
        for ii = 1:numel(chanNames_LMS)
            switch upper(chanNames_LMS{ii})
                case 'L', LMS_bL = LMS_betas(ii);
                case 'M', LMS_bM = LMS_betas(ii);
                case 'S', LMS_bS = LMS_betas(ii);
            end
        end

        % =========================
        % DKL-like model: channels = L-M, S-(L+M)
        % =========================
        bestIdx_DKL          = NaN;
        bestChan_DKL         = '';
        R2_best_DKL          = NaN;
        R2_all_DKL           = NaN;
        R2_all_DKL_boot_mean = NaN;
        R2_all_DKL_boot_ci   = [NaN NaN];
        DKL_b0               = NaN;
        DKL_betas            = [NaN NaN];

        if hasS
            g_LmM   = wL * L_disc - wM * M_disc;
            g_S_LpM = wS * S_disc - (wL * L_disc + wM * M_disc);
            G_DKL_trial   = [g_LmM, g_S_LpM]; %the other generator matrix. this is already the generator signal!
            chanNames_DKL = {'L_minus_M','S_minus_LpM'};

            [bestIdx_DKL, bestChan_DKL, ...
             R2_best_DKL, R2_all_DKL, ...
             R2_all_DKL_boot_mean, R2_all_DKL_boot_ci, ...
             DKL_b0, DKL_betas] = ...
                compute_space_stats(G_DKL_trial, y, stimID, nSat, nHue, ...
                                    chanNames_DKL, N_BOOT_REPS, nStim);
        else
            fprintf('  [%s] %s: no S channel → skipping DKL analysis.\n', ...
                    filedate, unitLabel);
        end

        % map DKL betas
        DKL_bLmM  = NaN;
        DKL_bSLpM = NaN;
        if exist('chanNames_DKL','var')
            for ii = 1:numel(chanNames_DKL)
                switch chanNames_DKL{ii}
                    case 'L_minus_M',   DKL_bLmM  = DKL_betas(ii);
                    case 'S_minus_LpM', DKL_bSLpM = DKL_betas(ii);
                end
            end
        end

        fprintf(['  [%s] %s | LMS: best=%s R2_best=%.3f R2_all=%.3f ', ...
                 '| DKL: best=%s R2_best=%.3f R2_all=%.3f\n'], ...
                filedate, unitLabel, ...
                bestChan_LMS, R2_best_LMS, R2_all_LMS, ...
                bestChan_DKL, R2_best_DKL, R2_all_DKL);

        ciL = R2_all_LMS_boot_ci;
        if numel(ciL) < 2
            ciL = [NaN NaN];
        end

        ciD = R2_all_DKL_boot_ci;
        if numel(ciD) < 2
            ciD = [NaN NaN];
        end

        allRows = [allRows; struct( ...
            'date', filedate, ...
            'unit', unitLabel, ...
            'unit_type', unitType, ...
            'phy_id', unitIDs(cc), ...
            'LMS_best_channel', bestChan_LMS, ...
            'LMS_best_idx', bestIdx_LMS, ...
            'LMS_R2_best', R2_best_LMS, ...
            'LMS_R2_all', R2_all_LMS, ...
            'LMS_R2_all_boot_mean', R2_all_LMS_boot_mean, ...
            'LMS_R2_all_boot_lo', ciL(1), ...
            'LMS_R2_all_boot_hi', ciL(2), ...
            'LMS_b0', LMS_b0, ...
            'LMS_bL', LMS_bL, ...
            'LMS_bM', LMS_bM, ...
            'LMS_bS', LMS_bS, ...
            'DKL_best_channel', bestChan_DKL, ...
            'DKL_best_idx', bestIdx_DKL, ...
            'DKL_R2_best', R2_best_DKL, ...
            'DKL_R2_all', R2_all_DKL, ...
            'DKL_R2_all_boot_mean', R2_all_DKL_boot_mean, ...
            'DKL_R2_all_boot_lo', ciD(1), ...
            'DKL_R2_all_boot_hi', ciD(2), ...
            'DKL_b0', DKL_b0, ...
            'DKL_bLmM', DKL_bLmM, ...
            'DKL_bSLpM', DKL_bSLpM)];
    end  % end for cc

    if ~isempty(allRows)
        T = struct2table(allRows);
        outCSV = fullfile(outDir, sprintf('%s_STA_LMS_DKL_summary.csv', filedate));
        writetable(T, outCSV);
        fprintf('  [%s] wrote %d rows to %s\n', filedate, height(T), outCSV);
    end
end  % end for idate

fprintf('\nDone.\n');
end

% ==========================================
% helpers
% ==========================================

function val = iff(cond, a, b)
if cond, val = a; else, val = b; end
end

function expFile = locate_expTrialsDisc(PATHS, MONKEY, filedate)
cands = {
    fullfile(PATHS.baseDiscProbeLocal, filedate, ...
             sprintf('%s_%s_ExpTrialsDisc.mat', MONKEY, filedate)), ...
    fullfile(PATHS.baseDiscProbeLocal, filedate, ...
             sprintf('%s_ExpTrialsDisc.mat', filedate)), ...
    fullfile(PATHS.baseDiscProbeLocal, ...
             sprintf('%s_ExpTrialsDisc.mat', filedate))};
expFile = '';
for i = 1:numel(cands)
    if isfile(cands{i})
        expFile = cands{i};
        break;
    end
end
end

function info = find_sta_file(PATHS, filedate, unitType, phyID)
info = struct('fullpath','','name','');
staDir = fullfile(PATHS.baseDiscProbeLocal, filedate, 'STAs');
if ~exist(staDir,'dir')
    return;
end

phyTag = sprintf('phy%05d', phyID);
umTag  = tern(strcmpi(unitType,'SU'),'SU','MU');

d = dir(fullfile(staDir, sprintf('*%s_%s*_STA.mat', phyTag, umTag)));
if isempty(d)
    d = dir(fullfile(staDir, sprintf('*%s*_STA.mat', phyTag)));
end
if isempty(d)
    return;
end

info.fullpath = fullfile(staDir, d(1).name);
info.name     = d(1).name;
end

function out = tern(cond,a,b)
if cond, out = a; else, out = b; end
end

function [w_chan, chanNames] = grand_sta_per_color(staPath)
S = load(staPath);
if ~isfield(S,'STA')
    error('STA variable not found in %s', staPath);
end
STA = S.STA;
if numel(STA) > 1
    STA = STA(1);
end
if ~isfield(STA,'sta_flat') || ~isfield(STA,'color_channels')
    error('STA.sta_flat or STA.color_channels missing.');
end

sta_flat = STA.sta_flat;
[~, nCols] = size(sta_flat);

baseChanNames = cellstr(STA.color_channels);
nColor        = numel(baseChanNames);

if mod(nCols, nColor) ~= 0
    error('sta_flat columns (%d) not divisible by nColor (%d)', nCols, nColor);
end

nPix = nCols / nColor;
sta_resh = reshape(sta_flat, [], nPix, nColor);

w_rgb = squeeze(sum(sum(sta_resh, 1), 2));
w_rgb = w_rgb(:);

w_chan    = w_rgb(:)';
chanNames = baseChanNames;

names_upper = upper(strtrim(baseChanNames(:)));

has_tL = isfield(STA,'transform_L') && numel(STA.transform_L) == nColor;
has_tM = isfield(STA,'transform_M') && numel(STA.transform_M) == nColor;
has_tS = isfield(STA,'transform_S') && numel(STA.transform_S) == nColor;

tL = []; tM = []; tS = [];

if has_tL && has_tM
    tL = STA.transform_L(:);
    tM = STA.transform_M(:);
end

isRGB = (nColor == 3) && all(ismember(names_upper, {'R','G','B'}));
if isRGB
    [tL_cal, tM_cal, tS_cal] = get_gun_LMS_weights();
    order = zeros(3,1);
    for k = 1:3
        switch names_upper{k}
            case 'R', order(k) = 1;
            case 'G', order(k) = 2;
            case 'B', order(k) = 3;
        end
    end
    tL_cal = tL_cal(order);
    tM_cal = tM_cal(order);
    tS_cal = tS_cal(order);

    if isempty(tL)
        tL = tL_cal;
    end
    if isempty(tM)
        tM = tM_cal;
    end
    if ~has_tS
        tS = tS_cal;
    else
        tS = STA.transform_S(:);
    end
elseif has_tS
    tS = STA.transform_S(:);
end

if ~isempty(tL) && ~isempty(tM)
    wL = dot(w_rgb, tL);
    wM = dot(w_rgb, tM);
    if ~isempty(tS)
        wS = dot(w_rgb, tS);
        w_chan    = [wL, wM, wS];
        chanNames = {'L','M','S'};
    else
        w_chan    = [wL, wM];
        chanNames = {'L','M'};
    end
end
end

function [tL, tM, tS] = get_gun_LMS_weights()
rx=0.6280; ry=0.3310; gx=0.3059; gy=0.5826; bx=0.1639; by=0.0617;
Wr=18.6469/2; Wg=75.8449/2; Wb=10.5313/2;

R = cie2lms(rx,ry);
G = cie2lms(gx,gy);
B = cie2lms(bx,by);

Lr=R(1); Lg=G(1); Lb=B(1);
Mr=R(2); Mg=G(2); Mb=B(2);
Sr=R(3); Sg=G(3); Sb=B(3);

M_rgb2lms = [Lr Lg Lb; Mr Mg Mb; Sr Sg Sb] * diag([Wr Wg Wb]);

tL = M_rgb2lms(1,:).';
tM = M_rgb2lms(2,:).';
tS = M_rgb2lms(3,:).';
end

function v = cie2lms(a,b)
x=a; y=b; z=1-x-y;
M=[ .15514 .54316 -.03286; -.15514 .45684 .03286; 0 0 .01608];
lms = (M*[x;y;z]).';
den = lms(1)+lms(2);
v = [lms(1)/den, lms(2)/den, lms(3)/den];
end

% ==========================================
% core analysis helper for one "space"
% ==========================================
function [bestIdx, bestName, R2_best, R2_all, ...
          R2_all_boot_mean, R2_all_boot_ci, ...
          tf_intercept, tf_betas] = ...
    compute_space_stats(G_trial, y, stimID, nSat, nHue, ...
                        chanNames, N_BOOT_REPS, nStim)

if nargin < 8 || isempty(N_BOOT_REPS)
    N_BOOT_REPS = 1000;
end
if nargin < 9
    nStim = nSat * nHue;
end

nChan   = size(G_trial,2);
bestIdx = NaN;
bestName = '';
R2_best = NaN;
R2_all  = NaN;
R2_all_boot_mean = NaN;
R2_all_boot_ci   = [NaN NaN];

tf_intercept = NaN;
tf_betas     = nan(1, nChan);

if isempty(G_trial) || isempty(y)
    return;
end

% tuning-level means from data
y_tune_raw = accumarray(stimID, y, [nStim 1], @mean, NaN);

% cosine fit on tuning
y_tune = fit_cosine_from_tuning(y_tune_raw, nSat, nHue);
if isempty(y_tune)
    return;
end

% mean generators per stimulus
G_tune = nan(nStim, nChan);
for c = 1:nChan
    vals_c = double(G_trial(:,c));
    G_tune(:,c) = accumarray(stimID, vals_c, [nStim 1], @mean, NaN);
end

% best single-channel R² (still computed, using cosine-tuning y_tune)
R2_each = nan(1, nChan);
for c = 1:nChan
    g_c = G_tune(:,c);
    good = isfinite(y_tune) & isfinite(g_c);
    if nnz(good) < 5
        continue;
    end
    yc = y_tune(good);
    gc = g_c(good);
    Xc = [ones(nnz(good),1) gc];
    b  = Xc \ yc;
    yhat = Xc * b;
    SST = sum((yc - mean(yc)).^2);
    SSE = sum((yc - yhat).^2);
    R2_each(c) = 1 - SSE / max(SST, eps);
end

[~, idxMax] = max(R2_each);
if ~isempty(idxMax) && isfinite(R2_each(idxMax))
    bestIdx  = idxMax;
    R2_best  = R2_each(idxMax);
    bestName = chanNames{bestIdx};
else
    return;
end

% pooled multi-channel R² and multivariate betas (this is your TF)
good_full = isfinite(y_tune) & all(isfinite(G_tune),2);
if nnz(good_full) >= 5
    y_full = y_tune(good_full);
    X_full = [ones(nnz(good_full),1) G_tune(good_full,:)];
    b_full = X_full \ y_full;     % length 1 + nChan
    tf_intercept = b_full(1);
    tf_betas     = b_full(2:end).';

    yhat_full = X_full * b_full;
    SST_full  = sum((y_full - mean(y_full)).^2);
    SSE_full  = sum((y_full - yhat_full).^2);
    R2_all    = 1 - SSE_full / max(SST_full, eps);
end

% bootstrap CIs on pooled R²
nValidTrials = numel(y);
if nValidTrials < 10
    return;
end

R2_boot = nan(N_BOOT_REPS,1);
for r = 1:N_BOOT_REPS
    bootIdx = randi(nValidTrials, nValidTrials, 1);

    bootStimID  = stimID(bootIdx);
    boot_y      = y(bootIdx);
    boot_Gtrial = G_trial(bootIdx,:);

    y_tune_raw_b = accumarray(bootStimID, boot_y, [nStim 1], @mean, NaN);
    y_tune_b     = fit_cosine_from_tuning(y_tune_raw_b, nSat, nHue);
    if isempty(y_tune_b)
        continue;
    end

    G_tune_b = nan(nStim, nChan);
    for c = 1:nChan
        vals_b = double(boot_Gtrial(:,c));
        G_tune_b(:,c) = accumarray(bootStimID, vals_b, [nStim 1], @mean, NaN);
    end

    good_b = isfinite(y_tune_b) & all(isfinite(G_tune_b),2);
    if nnz(good_b) < 5
        continue;
    end
    yb = y_tune_b(good_b);
    Xb = [ones(nnz(good_b),1) G_tune_b(good_b,:)];
    try
        b_b   = Xb \ yb;
        yhatb = Xb * b_b;
        SST_b = sum((yb - mean(yb)).^2);
        SSE_b = sum((yb - yhatb).^2);
        R2_boot(r) = 1 - SSE_b / max(SST_b, eps);
    catch
        R2_boot(r) = NaN;
    end
end

if sum(isfinite(R2_boot)) >= 10
    R2_all_boot_mean = mean(R2_boot, 'omitnan');
    R2_all_boot_ci   = prctile(R2_boot(isfinite(R2_boot)), [2.5 97.5]);
end
end

% ==========================================
% cosine fit helper (uses tuning means)
% ==========================================
function y_cos = fit_cosine_from_tuning(y_tune_raw, nSat, nHue)
nStim = numel(y_tune_raw);
if nStim ~= nSat * nHue
    y_cos = [];
    return;
end

y_cos = nan(size(y_tune_raw));

[~, HueGrid] = ind2sub([nSat nHue], (1:nStim).');
theta = 2*pi*(HueGrid-1)/nHue;

good = isfinite(y_tune_raw);
if nnz(good) < 5
    y_cos = [];
    return;
end

th_g = theta(good);
y_g  = y_tune_raw(good);

X = [ones(nnz(good),1), cos(th_g), sin(th_g)];
b = X \ y_g;

X_all = [ones(nStim,1), cos(theta), sin(theta)];
y_cos = X_all * b;
end
% ===== END FILE: core/analysis/DiscProbe_STA_LMSLINv5.m =====

% ===== FILE: core/analysis/compute_unit_color_tuning_wachtler.m =====
% ===== START =====
function unitTuning = compute_unit_color_tuning_wachtler(U, COL, config)

unitTuning = struct();

if ~isfield(U,'spk') || U.nTrials == 0
    unitTuning.fit = [];
    return;
end

hueAll = U.trials.hueID;
satAll = U.trials.satID;

nTr = numel(U.spk);
hasOutliers = isfield(U,'isOutlier') && numel(U.isOutlier) == nTr;

% time windows
sigWin = [0.05 0.15];
if isfield(config,'tuning') && isfield(config.tuning,'win')
    sigWin = config.tuning.win;
elseif isfield(U,'winEarly')
    sigWin = U.winEarly;
end

baseWin = [0.25 0.4];
if isfield(config,'tuning') && isfield(config.tuning,'baselineWin')
    baseWin = config.tuning.baselineWin;
end

durSig  = diff(sigWin);
durBase = diff(baseWin);

rateSig  = nan(nTr,1);
rateBase = nan(nTr,1);

for tt = 1:nTr
    spks = U.spk{tt};
    if isempty(spks), continue; end
    rateSig(tt)  = sum(spks >= sigWin(1)  & spks < sigWin(2))  ./ durSig;
    rateBase(tt) = sum(spks >= baseWin(1) & spks < baseWin(2)) ./ durBase;
end

rate = rateSig - rateBase;

% which saturations to use
useSats = [];
if isfield(config,'tuning') && isfield(config.tuning,'useSaturIDs') ...
        && ~isempty(config.tuning.useSaturIDs)
    useSats = config.tuning.useSaturIDs(:).';
end

satTol = 1e-3;
if isfield(config,'legacy') && isfield(config.legacy,'satTol')
    satTol = config.legacy.satTol;
end

% hue list = all hues that ever appear
hueList = unique(hueAll(isfinite(hueAll)));
hueList = hueList(:);

% saturation list: either requested sats or all sats present
if isempty(useSats)
    satList = unique(satAll(isfinite(satAll))).';
else
    satList = useSats(:).';
end

nH = numel(hueList);
nS = numel(satList);

meanRate   = nan(nH,nS);
semRate    = nan(nH,nS);
nTrialsMat = zeros(nH,nS);

validBase = isfinite(hueAll) & isfinite(satAll);
if hasOutliers
    validBase = validBase & ~U.isOutlier(:);
end
if ~isempty(useSats)
    satMask = false(size(satAll));
    for s = satList
        satMask = satMask | abs(satAll - s) < satTol;
    end
    validBase = validBase & satMask;
end

for ih = 1:nH
    h = hueList(ih);
    for is = 1:nS
        sTarget = satList(is);

        idx = isfinite(hueAll) & isfinite(satAll) & ...
              hueAll == h & abs(satAll - sTarget) < satTol;

        if hasOutliers
            idx = idx & ~U.isOutlier(:);
        end

        vals = rate(idx);
        nTrialsMat(ih,is) = numel(vals);
        if isempty(vals), continue; end

        meanRate(ih,is) = mean(vals,'omitnan');
        semRate(ih,is)  = std(vals,'omitnan') ./ sqrt(numel(vals));
    end
end

baselineHz = mean(rateBase(validBase),'omitnan');

thetaDeg = spatial_transforms.hue_to_angle(hueList, COL, config);

unitTuning.thetaID    = hueList;
unitTuning.thetaDeg   = thetaDeg;
unitTuning.saturIDs   = satList;
unitTuning.meanRate   = meanRate;
unitTuning.semRate    = semRate;
unitTuning.nTrials    = nTrialsMat;
unitTuning.baselineHz = baselineHz;

% choose which saturation(s) to use for the fit
if isempty(satList)
    unitTuning.fit = [];
    return;
end

fitMask = true(size(satList));
if ~isempty(useSats)
    fitMask = false(size(satList));
    for s = useSats
        fitMask = fitMask | abs(satList - s) < satTol;
    end
end

satIdx = find(fitMask);
if isempty(satIdx)
    satIdx = 1:numel(satList);
end

[~, kLocal] = max(satList(satIdx));
bestSatIdx = satIdx(kLocal);

theta = thetaDeg(:);
resp  = meanRate(:,bestSatIdx);

validFit = isfinite(theta) & isfinite(resp);
theta = theta(validFit);
resp  = resp(validFit);

if numel(resp) < 3 || all(resp <= 0 | isnan(resp))
    unitTuning.fit = [];
    return;
end

resp(resp < 0) = 0;

unitTuning.fit = fit_circular_tuning(theta, resp, struct());

end
% ===== END FILE: core/analysis/compute_unit_color_tuning_wachtler.m =====

% ===== FILE: core/analysis/compute_unit_tuning_lms.m =====
% ===== START =====
function tuning3D = compute_unit_tuning_lms(U, COL, config)
% Collapse trials onto unique [L-M, S, Lum] directions using early-window rates.

tuning3D = [];

if ~isfield(U,'colIdx') || ~isfield(U,'spk') || ~isfield(U,'trials')
    warning('compute_unit_tuning_lms: missing colIdx/spk/trials, skipping.');
    return;
end

if ~isfield(COL,'axis_LM') || ~isfield(COL,'axis_S') || ~isfield(COL,'axis_Lum')
    warning('compute_unit_tuning_lms: LMS axes missing in COL, skipping.');
    return;
end

% window: prefer Wachtler config, then U.winEarly, else [0 0.2]
if isfield(config,'tuning') && isfield(config.tuning,'win') && ~isempty(config.tuning.win)
    win = config.tuning.win;
elseif isfield(U,'winEarly')
    win = U.winEarly;
else
    win = [0 0.2];
end
dur = diff(win);

% per-trial firing rate in that window from U.spk
nSpkTrials = numel(U.spk);
rate_trial = nan(nSpkTrials,1);

for tt = 1:nSpkTrials
    spks = U.spk{tt};
    if isempty(spks)
        rate_trial(tt) = 0;
    else
        use = spks >= win(1) & spks < win(2);
        rate_trial(tt) = sum(use) / dur;
    end
end

% match colIdx and rate_trial lengths
idx   = U.colIdx(:);
nIdx  = numel(idx);
nRate = numel(rate_trial);
nUse  = min(nIdx, nRate);

if nUse == 0
    return;
end

idx        = idx(1:nUse);
rate_trial = rate_trial(1:nUse);

valid = ~isnan(idx) & isfinite(rate_trial);

% respect outlier flags if present (trimmed, column, same length)
if isfield(U,'isOutlier') && numel(U.isOutlier) >= nUse
    o = U.isOutlier(1:nUse);
    o = o(:);                % force column
    valid = valid & ~o;
end

valid = valid(:);           % make sure it's a column vector

idx = idx(valid);
r   = rate_trial(valid);

if isempty(idx)
    return;
end

LM  = COL.axis_LM(idx);
S   = COL.axis_S(idx);
Lum = COL.axis_Lum(idx);

X = [LM, S, Lum];

[uniqX,~,g] = unique(X,'rows','stable');
nDir = size(uniqX,1);

meanRate = nan(nDir,1);
semRate  = nan(nDir,1);
nPerDir  = nan(nDir,1);

for k = 1:nDir
    use = (g == k);
    vals = r(use);
    vals = vals(~isnan(vals));
    if isempty(vals)
        continue;
    end
    meanRate(k) = mean(vals);
    n = numel(vals);
    semRate(k)  = std(vals) ./ max(1, sqrt(n));
    nPerDir(k)  = n;
end

tuning3D.LM   = uniqX(:,1);
tuning3D.S    = uniqX(:,2);
tuning3D.Lum  = uniqX(:,3);
tuning3D.rate = meanRate;
tuning3D.sem  = semRate;
tuning3D.n    = nPerDir;
tuning3D.win  = win;
end
% ===== END FILE: core/analysis/compute_unit_tuning_lms.m =====

% ===== FILE: core/analysis/cosine_fit.m =====
% ===== START =====
function COS = cosine_fit(U, config)
% Cosine fit to hue tuning (first harmonic model)

hm = compute_hue_means(U);
hues = hm.hues;
y    = hm.rate_mean;

COS = struct();
COS.hues      = hues;
COS.theta_deg = nan(size(hues));
COS.y         = y;
COS.y_hat     = nan(size(y));
COS.beta      = nan(3,1);
COS.amp       = NaN;
COS.pref_deg  = NaN;
COS.R2        = NaN;

if all(~isfinite(y)) || all(y == 0 | isnan(y))
    return;
end

theta_deg = spatial_transforms.hue_to_angle(hues, [], config);
theta = theta_deg(:);
y = y(:);

X = [ones(size(theta)) cosd(theta) sind(theta)];
beta = X \ y;

y_hat = X * beta;

amp = hypot(beta(2), beta(3));
phi = atan2(-beta(3), beta(2));
pref_deg = mod(rad2deg(phi), 360);

SS_tot = sum((y - mean(y, 'omitnan')).^2, 'omitnan');
SS_res = sum((y - y_hat).^2, 'omitnan');
if SS_tot > 0
    R2 = 1 - SS_res / SS_tot;
else
    R2 = NaN;
end

COS.theta_deg = theta_deg;
COS.y_hat     = y_hat;
COS.beta      = beta;
COS.amp       = amp;
COS.pref_deg  = pref_deg;
COS.R2        = R2;

end
% ===== END FILE: core/analysis/cosine_fit.m =====

% ===== FILE: core/analysis/fit_circular_tuning.m =====
% ===== START =====
function fit = fit_circular_tuning(thetaDeg, resp, opts)
% Fit Wachtler-style circular normal tuning curve
% fc = A0 + A * exp((cos(phi - phi0) - 1) / sigma^2)
% Also returns chi-square goodness-of-fit and p-value.

    theta = deg2rad(thetaDeg(:));
    y     = resp(:);

    % remove NaNs
    valid = isfinite(theta) & isfinite(y);
    theta = theta(valid);
    y     = y(valid);

    fit = struct('A0',NaN,'A',NaN,'phi0_deg',NaN,'sigma',NaN, ...
                 'fwhm_deg',NaN,'R2',NaN,'chi2',NaN,'pChi2',NaN,'df',NaN);

    if numel(y) < 4
        return;
    end

    if nargin < 3
        opts = struct();
    end

    if ~isfield(opts,'A0_init')
        opts.A0_init = min(y);
    end
    if ~isfield(opts,'A_init')
        opts.A_init = max(y) - opts.A0_init;
    end

    [~, idxMax] = max(y);
    if ~isfield(opts,'phi0_init')
        opts.phi0_init = theta(idxMax);
    end
    if ~isfield(opts,'sigma_init')
        opts.sigma_init = 1;
    end

    p0 = [opts.A0_init, opts.A_init, opts.phi0_init, opts.sigma_init];

    % objective: sum of squared errors
    obj = @(p) sse_circ_model(p, theta, y);

    opts_fmin = optimset('Display','off');
    p_hat = fminsearch(obj, p0, opts_fmin);

    A0   = p_hat(1);
    A    = p_hat(2);
    phi0_rad = p_hat(3);
    phi0 = phi0_rad;
    sig  = max(p_hat(4), 1e-3);
    % A0   = p_hat(1);
    % A    = p_hat(2);
    % phi0 = p_hat(3);
    % sig  = max(p_hat(4), 1e-3);

    yhat = circ_model(p_hat, theta);

    % R^2
    ss_res = sum((y - yhat).^2);
    ymean  = mean(y);
    ss_tot = sum((y - ymean).^2);
    if ss_tot <= eps
        R2 = NaN;
    else
        R2 = 1 - ss_res / ss_tot;
    end

    % FWHM in deg
    cos_dphi = 1 - sig.^2 * log(2);
    cos_dphi = min(max(cos_dphi, -1), 1);
    dphi_rad = acos(cos_dphi);
    fwhm_deg = rad2deg(2 * dphi_rad);

    % chi-square goodness-of-fit
    % Use Poisson-like variance: var ~ mean rate
    varY = max(yhat, 1e-3);
    chi2 = sum((y - yhat).^2 ./ varY);

    k  = 4;                 % A0, A, phi0, sigma
    N  = numel(y);
    df = max(N - k, 1);     % for 8 dirs -> df = 4

    pChi2 = 1 - chi2cdf(chi2, df);

    fit.A0       = A0;
    fit.A        = A;
    fit.phi0_deg = mod(rad2deg(phi0), 360);
    fit.sigma    = sig;
    fit.fwhm_deg = fwhm_deg;
    fit.R2       = R2;
    fit.chi2     = chi2;
    fit.pChi2    = pChi2;
    fit.df       = df;
end

function yhat = circ_model(p, theta)
% circular normal model

    A0   = p(1);
    A    = p(2);
    phi0 = p(3);
    sig  = max(p(4), 1e-3);

    yhat = A0 + A * exp((cos(theta - phi0) - 1) ./ (sig.^2));
end

function sse = sse_circ_model(p, theta, y)
% sum of squared errors between data and model

    yhat = circ_model(p, theta);
    sse  = sum((y - yhat).^2);
end
% ===== END FILE: core/analysis/fit_circular_tuning.m =====

% ===== FILE: core/analysis/fourier_analysis.m =====
% ===== START =====
function FT = fourier_analysis(U, config)
% Fourier analysis of hue tuning (overall and per-saturation).

FT = struct();
if U.nTrials == 0
    return;
end

% defaults from original script
FOURIER.maxHarmonics = 8;
FOURIER.useHann      = true;
FOURIER.detrend      = true;

if isfield(config, 'fourier')
    fcfg = config.fourier;
    if isfield(fcfg,'maxHarmonics'), FOURIER.maxHarmonics = fcfg.maxHarmonics; end
    if isfield(fcfg,'useHann'),      FOURIER.useHann      = logical(fcfg.useHann); end
    if isfield(fcfg,'detrend'),      FOURIER.detrend      = logical(fcfg.detrend); end
end

hueID = U.trials.hueID;
satID = U.trials.satID;

% use early window to match other tuning stats
win = U.winEarly;
dur = diff(win);

nTr = numel(U.spk);
rateEarly = nan(nTr,1);
for tt = 1:nTr
    spks = U.spk{tt};
    if isempty(spks)
        rateEarly(tt) = 0;
    else
        spks = spks(spks >= win(1) & spks < win(2));
        rateEarly(tt) = numel(spks) / dur;
    end
end

% overall mean per hue
hueVals = unique(hueID(~isnan(hueID)));
hueVals = sort(hueVals(:).');
nHue    = numel(hueVals);

R_h = nan(nHue,1);
for i = 1:nHue
    h = hueVals(i);
    idx = (hueID == h);
    R_h(i) = mean(rateEarly(idx), 'omitnan');
end

% per-sat, per-hue matrix R_hs(:,si)
satVals = unique(satID(~isnan(satID)));
satVals = sort(satVals(:).');
nS      = numel(satVals);

R_hs = nan(nHue, nS);
for si = 1:nS
    s = satVals(si);
    for hi = 1:nHue
        h = hueVals(hi);
        idx = (hueID == h) & (satID == s);
        R_hs(hi,si) = mean(rateEarly(idx), 'omitnan');
    end
end

% overall Fourier over hues
FT_over = fourier_over_hues_local(R_h, FOURIER.maxHarmonics, FOURIER.useHann, FOURIER.detrend);

% per-sat Fourier
FT_cells = cell(nS,1);
for si = 1:nS
    yi = R_hs(:,si);
    if any(~isfinite(yi)), yi(~isfinite(yi)) = 0; end
    FT_cells{si} = fourier_over_hues_local(yi, FOURIER.maxHarmonics, FOURIER.useHann, FOURIER.detrend);
end

% make proper struct array
names = fieldnames(FT_cells{1});
FT_sat = repmat(struct(), nS, 1);
for si = 1:nS
    for f = 1:numel(names)
        nm = names{f};
        FT_sat(si).(nm) = FT_cells{si}.(nm);
    end
end

% derived overall metrics (mirroring your script)
K = min(FOURIER.maxHarmonics, floor(nHue/2));
FT_over.amp_norm  = FT_over.amp ./ max(FT_over.DC, eps);
FT_over.frac_noDC = FT_over.varExp;

w = FOURIER.useHann * hann(nHue,'periodic') + (~FOURIER.useHann) * ones(nHue,1);
PX   = abs(fft(R_h(:).*w)).^2;
totP = sum(PX);
noDC = sum(PX(2:end));

FT_over.DC_powerFrac      = PX(1)/totP;
FT_over.allPowerFrac_noDC = noDC/totP;
FT_over.frac_total        = (PX(2:1+K)/totP).';
FT_over.frac12_noDC       = sum(FT_over.frac_noDC(1:min(2,end)));
FT_over.frac12_wDC        = sum(PX(2:1+min(2,K)))/totP;
FT_over.fracTotal_wDC     = (PX(1) + sum(PX(2:1+K)))/totP;
[~, FT_over.k_max_amp]    = max(FT_over.amp);
[~, FT_over.k_max_var]    = max(FT_over.varExp);
FT_over.pref_deg_h1       = mod(-FT_over.phase_deg(1), 360);
FT_over.axis_deg_h2       = NaN;
if numel(FT_over.phase_deg) >= 2
    FT_over.axis_deg_h2 = mod(-FT_over.phase_deg(2)/2, 180);
end

FT.over      = FT_over;
FT.perSat    = FT_sat;
FT.saturIDs  = satVals;
FT.hueVals   = hueVals;

end

function FT = fourier_over_hues_local(y, maxHarm, useHann, doDetrend)

y = y(:);
n = numel(y);

if doDetrend
    y0 = y - mean(y, 'omitnan');
else
    y0 = y;
end
y0(~isfinite(y0)) = 0;

if useHann
    w = hann(n,'periodic');
else
    w = ones(n,1);
end

X = fft(y0 .* w);
DC = real(X(1))/n;

K  = min(maxHarm, floor(n/2));
harmonics = (1:K).';

ck = X(2:1+K);           % skip DC
amp = 2*abs(ck)/n;
ph  = angle(ck);
phase_deg = rad2deg(ph);

power_k = abs(ck).^2;
totPower_noDC = sum(power_k);
if totPower_noDC > 0
    varExp = power_k / totPower_noDC;
else
    varExp = zeros(size(power_k));
end

FT = struct();
FT.harmonics = harmonics;
FT.amp       = amp(:).';
FT.phase_deg = phase_deg(:).';
FT.varExp    = varExp(:).';
FT.DC        = DC;

end
% ===== END FILE: core/analysis/fourier_analysis.m =====

% ===== FILE: core/analysis/peak_model.m =====
% ===== START =====
function P = peak_model(U, config)
% simple peak-shape classifier based on Fourier harmonics
% labels: 'flat', 'unimodal', 'bimodal'

hm = compute_hue_means(U);
hues = hm.hues;
y    = hm.rate_mean;

P = struct();
P.hues = hues;
P.resp = y;

if all(~isfinite(y)) || all(y <= 0 | isnan(y))
    P.class     = "flat";
    P.amp1      = NaN;
    P.amp2      = NaN;
    P.amp_ratio = NaN;
    P.p_tuned   = NaN;
    P.p_bimodal = NaN;
    return;
end

y = y(:);
y = y - min(y);
if max(y) > 0
    y = y ./ max(y);
end

nH = numel(y);
if nH < 4
    P.class     = "flat";
    P.amp1      = NaN;
    P.amp2      = NaN;
    P.amp_ratio = NaN;
    P.p_tuned   = NaN;
    P.p_bimodal = NaN;
    return;
end

Y = fft(y);
pos = Y(2:floor(nH/2)+1);

amp1 = 2*abs(pos(1)) ./ nH;
if numel(pos) >= 2
    amp2 = 2*abs(pos(2)) ./ nH;
else
    amp2 = 0;
end

if amp1 > 0
    amp_ratio = amp2 ./ amp1;
else
    amp_ratio = NaN;
end

if amp1 < 0.1
    cls = "flat";
elseif amp_ratio > 0.5
    cls = "bimodal";
else
    cls = "unimodal";
end

P.class     = cls;
P.amp1      = amp1;
P.amp2      = amp2;
P.amp_ratio = amp_ratio;

P.p_tuned   = NaN;   % we can hook in permutation/Fourier p's later
P.p_bimodal = NaN;

end
% ===== END FILE: core/analysis/peak_model.m =====

% ===== FILE: core/analysis/peak_model_harmonic.m =====
% ===== START =====
function P = peak_model_harmonic(U, config)
% Peak-shape classifier using explicit harmonic models:
% flat vs 1st harmonic vs 1st+2nd harmonic

hm   = compute_hue_means(U);
hues = hm.hues;
y    = hm.rate_mean;

P = struct();
P.hues = hues;
P.resp = y;

if nargin < 2
    config = struct();
end

alpha = 0.05;
if isfield(config,'tuning') && isfield(config.tuning,'alphaHarmonic') ...
        && ~isempty(config.tuning.alphaHarmonic)
    alpha = config.tuning.alphaHarmonic;
end

% empty or all NaN → call it flat / undefined stats
if isempty(y) || all(~isfinite(y))
    P.class      = "flat";
    P.p_tuned    = NaN;
    P.p_bimodal  = NaN;
    P.r2_flat    = NaN;
    P.r2_1       = NaN;
    P.r2_12      = NaN;
    P.SSE0       = NaN;
    P.SSE1       = NaN;
    P.SSE2       = NaN;
    P.amp1       = NaN;
    P.amp2       = NaN;
    P.amp_ratio  = NaN;
    P.R2         = NaN;
    return;
end

y = y(:);
n = numel(y);

% not enough directions to do anything sensible
if n < 4
    P.class      = "flat";
    P.p_tuned    = NaN;
    P.p_bimodal  = NaN;
    P.r2_flat    = NaN;
    P.r2_1       = NaN;
    P.r2_12      = NaN;
    P.SSE0       = NaN;
    P.SSE1       = NaN;
    P.SSE2       = NaN;
    P.amp1       = NaN;
    P.amp2       = NaN;
    P.amp_ratio  = NaN;
    P.R2         = NaN;
    return;
end

% drop NaNs if any
isGood = isfinite(y);
if ~all(isGood)
    y = y(isGood);
    n = numel(y);
end

% equally spaced directions around the circle
theta = 2*pi*(0:n-1)'/n;

% design matrices
X0 = ones(n,1);                                % flat
X1 = [ones(n,1), cos(theta), sin(theta)];      % 1st harmonic
X2 = [X1, cos(2*theta), sin(2*theta)];         % 1st + 2nd

% fits
beta0 = X0 \ y;
beta1 = X1 \ y;
beta2 = X2 \ y;

yhat0 = X0*beta0;
yhat1 = X1*beta1;
yhat2 = X2*beta2;

res0 = y - yhat0;
res1 = y - yhat1;
res2 = y - yhat2;

SSE0 = sum(res0.^2);
SSE1 = sum(res1.^2);
SSE2 = sum(res2.^2);

yMean = mean(y);
SST   = sum((y - yMean).^2);

if SST > 0
    r2_flat = 1 - SSE0 / SST;
    r2_1    = 1 - SSE1 / SST;
    r2_12   = 1 - SSE2 / SST;
else
    r2_flat = NaN;
    r2_1    = NaN;
    r2_12   = NaN;
end

% model dimensions
p0 = 1;   % flat: intercept
p1 = 3;   % flat + cos + sin
p2 = 5;   % flat + cos + sin + cos2 + sin2

df0 = n - p0;
df1 = n - p1;
df2 = n - p2;

% F-test: flat vs 1st harmonic
if df1 > 0 && (SSE1 < SSE0)
    num01 = (SSE0 - SSE1) / (p1 - p0);
    den01 = SSE1 / df1;
    F01   = num01 / den01;
    p_tuned = 1 - fcdf(F01, p1 - p0, df1);
else
    p_tuned = 1;
end

% F-test: 1st vs 1st+2nd harmonic
if df2 > 0 && (SSE2 < SSE1)
    num12 = (SSE1 - SSE2) / (p2 - p1);
    den12 = SSE2 / df2;
    F12   = num12 / den12;
    p_bimodal = 1 - fcdf(F12, p2 - p1, df2);
else
    p_bimodal = 1;
end

ratioThresh = 0.4;


% quick FFT amplitudes (for compatibility / extra descriptors)
Yfft = fft(y - min(y));
pos  = Yfft(2:floor(n/2)+1);
amp1 = 0;
amp2 = 0;
if ~isempty(pos)
    amp1 = 2*abs(pos(1)) / n;
    if numel(pos) >= 2
        amp2 = 2*abs(pos(2)) / n;
    end
end
if amp1 > 0
    amp_ratio = amp2 / amp1;
else
    amp_ratio = NaN;
end


ratioThresh = 0.4;

% classification: first decide tuned vs flat from p_tuned,
% then upgrade unimodal → bimodal based on 2nd harmonic
if p_tuned >= alpha
    % not significantly tuned overall → flat
    cls = "flat";
else
    % significantly tuned overall → at least unimodal
    if (p_bimodal < alpha) %|| (amp_ratio >= ratioThresh)
        cls = "bimodal";
    else
        cls = "unimodal";
    end
end


P.class      = cls;
P.p_tuned    = p_tuned;
P.p_bimodal  = p_bimodal;
P.r2_flat    = r2_flat;
P.r2_1       = r2_1;
P.r2_12      = r2_12;
P.SSE0       = SSE0;
P.SSE1       = SSE1;
P.SSE2       = SSE2;
P.amp1       = amp1;
P.amp2       = amp2;
P.amp_ratio  = amp_ratio;
P.R2         = r2_12;   % full model R²
% ===== END FILE: core/analysis/peak_model_harmonic.m =====

% ===== FILE: core/analysis/permutation_test.m =====
% ===== START =====
function PT = permutation_test(U, config)
% permutation test on hue tuning structure
% null: shuffle hue labels across trials

if ~isfield(U, 'winEarly')
    error('U.winEarly missing.');
end

win = U.winEarly;
dur = diff(win);

nPerm = 1000;
alpha = 0.05;
if isfield(config, 'pt')
    if isfield(config.pt, 'nPerm'), nPerm = config.pt.nPerm; end
    if isfield(config.pt, 'alpha'), alpha = config.pt.alpha; end
end

hueID = U.trials.hueID;
hasOutliers = isfield(U, 'isOutlier') && numel(U.isOutlier) == height(U.trials);

nTr = numel(U.spk);
rate = nan(nTr,1);

for tt = 1:nTr
    spks = U.spk{tt};
    if isempty(spks)
        rate(tt) = 0;
    else
        rate(tt) = sum(spks >= win(1) & spks < win(2)) ./ dur;
    end
end

valid = isfinite(rate) & ~isnan(hueID);
if hasOutliers
    valid = valid & ~U.isOutlier(:);
end

rate = rate(valid);
hueID = hueID(valid);

hues = unique(hueID);
hues = hues(:);
nH   = numel(hues);

% observed tuning
obsMean = nan(nH,1);
for ih = 1:nH
    h = hues(ih);
    obsMean(ih) = mean(rate(hueID == h), 'omitnan');
end

obsStat = var(obsMean, 'omitnan');

% null distribution
nullStat = nan(nPerm,1);
nV = numel(rate);

for p = 1:nPerm
    permHue = hueID(randperm(nV));
    mPerm = nan(nH,1);
    for ih = 1:nH
        h = hues(ih);
        mPerm(ih) = mean(rate(permHue == h), 'omitnan');
    end
    nullStat(p) = var(mPerm, 'omitnan');
end

pVal = mean(nullStat >= obsStat);

PT.hues      = hues;
PT.obsMean   = obsMean;
PT.obsStat   = obsStat;
PT.nullStat  = nullStat;
PT.p         = pVal;
PT.alpha     = alpha;
PT.nPerm     = nPerm;
PT.winEarly  = win;

end
% ===== END FILE: core/analysis/permutation_test.m =====

% ===== FILE: core/analysis/rayleigh_test.m =====
% ===== START =====
function RY = rayleigh_test(U, config, COL)
% Rayleigh test on hue tuning (early window)

hm = compute_hue_means(U);
hues = hm.hues;
resp = hm.rate_mean;

if all(~isfinite(resp)) || all(resp <= 0 | isnan(resp))
    RY = struct();
    RY.hues      = hues;
    RY.theta_deg = nan(size(hues));
    RY.rate_mean = resp;
    RY.R         = NaN;
    RY.p         = NaN;
    RY.z         = NaN;
    RY.mu_deg    = NaN;
    RY.n         = numel(hues);
    return;
end

resp(resp < 0) = 0;

theta_deg = spatial_transforms.hue_to_angle(hues, COL, config);
theta = deg2rad(theta_deg);

w = resp(:);
C = sum(w .* cos(theta));
S = sum(w .* sin(theta));
Rvec = sqrt(C.^2 + S.^2);
R = Rvec ./ sum(w);

n = numel(hues);
z = n * R.^2;
p = exp(-z);

mu = atan2(S, C);
mu_deg = mod(rad2deg(mu), 360);

RY.hues      = hues;
RY.theta_deg = theta_deg;
RY.rate_mean = resp;
RY.R         = R;
RY.z         = z;
RY.p         = p;
RY.mu_deg    = mu_deg;
RY.n         = n;

end
% ===== END FILE: core/analysis/rayleigh_test.m =====

% ===== FILE: core/analysis/run_fourier_population_analysis.m =====
% ===== START =====
function run_fourier_population_analysis(MODE, dateToAnalyze, spaceTag)
% Fourier population keeper + analysis (single / pooled / VSS)

DO_PANEL_A        = true;
DO_PANEL_B        = true;
DO_UNIT_OVERLAYS  = false;
DO_POWER_SPECTRUM = true;

if nargin < 1 || isempty(MODE)
    MODE = 'all';                          % 'single', 'all', or 'vss'
end
if nargin < 2
    dateToAnalyze = '';
end
if nargin < 3 || isempty(spaceTag)
    spaceTag = 'DKL';
end

clc;
set(0,'DefaultFigureVisible','off');

% make sure repo is on path
rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

config   = load_config();
basePath = config.paths.base;             % e.g. /Users/.../DiscProbe
rgbPath  = config.paths.code;             % where rgb.csv lives

fourSubdir      = 'overall';
fourBase        = fullfile(basePath, 'Fourier');
fourFilePattern = sprintf('%%s_FourierHue_summary_%s.csv', spaceTag);

if ~exist(fourBase,'dir')
    mkdir(fourBase);
end

if strcmpi(MODE,'single') && (isempty(dateToAnalyze))
    error('For MODE=''single'', you need to pass dateToAnalyze, e.g. ''250513''.');
end

rgbCSV = fullfile(rgbPath, 'rgb.csv');
pal16  = load_palette16(rgbCSV);
if isempty(pal16)
    warning('rgb.csv missing or unreadable -> skipping hue ring.');
else
    fprintf('palette OK: min=%.3f max=%.3f\n', min(pal16(:)), max(pal16(:)));
end

% I/O root
fourBase = fullfile(basePath,'Fourier');
if ~exist(fourBase,'dir'), mkdir(fourBase); end

%% ========================== choose units (MODE) ==========================

switch lower(MODE)
    case 'single'
        fourFile = sprintf(fourFilePattern, dateToAnalyze);
        fourCSV  = fullfile(basePath, dateToAnalyze, fourSubdir, fourFile);
        if ~isfile(fourCSV)
            error('Missing Fourier file: %s', fourCSV);
        end

        outDir   = fullfile(fourBase, dateToAnalyze);
        if ~exist(outDir,'dir'), mkdir(outDir); end
        keepPath = fullfile(outDir, sprintf('%s_keep.csv', dateToAnalyze));

        T = readtable(fourCSV);
        T.session = repmat(string(dateToAnalyze), height(T), 1);

        [ordType, ordNum, tag] = unit_sort_keys(T);
        T.unit_tag  = tag; 
        T.typeOrder = ordType; 
        T.idNum     = ordNum;
        T           = sortrows(T, {'session','typeOrder','idNum','unit_tag'});

        if ~isfile(keepPath)
            Tkeep = make_keep_table_from_unit(T);
            writetable(Tkeep, keepPath);
            fprintf('Created keeper file: %s\nEdit keep=1 then rerun.\n', keepPath);
            return
        else
            Tkeep = readtable(keepPath);
            T     = innerjoin(T, Tkeep, 'Keys', {'session','unit'});
            Tuse  = T(T.keep==1, :);
            if isempty(Tuse)
                warning('No units marked keep=1. Nothing to analyze.');
                return
            end
            [ordType, ordNum, tag] = unit_sort_keys(Tuse);
            Tuse.unit_tag  = tag; 
            Tuse.typeOrder = ordType; 
            Tuse.idNum     = ordNum;
            Tuse = sortrows(Tuse, {'session','typeOrder','idNum','unit_tag'});
        end

    case 'all'
        % pooled analysis, keeper file in Fourier/ALL/ALL_keep.csv
        searchPattern = sprintf('*_FourierHue_summary_%s.csv', spaceTag);
        D = dir(fullfile(basePath, '*', fourSubdir, searchPattern));
        if isempty(D)
            error('No FourierHue_summary_%s.csv files found under %s/*/%s/', ...
                  spaceTag, basePath, fourSubdir);
        end

        sess  = strings(numel(D),1);
        paths = strings(numel(D),1);
        for i = 1:numel(D)
            paths(i) = string(fullfile(D(i).folder, D(i).name));
            parentOfSubdir = fileparts(D(i).folder);      % /basePath/<session>
            [~, sess(i)]   = fileparts(parentOfSubdir);   % <session> from that folder name
        end

        outDir   = fullfile(fourBase, 'ALL');
        if ~exist(outDir,'dir'), mkdir(outDir); end
        keepPath = fullfile(outDir, 'ALL_keep.csv');

        T = harmonize_fourier_table(paths, sess);

        [ordType, ordNum, tag] = unit_sort_keys(T);
        T.unit_tag  = tag; 
        T.typeOrder = ordType; 
        T.idNum     = ordNum;
        T           = sortrows(T, {'session','typeOrder','idNum','unit_tag'});

        if ~isfile(keepPath)
            Tkeep = make_keep_table_from_unit(T);
            writetable(Tkeep, keepPath);
            fprintf('Created pooled keeper: %s\nEdit keep=1 then rerun.\n', keepPath);
            return
        else
            Tkeep = readtable(keepPath);
            T     = innerjoin(T, Tkeep, 'Keys', {'session','unit'});
            Tuse  = T(T.keep==1, :);
            if isempty(Tuse)
                warning('No units marked keep=1. Nothing to analyze.');
                return
            end
            [ordType, ordNum, tag] = unit_sort_keys(Tuse);
            Tuse.unit_tag  = tag; 
            Tuse.typeOrder = ordType; 
            Tuse.idNum     = ordNum;
            Tuse = sortrows(Tuse, {'session','typeOrder','idNum','unit_tag'});
        end

        case 'vss'
        % pooled analysis using VSS Fourier CSVs + ALL_keep_vss.csv

        % where VSS outputs live
        if isfield(config,'paths') && isfield(config.paths,'output') && ~isempty(config.paths.output)
            vssRoot = fullfile(config.paths.output, 'vss');
        else
            vssRoot = fullfile(basePath, 'vss');
        end

        % find all per-date VSS Fourier summaries
        searchPattern = '*_vss_fourier_sat1.csv';
        D = dir(fullfile(vssRoot, '*', 'tables', searchPattern));
        if isempty(D)
            error('No VSS Fourier files (%s) found under %s/*/tables/', ...
                  searchPattern, vssRoot);
        end

        % where population outputs go
        outDir = fullfile(fourBase, 'VSS');
        if ~exist(outDir,'dir'), mkdir(outDir); end

        % VSS keep list (built by run_vss_peakmodels)
        keepPath = fullfile(basePath, 'ALL_keep_vss.csv');
        if ~isfile(keepPath)
            error('VSS keep list not found at %s. Run run_vss_peakmodels(''all'') first.', keepPath);
        end

        % build pooled Fourier table T from VSS CSVs
        T = table();
        for i = 1:numel(D)
            csvPath = fullfile(D(i).folder, D(i).name);

            % session folder is parent of "tables"
            sessFolder = fileparts(D(i).folder);   % .../vss/<date>
            [~, sess]  = fileparts(sessFolder);    % <date> (e.g. 241122)

            Ti = readtable(csvPath);
            Ti.session = repmat(string(sess), height(Ti), 1);

            % construct a "unit" column that matches ALL_keep_vss.unit
            % prefer unitLabel if present; else build from type + ID
            vn = string(Ti.Properties.VariableNames);
            if any(vn == "unitLabel")
                unitCol = string(Ti.unitLabel);
            else
                uType = strings(height(Ti),1);
                if any(vn == "unitType")
                    uType = string(Ti.unitType);
                end
                uID = strings(height(Ti),1);
                if any(vn == "unitID")
                    uID = string(Ti.unitID);
                end
                unitCol = uType + uID;   % "SU13", "MU4", etc.
            end
            Ti.unit = unitCol;

            % append
            T = [T; Ti]; %#ok<AGROW>
        end

        % sort units in a nice order
        [ordType, ordNum, tag] = unit_sort_keys(T);
        T.unit_tag  = tag;
        T.typeOrder = ordType;
        T.idNum     = ordNum;
        T           = sortrows(T, {'session','typeOrder','idNum','unit_tag'});

        % apply ALL_keep_vss.csv
        Tkeep = readtable(keepPath);
        if any(strcmpi(Tkeep.Properties.VariableNames, 'keep'))
            Tkeep = Tkeep(Tkeep.keep == 1, :);
        end

        % intersection: only units present in BOTH the VSS Fourier table and keep list
        Tuse = innerjoin(T, Tkeep, 'Keys', {'session','unit'});
        if isempty(Tuse)
            warning('No overlap between VSS Fourier table and ALL_keep_vss keep==1. Nothing to analyze.');
            return
        end

        % re-sort after join
        [ordType, ordNum, tag] = unit_sort_keys(Tuse);
        Tuse.unit_tag  = tag;
        Tuse.typeOrder = ordType;
        Tuse.idNum     = ordNum;
        Tuse = sortrows(Tuse, {'session','typeOrder','idNum','unit_tag'});

    otherwise
        error('MODE must be ''single'', ''all'', or ''vss''.');
end

%% ========================== core analysis (shared) =========================

v = string(Tuse.Properties.VariableNames);
pick = @(alts) alts(find(ismember(alts, v), 1, 'first'));

col_amp1   = pick(["amp1","over_amp1","k1_amp"]);
col_amp2   = pick(["amp2","over_amp2","k2_amp"]);
col_phase1 = pick(["phase1","over_phase1","k1_phase","phase1_deg"]);
col_phase2 = pick(["phase2","over_phase2","k2_phase","phase2_deg"]);
col_DC     = pick(["DC","over_DC","dc"]);
if any(cellfun(@isempty, {col_amp1,col_amp2,col_phase1,col_phase2,col_DC}))
    error('Table must contain k1/k2 amplitude & phase and DC (tried name variants).');
end

amp1   = Tuse.(col_amp1);
amp2   = Tuse.(col_amp2);
ph1    = mod(Tuse.(col_phase1), 360);
ph2raw = mod(Tuse.(col_phase2), 360);
ph2    = mod(ph2raw, 180);
DCv    = max(Tuse.(col_DC), eps);

% --- override with true preferred angles if available (VSS pipeline) ---
if any(v == "pref_deg_h1")
    ph1 = mod(Tuse.pref_deg_h1, 360);
end

if any(v == "axis_deg_h2")
    % axis is already 0–180; for axial plots we want orientation, not raw phase
    ph2raw = mod(Tuse.axis_deg_h2, 360);  % for axial histogram
    ph2    = mod(Tuse.axis_deg_h2, 180);  % for width vs orientation
end


% widths from each unit's mean-per-hue curve
nUnits = height(Tuse);
width_long  = nan(nUnits,1);
width_short = nan(nUnits,1);
for i = 1:nUnits
    sess_i = string(Tuse.session(i));
    tag_i  = derive_unit_tag(Tuse, i);
    [ok, ybar] = get_unit_ybar(basePath, sess_i, tag_i);
    if ~ok || isempty(ybar), continue; end
    [w_long, w_short] = fwhm_circular_from_ybar(ybar);
    width_long(i)  = w_long;
    width_short(i) = w_short;
end

% dominance split
idx_uni = amp1 > amp2;
idx_bi  = amp2 > amp1;

% saver tag
if strcmpi(MODE,'single')
    tagRun = string(dateToAnalyze);
elseif strcmpi(MODE,'vss')
    tagRun = "VSS";
else
    tagRun = "ALL";
end
sav = @(fn) fullfile(outDir, sprintf('%s_%s', tagRun, fn));

% ==== unified angular bin definition (shared by hist + hue ring) ====
nBins = 16;
d     = 360 / nBins;
binEdges_deg = (-d/2) : d : (360 - d/2);

opts = struct('offset_deg', 0, 'flip', false);

% phase vs width
fW = figure('Color','w','Position',[80 80 1000 430]);
subplot(1,2,1);
ii = find(idx_uni & ~isnan(width_long));
scatter(ph1(ii), width_long(ii), 46, 'k','filled'); grid on
xlabel('Phase k=1 (deg)'); ylabel('FWHM width (deg)'); title('k=1 dominant');
subplot(1,2,2);
jj = find(idx_bi & ~isnan(width_short));
scatter(ph2(jj), width_short(jj), 46, 'k','filled'); grid on
xlabel('Phase k=2 (deg, 0–180)'); ylabel('FWHM width (deg)'); title('k=2 dominant');
saveas(fW, sav('PhaseVsWidth_k1_k2.png')); close(fW);

% Panel A
if DO_PANEL_A
    fA = figure('Color','w','Position',[400 300 1800 900]);

    ax1 = polaraxes('Parent', fA);
    ax1.Position = [0.14 0.12 0.32 0.76];

    polarhist_counts_with_mean(ph1(idx_uni), binEdges_deg, false, ...
        'First harmonic dominant', ax1, pal16, opts);

    ax2 = polaraxes('Parent', fA);
    ax2.Position = [0.54 0.12 0.32 0.76];

    polarhist_counts_with_mean(ph2raw(idx_bi), binEdges_deg, true, ...
        'Second harmonic dominant', ax2, pal16, opts);

    saveas(fA, sav('PanelA_k1vsK2_dominance.png'));
    close(fA);
end

% Panel B
if DO_PANEL_B
    fB = figure('Color','w','Position',[400 300 1800 900]);

    ax3 = polaraxes('Parent', fB);
    ax3.Position = [0.14 0.12 0.32 0.76];
    polarhist_counts_with_mean(ph1, binEdges_deg, false, ...
        'All cells — 1st harmonic', ax3, pal16, opts);

    ax4 = polaraxes('Parent', fB);
    ax4.Position = [0.54 0.12 0.32 0.76];
    polarhist_counts_with_mean(ph2raw, binEdges_deg, true, ...
        'All cells — 2nd harmonic (axial)', ax4, pal16, opts);

    saveas(fB, sav('PanelB_allCells_k1_and_k2.png'));
    close(fB);
end

% CSV: phases + widths
outCSV = sav('KeptUnits_phase_widths.csv');
S = table( ...
    Tuse.session, Tuse.unit, ...
    amp1, ph1, width_long, ...
    amp2, ph2, width_short, DCv, ...
    'VariableNames', {'session','unit', ...
    'amp1','phase1_deg','width_FWHM_deg', ...
    'amp2','phase2_deg_0to180','width_FWHM_deg_ph2','DC'});
writetable(S, outCSV);
fprintf('Saved analysis to: %s\n', outCSV);

% per-unit overlays
if DO_UNIT_OVERLAYS
    hasUnitFile = ismember('unit_file', string(Tuse.Properties.VariableNames));
    for i = 1:nUnits
        sess_i = string(Tuse.session(i));
        if hasUnitFile && ~isempty(Tuse.unit_file{i})
            tag_i = string(Tuse.unit_file{i});
            if endsWith(tag_i,".mat"), tag_i = erase(tag_i,".mat"); end
        else
            tag_i = derive_unit_tag(Tuse, i);
        end
        try
            plot_fourier_fit_unit_k1k2(basePath, sess_i, tag_i);
        catch ME
            warning('Overlay failed for %s / %s: %s', sess_i, tag_i, ME.message);
        end
    end
end

% population power spectrum (no DC)
if DO_POWER_SPECTRUM
    P_all = [];
    sess_list = strings(0,1);
    unit_list = strings(0,1);
    N0 = NaN;

    for i = 1:nUnits
        sess_i = string(Tuse.session(i));
        tag_i  = derive_unit_tag(Tuse, i);
        [ok, ybar] = get_unit_ybar(basePath, sess_i, tag_i);
        if ~ok || isempty(ybar), continue; end
        y = double(ybar(:));
        if any(~isfinite(y)) || numel(y) < 4, continue; end
        if isnan(N0), N0 = numel(y); end
        if numel(y) ~= N0
            warning('Skipping %s (N mismatch)', tag_i);
            continue;
        end

        y = y - mean(y);
        N = numel(y);
        X = fft(y);
        Kmax = floor(N/2);
        Ak = (2/N) * abs(X(2:Kmax+1));
        Pk = Ak.^2;
        s  = sum(Pk);
        if s <= 0, continue; end

        P_all(end+1,1:Kmax) = (Pk(:)/s).'; %#ok<AGROW>
        sess_list(end+1,1)  = sess_i;      %#ok<AGROW>
        unit_list(end+1,1)  = tag_i;       %#ok<AGROW>
    end

    if isempty(P_all)
        warning('No per-unit power spectra computed. Nothing to plot.');
    else
        meanP  = mean(P_all, 1);
        k      = 1:size(P_all,2);
        nSpec  = size(P_all,1);

        f = figure('Color','w','Position',[120 120 560 420]);
        plot(k, meanP, '-o', 'LineWidth', 2, 'MarkerFaceColor', 'k'); grid on
        xlim([0.5, numel(k)+0.5]); xticks(k);
        xlabel('Harmonic k'); ylabel('Normalized power (no DC)');
        title(sprintf('%s: Population power spectrum (n=%d kept units; %d with valid spectra)', ...
              char(tagRun), nUnits, nSpec));
        saveas(f, sav('PowerSpectrum_noDC.png')); close(f);

        outUnitCSV = sav('PowerSpectrum_perUnit_noDC.csv');
        UnitTab = table(sess_list, unit_list, 'VariableNames', {'session','unit_tag'});
        Ktab = array2table(P_all, 'VariableNames', compose('k%d', k));
        writetable([UnitTab Ktab], outUnitCSV);

        outPopCSV = sav('PowerSpectrum_population_noDC.csv');
        PopTab = table(k.', meanP.', 'VariableNames', {'k','mean_norm_power'});
        writetable(PopTab, outPopCSV);

        fprintf('Saved power spectrum figure + CSVs in %s\n', outDir);
    end
end

%% ======================== helpers (local functions) ========================







% ------------------- rest of helpers unchanged -------------------

function tag_i = derive_unit_tag(T, i)
v = string(T.Properties.VariableNames);
if any(v=="unit_file") && ~isempty(T.unit_file{i})
    tag_i = string(erase(T.unit_file{i}, ".mat"));
elseif any(v=="unit_label") && ~isempty(T.unit_label{i})
    tag_i = string(T.unit_label{i});
else
    u = T.unit(i);
    if iscell(u), u = u{1}; end
    if isstring(u) || ischar(u)
        tag_i = string(u);
    elseif isnumeric(u)
        tag_i = "SU" + string(u);
    else
        tag_i = string(u);
    end
end
tag_i = strtrim(tag_i);
end

function [ok, ybar] = get_unit_ybar(basePath, date6, unitTag)
ok = false; ybar = [];
meanCSV = fullfile(basePath, char(date6), 'Figs', 'MeanNormPerHue_perUnit.csv');
if ~isfile(meanCSV), return; end
T = readtable(meanCSV);
vn = string(T.Properties.VariableNames);
isHueCol = startsWith(vn,"over_h_") | startsWith(vn,"over_hue_") | startsWith(vn,"over_h");
hueCols  = vn(isHueCol);
if isempty(hueCols), return; end
getN = @(s) sscanf(regexprep(s,'[^0-9]',''),'%d');
nums = arrayfun(getN, hueCols); [~, ord] = sort(nums); hueCols = hueCols(ord);

rowMatch = [];
dateStrs = string(T.date);
candDate = dateStrs == string(date6);
m = regexp(char(unitTag),'^(SU|MU)(\d+)$','tokens','once');
if ~isempty(m)
    idNum = str2double(m{2});
    if any(vn=="phy_id")
        cand = candDate & (T.phy_id == idNum);
        if any(cand), rowMatch = find(cand,1,'first'); end
    end
    if isempty(rowMatch) && any(vn=="unit_num")
        cand = candDate & (T.unit_num == idNum);
        if any(cand), rowMatch = find(cand,1,'first'); end
    end
end
if isempty(rowMatch)
    if any(vn=="unit_file")
        uf = erase(string(T.unit_file), ".mat");
        cand = candDate & strcmpi(uf, unitTag);
        if any(cand), rowMatch = find(cand,1,'first'); end
    elseif any(vn=="unit_label")
        cand = candDate & strcmpi(string(T.unit_label), unitTag);
        if any(cand), rowMatch = find(cand,1,'first'); end
    end
end
if isempty(rowMatch)
    cand = find(candDate);
    if ~isempty(cand), rowMatch = cand(1); end
end
if isempty(rowMatch), return; end

ybar = double(T{rowMatch, hueCols}).';
ok = true;
end

function [w_long, w_short] = fwhm_circular_from_ybar(ybar)
N = numel(ybar);
theta = linspace(0, 360, N+1); theta(end) = [];
fineN = 3600;
fineTheta = linspace(0, 360, fineN+1); fineTheta(end) = [];
yf = interp1(theta, ybar(:), fineTheta, 'pchip');
pmax = max(yf);
if ~isfinite(pmax) || pmax<=0
    w_long = NaN; w_short = NaN; return;
end
halfVal = pmax/2;
above = yf >= halfVal;
if ~any(above)
    w_long = 0; w_short = 0; return;
end
ab2 = [above, above];
d  = diff([false, ab2, false]);
starts = find(d==1);
ends   = find(d==-1) - 1;
mask = starts <= fineN;
starts = starts(mask); ends = ends(mask);
lens = ends - starts + 1;
degPerIdx = 360 / fineN;
widths = lens * degPerIdx;
if isempty(widths)
    w_long = 0; w_short = 0;
else
    w_long  = max(widths);
    w_short = min(widths);
end
end

function [typeOrder, idNum, tag] = unit_sort_keys(T)
v = string(T.Properties.VariableNames);
if any(v=="unit_file")
    tag = string(erase(T.unit_file, ".mat"));
elseif any(v=="unit_label")
    tag = string(T.unit_label);
else
    u = T.unit;
    if iscell(u)
        tag = string(u);
    elseif isstring(u) || ischar(u)
        tag = string(u);
    elseif isnumeric(u)
        tag = "SU" + string(u);
    else
        tag = string(u);
    end
end
tag = strtrim(tag);
up  = upper(tag);
isSU = startsWith(up, "SU");
isMU = startsWith(up, "MU");
typeOrder = ones(height(T),1) * 2;
typeOrder(isSU) = 0;
typeOrder(isMU) = 1;
numCell = regexp(tag, '\d+', 'match');
idNum = nan(height(T),1);
for i = 1:height(T)
    if ~isempty(numCell{i})
        idNum(i) = str2double(numCell{i}{1});
    end
end
end

function T = harmonize_fourier_table(paths, sess)
baseNum = ["amp1","over_amp1","k1_amp", ...
           "amp2","over_amp2","k2_amp", ...
           "phase1","over_phase1","k1_phase","phase1_deg", ...
           "phase2","over_phase2","k2_phase","phase2_deg", ...
           "DC","over_DC","dc", ...
           "phy_id","unit_num"];
baseStr = ["session","unit","unit_file","unit_label","date"];
T = table();
for i = 1:numel(paths)
    Ti = readtable(paths(i));
    Ti.session = repmat(sess(i), height(Ti), 1);
    To = table();
    for c = baseStr
        if any(strcmp(Ti.Properties.VariableNames, c))
            To.(c) = string(Ti.(c));
        else
            To.(c) = strings(height(Ti),1);
        end
    end
    for c = baseNum
        if any(strcmp(Ti.Properties.VariableNames, c))
            To.(c) = double(Ti.(c));
        else
            To.(c) = nan(height(Ti),1);
        end
    end
    T = [T; To]; %#ok<AGROW>
end
end

function Tkeep = make_keep_table_from_unit(T)
Tuniq = unique(T(:,{'session','unit'}), 'rows');

u  = string(Tuniq.unit);
up = upper(u);

isSU = startsWith(up, "SU");
isMU = startsWith(up, "MU");

typeOrder = ones(height(Tuniq),1) * 2;
typeOrder(isSU) = 0;
typeOrder(isMU) = 1;

numCell = regexp(u, '\d+', 'match');
idNum   = nan(height(Tuniq),1);
for i = 1:height(Tuniq)
    if ~isempty(numCell{i})
        idNum(i) = str2double(numCell{i}{1});
    end
end

Tuniq.typeOrder = typeOrder;
Tuniq.idNum     = idNum;

Tuniq = sortrows(Tuniq, {'session','typeOrder','idNum','unit'});

Tuniq.keep = zeros(height(Tuniq),1);
Tkeep = removevars(Tuniq, {'typeOrder','idNum'});
end

end

function pal16 = load_palette16(csvPath)
% Load 16 full-saturation RGB colors for the hue ring from rgb.csv.

pal16 = [];

if nargin < 1 || isempty(csvPath)
    warning('load_palette16:NoPath', 'No csvPath provided.');
    return;
end

if ~isfile(csvPath)
    warning('load_palette16:MissingFile', 'rgb.csv not found at %s', csvPath);
    return;
end

A = readmatrix(csvPath);
if isempty(A) || size(A,2) < 3
    warning('load_palette16:BadFile', 'rgb.csv has wrong shape or is empty.');
    return;
end

% assume every 3rd row is full-sat: 3,6,9,...
idx = 3:3:size(A,1);
if isempty(idx)
    warning('load_palette16:NoFullSatRows', ...
        'No full-saturation rows (3:3:end) found in %s', csvPath);
    return;
end

% we want 16 hues if possible
if numel(idx) < 16
    warning('load_palette16:FewHues', ...
        'Only %d full-sat hues found, need 16. Using what is available.', numel(idx));
    idx = idx(1:numel(idx));
else
    idx = idx(1:16);
end

P = double(A(idx,1:3));
P(~isfinite(P)) = 0;

% normalize:
%  - if max > 2, assume 0–255 and divide by 255
%  - if 1 < max <= 2, divide by max (weird 0–1 plus rogue 256 case)
mx = max(P(:));
if mx > 2
    P = P / 255;
elseif mx > 1
    P = P / mx;
end

% clip to [0,1] just in case
P = max(0, min(P, 1));

% rotate so the last hue sits at 0°, i.e., [16 1 2 ... 15]
if size(P,1) >= 16
    P = circshift(P, 1, 1);
end

pal16 = P;
end

function draw_hue_ring(ax, pal16, ring_in, ring_out, edges_deg)
% pal16: 16×3 RGB in [0,1], row 1 = bin 1 color
% ring_in / ring_out: inner/outer radius of the ring
% edges_deg: 1×(N+1) bin edges used for the histogram

if isempty(pal16) || isempty(ax) || ~isvalid(ax)
    return;
end

edges_deg = edges_deg(:).';
N = numel(edges_deg) - 1;

if size(pal16,1) > N
    pal16 = pal16(1:N,:);
end

pal16(~isfinite(pal16)) = 0;
pal16 = max(0, min(pal16,1));

hp = gobjects(N,1);
for k = 1:N
    t1 = deg2rad(edges_deg(k));
    t2 = deg2rad(edges_deg(k+1));
    tt = linspace(t1, t2, 40);

    th_poly = [tt, fliplr(tt)];
    r_poly  = [ring_in * ones(size(tt)), ...
               fliplr(ring_out * ones(size(tt)))];

    hp(k) = patch(ax, th_poly, r_poly, pal16(k,:), ...
        'EdgeColor','none', ...
        'HandleVisibility','off');
end

uistack(hp,'bottom');
end

function polarhist_counts_with_mean(theta_deg, nBins_or_edges, isAxial, ttl, ax, pal16, opts)
% opts.offset_deg (default 0) shifts phase origin
% opts.flip       (default false) flips direction (clockwise vs CCW)

if nargin < 7 || isempty(opts), opts = struct; end
if ~isfield(opts,'offset_deg'), opts.offset_deg = 0; end
if ~isfield(opts,'flip'),       opts.flip       = false; end

sgn = opts.flip * (-1) + (~opts.flip) * 1;

% ---------- handle nBins vs explicit bin edges ----------
if isscalar(nBins_or_edges)
    nBins = nBins_or_edges;
    edges_deg = linspace(0, 360, nBins+1);
else
    edges_deg = nBins_or_edges(:).';
    nBins     = numel(edges_deg) - 1;
end

% ---------- clean angles ----------
theta_deg = theta_deg(:);
theta_deg = theta_deg(isfinite(theta_deg));
nCells    = numel(theta_deg);

theta_deg = mod(theta_deg, 360);
theta_deg = mod(opts.offset_deg + sgn*theta_deg, 360);

hold(ax,'on');

% ---------- directional vs axial ----------
if isAxial
    t = mod(theta_deg, 180);          % 0..180
    theta_plot = [t; t+180];          % duplicate 180° apart
    w = ones(size(theta_plot));
else
    theta_plot = theta_deg;
    w = ones(size(theta_deg));
end

% ---------- binning ----------
binIdx = discretize(theta_plot, edges_deg);
valid  = ~isnan(binIdx);
counts = accumarray(binIdx(valid), w(valid), [nBins 1], @sum, 0).';

% enforce perfect mirroring for axial case
if isAxial
    half = nBins/2;
    for k = 1:half
        m = 0.5 * (counts(k) + counts(k+half));
        counts(k)      = m;
        counts(k+half) = m;
    end
end

% ---------- radial layout ----------
maxC = max(counts);
if maxC <= 0, maxC = 1; end

if maxC <= 5
    step = 1;
elseif maxC <= 10
    step = 2;
else
    step = ceil(maxC/5);
end
outerGrid = step * ceil(maxC/step);

rt = 0:step:outerGrid;
if rt(end) ~= outerGrid
    rt = [rt outerGrid];
end
rticks(ax, rt);
ax.RTickLabel = string(ax.RTick);

ring_gap   = 0.10 * outerGrid;
ring_thick = 0.18 * outerGrid;

ring_in  = outerGrid + ring_gap;
ring_out = ring_in + ring_thick;
outerR   = ring_out + 0.1 * outerGrid;
rlim(ax, [0, outerR]);

% ---------- histogram ----------
polarhistogram(ax, ...
    'BinEdges',  deg2rad(edges_deg), ...
    'BinCounts', counts, ...
    'FaceColor', [0.6 0.6 0.6], ...
    'EdgeColor', 'none');

% ---------- theta grid / spokes ----------
theta_spokes = edges_deg(1:end-1);

ax.ThetaZeroLocation = 'right';          % 0° at +[L−M]
ax.ThetaDir          = 'counterclockwise';
ax.ThetaTick         = theta_spokes;
ax.ThetaTickLabel    = repmat({''}, size(theta_spokes));
ax.ThetaGrid         = 'on';
ax.RGrid             = 'on';
ax.GridAlpha         = 0.25;
ax.Layer             = 'top';

% ---------- numeric labels ----------
majorAngles = [0 90 180 270];
rNum = ring_out + 0.05 * outerGrid;

for k = 1:numel(majorAngles)
    ang = majorAngles(k);
    th  = deg2rad(ang);

    hal = 'center';
    val = 'middle';
    switch ang
        case 90
            val = 'bottom';
        case 270
            val = 'top';
    end

    text(ax, th, rNum, sprintf('%d°', ang), ...
        'HorizontalAlignment', hal, ...
        'VerticalAlignment',   val, ...
        'FontSize',            9);
end

% ---------- DKL axis labels ----------
labelAngles = [0 90 180 270];
labelText   = { '+[L−M]', '+[S−(L+M)]', '−[L−M]', '−[S−(L+M)]' };

rLabel = ring_out + 0.18 * outerGrid;

for k = 1:numel(labelAngles)
    ang = labelAngles(k);
    th  = deg2rad(ang);

    hal = 'center';
    val = 'middle';
    rot = 0;

    switch ang
        case 0
            rot = -90;
        case 180
            rot = 90;
        case 90
            rot = 0;
            val = 'top';
        case 270
            rot = 0;
            val = 'bottom';
    end

    text(ax, th, rLabel, labelText{k}, ...
        'HorizontalAlignment', hal, ...
        'VerticalAlignment',   val, ...
        'FontWeight',          'bold', ...
        'Rotation',            rot);
end

% ---------- title ----------
ht = title(ax, sprintf('%s (n=%d)', ttl, nCells), 'FontWeight', 'bold');
ht.Units = 'normalized';
pos = ht.Position;
pos(2) = 1.06;
ht.Position = pos;

% ---------- hue ring ----------
if nargin >= 6 && ~isempty(pal16)
    draw_hue_ring(ax, pal16, ring_in, ring_out, edges_deg);
end
end
% ===== END FILE: core/analysis/run_fourier_population_analysis.m =====

% ===== FILE: core/analysis/summarize_tuning_population.m =====
% ===== START =====
function pop = summarize_tuning_population(allUnitTuning, config)
% Collect preferred directions and widths across units

    nUnits = numel(allUnitTuning);
    phi0 = nan(nUnits,1);
    fwhm = nan(nUnits,1);
    R2   = nan(nUnits,1);

    for ii = 1:nUnits
        ut = allUnitTuning{ii};
        if isempty(ut) || isempty(ut.fit)
            continue;
        end
        phi0(ii) = ut.fit.phi0_deg;
        fwhm(ii) = ut.fit.fwhm_deg;
        R2(ii)   = ut.fit.R2;
    end

    good = R2 >= 0.5;   % tweak threshold if necessary

    pop.phi0_deg = phi0;
    pop.fwhm_deg = fwhm;
    pop.R2       = R2;
    pop.good     = good;
end
% ===== END FILE: core/analysis/summarize_tuning_population.m =====

% ===== FILE: core/analysis/discprobe/anova_analysis.m =====
% ===== START =====
function A = anova_analysis(U, config)
% two-way ANOVA: hue × saturation on early window rate

win = U.winEarly;
dur = diff(win);

nTr = numel(U.spk);
rate = nan(nTr,1);

for tt = 1:nTr
    spks = U.spk{tt};
    if isempty(spks)
        rate(tt) = 0;
    else
        rate(tt) = sum(spks >= win(1) & spks < win(2)) ./ dur;
    end
end

hueID = U.trials.hueID;
satID = U.trials.satID;

hasOutliers = isfield(U, 'isOutlier') && numel(U.isOutlier) == nTr;

valid = isfinite(rate) & isfinite(hueID) & isfinite(satID);
if hasOutliers
    valid = valid & ~U.isOutlier(:);
end

rate  = rate(valid);
hueID = hueID(valid);
satID = satID(valid);

if numel(rate) < 10
    A = struct();
    A.p_hue = NaN;
    A.p_sat = NaN;
    A.p_int = NaN;
    A.tbl   = {};
    A.n     = numel(rate);
    return;
end

[p, tbl, statsAn] = anovan(rate, {hueID, satID}, ...
    'model', 'full', ...
    'varnames', {'hue','sat'}, ...
    'display', 'off');

A.p_hue  = p(1);
A.p_sat  = p(2);
A.p_int  = p(3);
A.tbl    = tbl;
A.stats  = statsAn;
A.n      = numel(rate);

end
% ===== END FILE: core/analysis/discprobe/anova_analysis.m =====

% ===== FILE: core/analysis/discprobe/compute_hue_means.m =====
% ===== START =====
function stats = compute_hue_means(U)
% mean firing per hue (early window, across all sats)

hue = U.trials.hueID;
hue(isnan(hue)) = [];

hues = unique(hue);
hues = hues(:);

nH = numel(hues);
rate_mean = nan(nH,1);
rate_sem  = nan(nH,1);
n_trials  = nan(nH,1);

win = U.winEarly;
dur = diff(win);

hasOutliers = isfield(U, 'isOutlier') && numel(U.isOutlier) == height(U.trials);

for ih = 1:nH
    h = hues(ih);
    use = U.trials.hueID == h;
    if hasOutliers
        use = use & ~U.isOutlier(:);
    end

    idx = find(use);
    if isempty(idx)
        continue;
    end

    r = nan(numel(idx),1);
    for ii = 1:numel(idx)
        t = idx(ii);
        spks = U.spk{t};
        if isempty(spks)
            r(ii) = 0;
        else
            r(ii) = sum(spks >= win(1) & spks < win(2)) ./ dur;
        end
    end

    rate_mean(ih) = mean(r, 'omitnan');
    rate_sem(ih)  = std(r, 'omitnan') ./ sqrt(numel(r));
    n_trials(ih)  = numel(r);
end

stats.hues      = hues;
stats.rate_mean = rate_mean;
stats.rate_sem  = rate_sem;
stats.n_trials  = n_trials;
stats.win       = win;

end
% ===== END FILE: core/analysis/discprobe/compute_hue_means.m =====

% ===== FILE: core/analysis/vss/calc_harmonic_fstats.m =====
% ===== START =====
function [F, p_val, df_num, df_den] = calc_harmonic_fstats(varExp, nHues, nParams)
if nargin < 3 || isempty(nParams)
    nParams = 2;
end

R2 = varExp;

if isnan(R2)
    F = NaN;
    p_val = NaN;
    df_num = NaN;
    df_den = NaN;
    return;
end

df_num = nParams;
df_den = nHues - nParams - 1;

if df_den <= 0
    F = NaN;
    p_val = NaN;
    df_num = NaN;
    df_den = NaN;
    return;
end

if R2 >= 1
    F = Inf;
    p_val = 0;
    return;
end

F = (R2 / df_num) / ((1 - R2) / df_den);
p_val = 1 - fcdf(F, df_num, df_den);
end
% ===== END FILE: core/analysis/vss/calc_harmonic_fstats.m =====

% ===== FILE: core/analysis/vss/classify_fourier_peak.m =====
% ===== START =====
function [peakClassStr, isTunedFourier, kMax, fracMax] = classify_vss_fourier_peak(P, FT, config)
peakClassStr   = "flat";
isTunedFourier = false;
kMax           = NaN;
fracMax        = NaN;

if isempty(FT) || ~isfield(FT,'over') || isempty(FT.over)
    return;
end

F = FT.over;

if ~isfield(F,'varExp') || isempty(F.varExp)
    return;
end

K = numel(F.varExp);
kMax = F.k_max_var;
if isnan(kMax) || kMax < 1 || kMax > K
    return;
end

fracMax = F.varExp(kMax);

% thresholds
alpha    = 0.05;
minFrac  = 0.20;

if isfield(config,'vss')
    if isfield(config.vss,'alpha'),   alpha   = config.vss.alpha;   end
    if isfield(config.vss,'minFrac'), minFrac = config.vss.minFrac; end
end

% significance from peak_model stats (now using parametric P.p_tuned)
p_tuned   = NaN;
p_bimodal = NaN;
if isfield(P,'p_tuned'),   p_tuned   = P.p_tuned;   end
if isfield(P,'p_bimodal'), p_bimodal = P.p_bimodal; end

sigTuned = ~isnan(p_tuned)   && (p_tuned   < alpha);
sigBi    = ~isnan(p_bimodal) && (p_bimodal < alpha);

if ~sigTuned
    return;
end

if kMax > 2 || fracMax < minFrac
    return;
end

if kMax == 1
    peakClassStr   = "unimodal";
    isTunedFourier = true;
elseif kMax == 2
    if sigBi || isnan(p_bimodal)
        peakClassStr   = "bimodal";
        isTunedFourier = true;
    else
        peakClassStr   = "flat";
        isTunedFourier = false;
    end
end

end
% ===== END FILE: core/analysis/vss/classify_fourier_peak.m =====

% ===== FILE: core/analysis/vss/subset_unit_to_max_saturation.m =====
% ===== START =====
function U_high = subset_unit_to_max_saturation(U, maxSatVal)
U_high = U;

if nargin < 2 || isempty(maxSatVal)
    satAll = U.trials.satID;
    satAll = satAll(~isnan(satAll));
    if isempty(satAll)
        U_high.nTrials = 0;
        return;
    end
    maxSatVal = max(satAll);
end

satID = U.trials.satID;
satTol = 1e-3;
use = abs(satID - maxSatVal) < satTol;

if isfield(U, 'isOutlier') && numel(U.isOutlier) == height(U.trials)
    use = use & ~U.isOutlier(:);
end

idx = find(use);
if isempty(idx)
    U_high.trials  = U.trials([]);
    U_high.spk     = U.spk([]);
    U_high.nTrials = 0;
    if isfield(U_high, 'isOutlier')
        U_high.isOutlier = U_high.isOutlier([]);
    end
    return;
end

U_high.trials  = U.trials(idx, :);
U_high.spk     = U.spk(idx);
U_high.nTrials = numel(idx);

if isfield(U, 'isOutlier')
    U_high.isOutlier = U.isOutlier(idx);
end
end
% ===== END FILE: core/analysis/vss/subset_unit_to_max_saturation.m =====

% ===== FILE: core/data_loading/load_or_make_trial_index.m =====
% ===== START =====
function Tidx = load_or_make_trial_index(S, COL, config)
% Load or build the per-session TrialIndex table.
%
% If a CSV already exists for this session, load it.
% Otherwise, call make_trial_index_table and save a new CSV.
%

if nargin < 3
    config = struct();
end

% figure out the session name (Jocamo_250513 style if present)
if isfield(S, 'sessionID') && ~isempty(S.sessionID)
    sessName = char(S.sessionID);
else
    sessName = char(S.dateStr);
end

% ---------- figure out where the CSV should live ----------

idxDir = '';

% preferred: use per-session root dir via get_session_paths
if exist('get_session_paths','file') == 2
    try
        P = get_session_paths(config, sessName);
        if isfield(P, 'session') && ~isempty(P.session)
            idxDir = P.session;   % <DiscProbe base>/Jocamo_250513
        end
    catch ME
        warning('load_or_make_trial_index: get_session_paths failed (%s). Falling back.', ME.message);
    end
end

% fall back to base/<session> or output/<session> if needed
if isempty(idxDir)
    if isfield(config, 'paths') && isfield(config.paths, 'base') ...
            && ~isempty(config.paths.base)
        idxDir = fullfile(config.paths.base, sessName);
    elseif isfield(config, 'paths') && isfield(config.paths, 'output') ...
            && ~isempty(config.paths.output)
        idxDir = fullfile(config.paths.output, sessName);
    else
        % no place to save → build in memory only
        Tidx = make_trial_index_table(S, COL, config);
        return;
    end
end

if ~exist(idxDir, 'dir')
    mkdir(idxDir);
end

idxCSV = fullfile(idxDir, sprintf('%s_TrialIndex.csv', sessName));

% ---------- decide whether to reuse or rebuild ----------

forceRebuild = false;
if isfield(config, 'trials') && isfield(config.trials, 'forceRebuildIndex') ...
        && ~isempty(config.trials.forceRebuildIndex)
    forceRebuild = logical(config.trials.forceRebuildIndex);
end

% try to load existing CSV
if isfile(idxCSV) && ~forceRebuild
    try
        Tidx = readtable(idxCSV);
        return;
    catch ME
        warning('load_or_make_trial_index: failed to read %s (%s). Rebuilding.', ...
                idxCSV, ME.message);
    end
end

% build fresh and write it where we just decided
Tidx = make_trial_index_table(S, COL, config);

try
    writetable(Tidx, idxCSV);
catch ME
    warning('load_or_make_trial_index: could not write %s (%s).', idxCSV, ME.message);
end

end
% ===== END FILE: core/data_loading/load_or_make_trial_index.m =====

% ===== FILE: core/data_loading/load_session.m =====
% ===== START =====
function S = load_session(sessionID, config)
% LOAD_SESSION - Load one DiscProbe session and pack spikes into S.
% S.phyIDs    -> The specific Unit IDs (e.g. 13, 42)
% S.unitTypes -> Cell array {'SU', 'MU'} matching the IDs

    if isstring(sessionID)
        sessionID = char(sessionID);
    end
    info = parse_session_id(sessionID); 
    
    dateStr = char(info.dateStr);
    
    if strlength(info.monkey) > 0
        monkey = char(info.monkey);
    else
        monkey = config.monkey;
    end
    
    PATHS = struct();
    PATHS.baseDiscProbeLocal = config.paths.base;
    PATHS.baseDiscProbesCode = config.paths.code;
    PATHS.baseOut            = config.paths.output;
    
    expFile = locate_expTrialsDisc(PATHS, monkey, dateStr);
    if ~isfile(expFile)
        error('Could not find ExpTrialsDisc file for %s (got: %s)', sessionID, expFile);
    end
    
    t = tic;
    raw = load(expFile);
    fprintf('Loaded %s in %.1f s.\n', expFile, toc(t));
    
    if ~isfield(raw, 'ExptTrialsDisc') || ~isfield(raw, 'ExptInfo')
        error('Expected ExptTrialsDisc and ExptInfo in %s', expFile);
    end
    
    ExptTrialsDisc = raw.ExptTrialsDisc;
    ExptInfo       = raw.ExptInfo;
    
    if ~isfield(ExptInfo, 'nSU') || ~isfield(ExptInfo, 'nMU')
        error('ExptInfo is missing nSU/nMU in %s', expFile);
    end
    
    nSU  = ExptInfo.nSU;
    nMU  = ExptInfo.nMU;
    nTOT = nSU + nMU;
    
    nTrials = size(ExptTrialsDisc, 1);
    if nTOT <= 0 || nTrials == 0
        error('No units or no trials in %s', expFile);
    end
    
    cols = 10:(9+nTOT); 
    if size(ExptTrialsDisc, 2) < max(cols)
        error('Expected at least %d columns in ExptTrialsDisc, got %d.', ...
            max(cols), size(ExptTrialsDisc,2));
    end
    
    if isfield(config, 'time') && isfield(config.time, 'fullWin')
        winFull = config.time.fullWin;
    else
        winFull = [0 0.4]; 
    end
    
    spkCols = ExptTrialsDisc(:, cols); 
    trimfun = @(x) x(x >= winFull(1) & x <= winFull(2)); 
    spkCols = cellfun(trimfun, spkCols, 'UniformOutput', false);
    
    spk_all = cell(1, nTOT);
    mrk_all = cell(1, nTOT);
    mrkWin   = [winFull(1) winFull(2)]; 
    mrk_cell = repmat({mrkWin}, nTrials, 1); 
    
    for uu = 1:nTOT 
        unit_tr = spkCols(:, uu);
        for tt = 1:nTrials 
            v = unit_tr{tt}; 
            if isempty(v)
                unit_tr{tt} = [];
            else
                unit_tr{tt} = double(v(:).'); 
            end
        end
        spk_all{uu} = unit_tr; 
        mrk_all{uu} = mrk_cell;
    end
    
    % --- CONSTRUCT IDs AND TYPES ---
    if isfield(ExptInfo, 'spk_ID_SU') && isfield(ExptInfo, 'spk_ID_MU')
        phyIDs_all = [ExptInfo.spk_ID_SU(:); ExptInfo.spk_ID_MU(:)];
    else
        phyIDs_all = (1:nTOT).';
    end
    
    % Create unitTypes manually since it doesn't exist in raw file
    unitTypes_all = [repmat({'SU'}, nSU, 1); repmat({'MU'}, nMU, 1)];

    % Output Structure
    S = struct();
    S.sessionID      = info.sessionID;  
    S.dateStr        = dateStr;
    S.monkey         = monkey;
    S.expFile        = expFile;
    S.ExptInfo       = ExptInfo;
    S.ExptTrialsDisc = ExptTrialsDisc;
    S.nTrials        = nTrials;
    S.nUnits         = nTOT;
    S.spk            = spk_all;
    S.mrk            = mrk_all;
    
    % Use phyIDs as the main identifier
    S.phyIDs         = phyIDs_all;    
    
    % Keep unitIDs as a copy for compatibility
    S.unitIDs        = phyIDs_all;    
    
    % Crucial: Add unitTypes so downstream scripts don't fail
    S.unitTypes      = unitTypes_all;  
    
    S.trNum          = (1:nTrials).';
end
% ===== END FILE: core/data_loading/load_session.m =====

% ===== FILE: core/data_loading/locate_expTrialsDisc.m =====
% ===== START =====
function expFile = locate_expTrialsDisc(PATHS, MONKEY, date6)
% find the ExpTrialsDisc .mat file for a date

    %location should be /DiscProbe/250513/Jacomo_250513_ExpTrialsDisc.mat
    cand1 = fullfile(PATHS.baseDiscProbeLocal, date6, ...
                     sprintf('%s_%s_ExpTrialsDisc.mat', MONKEY, date6));
    if isfile(cand1)
        expFile = cand1;
        return;
    end

    % but you can also search anywhere under baseDiscProbeLocal
    pat = sprintf('*%s*ExpTrialsDisc.mat', date6);
    D = dir(fullfile(PATHS.baseDiscProbeLocal, '**', pat));

    if ~isempty(D)
        [~, ix] = max([D.datenum]);
        expFile = fullfile(D(ix).folder, D(ix).name);
        fprintf('[info] Using ExpTrialsDisc at: %s\n', expFile);
        return;
    end

    error('Could not locate an ExpTrialsDisc .mat for date %s (base=%s)', ...
          date6, PATHS.baseDiscProbeLocal);
end
% ===== END FILE: core/data_loading/locate_expTrialsDisc.m =====

% ===== FILE: core/data_loading/make_trial_index_table.m =====
% ===== START =====
function T = make_trial_index_table(S, COL, config)
% build trial per trial table for one session.
%this is helpful to have an account of exactly what happened during each
%trial, what rgb was presented etc etc etc 
%
% Uses DiscprobeColor and master ProbeCols/ProbeColIDs.

ExptTrialsDisc = S.ExptTrialsDisc;
nTrials        = size(ExptTrialsDisc, 1);
dateStr        = S.dateStr;

if nTrials == 0
    error('make_trial_index_table: no trials found for %s.', dateStr);
end

trial = (1:nTrials).';

% grab trial RGB from DiscprobeColor (first column of ExptTrialsDisc)
try
    trlCols = cell2mat(cellfun(@(s) s.DiscprobeColor(:).', ...
                               ExptTrialsDisc(:,1), ...
                               'UniformOutput', false));
catch
    error('make_trial_index_table: could not read DiscprobeColor from ExptTrialsDisc(:,1) for %s.', dateStr);
end

trlCols = double(trlCols);

% master probe RGB and IDs from COL
if ~isfield(COL, 'probeCols') || ~isfield(COL, 'probeIDs')
    error('make_trial_index_table: COL.probeCols / COL.probeIDs missing.');
end

masterRGB = double(COL.probeCols(:,1:3));
masterIDs = double(COL.probeIDs);

% direct row matches (these are trials whose kofiko rgb is an exact match
% to the rgbs in our updatedprobecoleids
[isHit, loc] = ismember(trlCols, masterRGB, 'rows');

trlColIDs = nan(size(trlCols,1), size(masterIDs,2));
trlColIDs(isHit, :) = masterIDs(loc(isHit), :);

% handle non exact matches with nearest neighbor snapping
need  = find(~isHit);
nnIdx = [];
dists = [];

if ~isempty(need)
    if exist('knnsearch','file')
        [nnIdx, dists] = knnsearch(masterRGB, trlCols(need,:));
    else
        nnIdx = zeros(numel(need),1);
        dists = zeros(numel(need),1);
        for ii = 1:numel(need)
            x   = trlCols(need(ii),:);
            dif = masterRGB - x;
            dst = sqrt(sum(dif.^2,2));
            [dists(ii), nnIdx(ii)] = min(dst);
        end
    end

    % tolerance for snapping in RGB space (we could change this but 5 is
    % perfect)
    tol = 5;
    use = dists <= tol;

    trlColIDs(need(use), :) = masterIDs(nnIdx(use), :);
else
    use   = [];
    dists = [];
end

% bookkeeping for match type and mapping into master list
match_type = strings(nTrials,1);
match_type(:) = "unmatched";

master_row = nan(nTrials,1);
rgb_dist   = nan(nTrials,1);

master_row(isHit) = loc(isHit);
match_type(isHit) = "exact";

if ~isempty(need)
    got = need(use);
    master_row(got) = nnIdx(use);
    match_type(got) = "snap";
    rgb_dist(got)   = dists(use);
end

% unpack IDs and RGB per trial
IDs = trlColIDs;
RGB = trlCols;

% DKL coordinates via spatial_transforms util
dklL = nan(nTrials,1);
dklM = nan(nTrials,1);
dklS = nan(nTrials,1);

if isfield(COL, 'dklRows') && ~isempty(COL.dklRows)
    [dklL, dklM, dklS] = spatial_transforms.index_to_dkl(master_row, COL);
end

% LMS coordinates via COL.lms (if available)
lmsL = nan(nTrials,1);
lmsM = nan(nTrials,1);
lmsS = nan(nTrials,1);

if isfield(COL, 'lms') && ~isempty(COL.lms)
    LMS = COL.lms;             % [nProbes x 3]
    nL  = size(LMS,1);

    idx   = double(master_row);
    valid = ~isnan(idx) & idx >= 1 & idx <= nL;

    lmsL(valid) = LMS(idx(valid), 1);
    lmsM(valid) = LMS(idx(valid), 2);
    lmsS(valid) = LMS(idx(valid), 3);
end

% build trial table
T = table();

T.dateStr = repmat(string(dateStr), nTrials, 1);
T.unitID  = nan(nTrials,1);      % filled in prepare_unit

T.trial   = trial;

T.hueID   = IDs(:,1);            % hue index (1–nHue)
T.satID   = IDs(:,2);            % saturation ID
T.elevID  = IDs(:,3);            % elevation ID

T.dklLum  = dklL;
T.dklRG   = dklM;
T.dklYV   = dklS;

T.lmsL    = lmsL;
T.lmsM    = lmsM;
T.lmsS    = lmsS;

T.matchType = match_type;
T.rgbDist   = rgb_dist;
T.masterRow = master_row;

T.R = RGB(:,1);
T.G = RGB(:,2);
T.B = RGB(:,3);

if isfield(S, 'trTypes')
    T.trType = S.trTypes(:);
else
    T.trType = trial;
end

% choose folder name: Jocamo_250513 style if available, otherwise fallback to date only
if isfield(S, 'sessionID') && ~isempty(S.sessionID)
    sessName = char(S.sessionID);
else
    sessName = char(dateStr);
end

% save per-session trial index CSV ONLY in the session folder
if isfield(config, 'paths') && isfield(config.paths, 'base') && ~isempty(config.paths.base)
    sessDir = fullfile(config.paths.base, sessName);
    if ~isfolder(sessDir)
        mkdir(sessDir);
    end
    outCSV = fullfile(sessDir, sprintf('%s_TrialIndex.csv', sessName));
    try
        writetable(T, outCSV);
    catch ME
        warning('make_trial_index_table: could not write trial index CSV to %s (%s).', outCSV, ME.message);
    end
end

end
% ===== END FILE: core/data_loading/make_trial_index_table.m =====

% ===== FILE: core/data_loading/parse_session_id.m =====
% ===== START =====
function info = parse_session_id(id)
% parse session identifier into components
% can be:
%   '250513'
%   'Jacomo_250513'
%   'Jacomo_250513_anything" in case there is two sessions
%
% Returns struct with fields:
%   sessionID  - full string as given
%   dateStr    - 6-digit YYMMDD if found, otherwise original string
%   monkey     - leading chunk before the 6-digit date, if any
%   suffix     - anything after the date, if any

    s = string(id);

    info = struct( ...
        'sessionID', s, ...
        'dateStr',   "", ...
        'monkey',    "", ...
        'suffix',    "" );

    %usual pattern is Monkey_250513_optionalStuff
    tok = regexp(char(s), ...
        '^(?<monkey>[^_]+)_(?<date>\d{6})(?<suffix>.*)$', ...
        'names');

    if ~isempty(tok)
        info.monkey  = string(tok.monkey);
        info.dateStr = string(tok.date);
        info.suffix  = string(tok.suffix);
        return;
    end

    % otherwise try to find any 6-digit date inside
    tok2 = regexp(char(s), '(?<date>\d{6})', 'names', 'once');
    if ~isempty(tok2)
        info.dateStr = string(tok2.date);
    else
        % worst case treat whole string as "dateStr"
        info.dateStr = s;
    end
end
% ===== END FILE: core/data_loading/parse_session_id.m =====

% ===== FILE: core/data_loading/untitled.m =====
% ===== START =====
% ===== END FILE: core/data_loading/untitled.m =====

% ===== FILE: core/preprocessing/detect_outliers.m =====
% ===== START =====
function U = detect_outliers(U, config)
% mark and drop trial outliers based on early window firing rates.

if ~isfield(U, 'spk') || ~isfield(U, 'trials')
    return;
end

hueID = U.trials.hueID;
satID = U.trials.satID;

win = U.winEarly;
dur = diff(win); %duration 

nTr = numel(U.spk);
rateEarly = nan(nTr,1);

for tt = 1:nTr
    spks = U.spk{tt};
    if isempty(spks)
        rateEarly(tt) = 0;
    else
        spks = spks(spks >= win(1) & spks < win(2));
        rateEarly(tt) = numel(spks) / dur; %average spikes
    end
end

% default is tukey 
useNorm = false;
method  = 'tukey';   % 'tukey' or 'mad'
minN    = 5; %min number of spikes in window to do analysis 

if isfield(config, 'boxPlots')
    if isfield(config.boxPlots, 'useNorm')
        useNorm = logical(config.boxPlots.useNorm);
    end
    if isfield(config.boxPlots, 'method')
        method = lower(config.boxPlots.method);
    end
    if isfield(config.boxPlots, 'minN')
        minN = config.boxPlots.minN;
    end
end

% normalization of firing rates if normalization was chosen 
if useNorm
    r = rateEarly;
    r = r - min(r);
    denom = max(r);
    if denom <= 0
        vals = zeros(size(r));
    else
        vals = r ./ denom;
    end
else
    vals = rateEarly;
end

is_out = false(nTr,1); %assume everyone is in at the beginning

satVals = unique(satID(~isnan(satID))); %unique sats
hueVals = unique(hueID(~isnan(hueID))); %unique hue values

for si = 1:numel(satVals)
    s = satVals(si);
    for hi = 1:numel(hueVals)
        h = hueVals(hi);

        idx = find(satID == s & hueID == h & isfinite(vals));
        if numel(idx) < minN
            continue;
        end

        x = vals(idx);

        switch method
            case 'tukey'
                q = quantile(x, [0.25 0.75]);
                I = q(2) - q(1);
                if I <= 0
                    bad = false(size(idx));
                else
                    lo = q(1) - 1.5*I;
                    hi = q(2) + 1.5*I;
                    bad = (x < lo) | (x > hi);
                end

            case 'mad'
                med = median(x);
                if exist('mad', 'file')
                    srob = 1.4826 * mad(x, 1);
                else
                    srob = 1.4826 * median(abs(x - med));
                end
                if srob <= 0
                    bad = false(size(idx));
                else
                    z = abs(x - med) / srob;
                    bad = z > 3.5;
                end

            otherwise
                bad = false(size(idx));
        end

        if any(bad)
            is_out(idx(bad)) = true;
        end
    end
end

keep = ~is_out;

if ~any(is_out)
    U.isOutlier = is_out;
    return;
end

U.isOutlier = is_out;

U.spk     = U.spk(keep);
if isfield(U, 'mrk') && numel(U.mrk) == nTr
    U.mrk = U.mrk(keep);
end

U.trials  = U.trials(keep,:);
U.nTrials = sum(keep);

end
% ===== END FILE: core/preprocessing/detect_outliers.m =====

% ===== FILE: core/preprocessing/filter_zero_spike_units.m =====
% ===== START =====
function S = filter_zero_spike_units(S, config)
% drop units with 0 spikes across all trials in the full window

if ~isfield(S, 'spk') || isempty(S.spk)
    return;
end

if isfield(config, 'time') && isfield(config.time, 'fullWin')
    winFull = config.time.fullWin;
else
    winFull = [0 0.4]; %default time window
end

t0  = winFull(1);
t1  = winFull(2);
nU  = S.nUnits;
nTr = S.nTrials;

totalPerUnit = zeros(1, nU);

for uu = 1:nU %for every unit
    spk_cell = S.spk{uu};
    if numel(spk_cell) ~= nTr %does the unit have n trials?
        error('S.spk{%d} has %d trials, expected %d.', uu, numel(spk_cell), nTr);
    end

    c = 0;
    for tt = 1:nTr %for every trial
        spks = spk_cell{tt};
        if isempty(spks)
            continue;
        end
        spks = spks(spks >= t0 & spks < t1);
        c = c + numel(spks);
    end
    totalPerUnit(uu) = c;
end

keepUnits = totalPerUnit > 0; %we keep all units whose total is greater than 0

if all(keepUnits)
    return;
end

fprintf('Removing %d/%d units with 0 spikes.\n', sum(~keepUnits), nU);

S.spk= S.spk(keepUnits);
if isfield(S, 'mrk') && numel(S.mrk) == nU
    S.mrk = S.mrk(keepUnits);
end
if isfield(S, 'unitIDs') && numel(S.phyIDs) == nU
    S.phyIDs = S.phyIDs(keepUnits);
end

S.nUnits = sum(keepUnits);

if isfield(S, 'ExptInfo')
    EI = S.ExptInfo;

    %aligning nsu and msu so everyone is in the same page
    if isfield(EI, 'nSU') && isfield(EI, 'nMU') && ...
       isfield(EI, 'spk_ID_SU') && isfield(EI, 'spk_ID_MU')

        nSU = EI.nSU;
        nMU = EI.nMU;

        if numel(keepUnits) == nSU + nMU
            suMask = keepUnits(1:nSU);
            muMask = keepUnits(nSU+1:nSU+nMU);

            EI.spk_ID_SU = EI.spk_ID_SU(suMask);
            EI.spk_ID_MU = EI.spk_ID_MU(muMask);

            EI.nSU = numel(EI.spk_ID_SU);
            EI.nMU = numel(EI.spk_ID_MU);
        end
    end

    EI.unit_new2old = find(keepUnits);
    S.ExptInfo      = EI;
end

if S.nUnits == 0
    error('All units had zero spikes after filtering. Nothing to analyze.');
end

end
% ===== END FILE: core/preprocessing/filter_zero_spike_units.m =====

% ===== FILE: core/utils/add_lms_axes.m =====
% ===== START =====
function COL = add_lms_axes(COL)
% Build L-M / S / Lum axes from COL.lms (columns = [L M S])

if ~isfield(COL,'lms')
    error('COL.lms missing. Make sure lms.csv is loaded into COL.lms.');
end

L = COL.lms(:,1);
M = COL.lms(:,2);
S = COL.lms(:,3);

COL.axis_LM  = L - M;
COL.axis_S   = S;
COL.axis_Lum = L + M;
end
% ===== END FILE: core/utils/add_lms_axes.m =====

% ===== FILE: core/utils/attach_color_index.m =====
% ===== START =====
function U = attach_color_index(U, COL)
% Attach U.colIdx = row in COL.probeIDs / COL.lms per trial.
% Assumes U.trials has hueID, saturID, elevID that match COL.probeIDs columns.

nT = height(U.trials);
colIdx = nan(nT,1);

hue  = U.trials.hueID;
sat  = U.trials.satID;
elev = [];

if isfield(U.trials,'elevID')
    elev = U.trials.elevID;
end

ids = COL.probeIDs;  % [144 x ?], assume columns: 1=hue, 2=sat, 5=elev

for t = 1:nT
    if isnan(hue(t)) || isnan(sat(t))
        continue
    end

    match = ids(:,1) == hue(t) & ids(:,2) == sat(t);

    if ~isempty(elev)
        match = match & ids(:,5) == elev(t);
    end

    k = find(match,1,'first');
    if ~isempty(k)
        colIdx(t) = k;
    end
end

U.colIdx = colIdx;
end
% ===== END FILE: core/utils/attach_color_index.m =====

% ===== FILE: core/utils/build_all_keep_from_wachtler.m =====
% ===== START =====
function build_all_keep_from_wachtler(wachtlerRoot, outKeepPath)
% Build a global ALL_keep.csv from per-session Wachtler fits.
%
% Scans:
%   <DiscProbe>/wachtler/<date>/tables/<date>_wachtler_fits.csv
% and creates:
%   <DiscProbe>/ALL_keep.csv
%
% Unit tags are always SU/MU + phy number (unitID), never unitNum.

config = load_config();

% where the wachtler/<date>/tables live
if nargin < 1 || isempty(wachtlerRoot)
    wachtlerRoot = fullfile(config.paths.base, 'wachtler');
end

% where to write ALL_keep.csv
if nargin < 2 || isempty(outKeepPath)
    outKeepPath = fullfile(config.paths.base, 'ALL_keep.csv');
end

if ~exist(wachtlerRoot, 'dir')
    error('Wachtler root folder not found: %s', wachtlerRoot);
end

% all per-session fits like /wachtler/<date>/tables/<date>_wachtler_fits.csv
D = dir(fullfile(wachtlerRoot, '*', 'tables', '*_wachtler_fits.csv'));
if isempty(D)
    error('No wachtler_fits.csv files found under %s', wachtlerRoot);
end

fprintf('Found %d Wachtler fit files.\n', numel(D));

T = table();

for i = 1:numel(D)
    csvPath = fullfile(D(i).folder, D(i).name);
    [~, dateStr] = fileparts(fileparts(D(i).folder)); % folder above "tables"
    fprintf('  Loading %s...\n', dateStr);

    Ti = readtable(csvPath);
    Ti.session = repmat(string(dateStr), height(Ti), 1);

    % attach unitType (SU/MU) if we can, using per-session unit_summary
    unitTypeCol = repmat("SU", height(Ti), 1); % default if we can't find better

    % first: if fits already have a unitType-ish column, trust it
    vTi = string(Ti.Properties.VariableNames);
    if any(vTi == "unitType")
        unitTypeCol = string(Ti.unitType);
    elseif any(vTi == "unit_type")
        unitTypeCol = string(Ti.unit_type);
    else
        % otherwise, try to read <output>/<date>/tables/<date>_unit_summary.csv
        if isfield(config, 'paths') && isfield(config.paths, 'output') ...
                && ~isempty(config.paths.output)

            sumFile = fullfile(config.paths.output, dateStr, 'tables', ...
                               sprintf('%s_unit_summary.csv', dateStr));
            if isfile(sumFile)
                try
                    Ts = readtable(sumFile);
                    vS = string(Ts.Properties.VariableNames);

                    if any(vS == "unitID") && any(vS == "unitType") ...
                            && any(vTi == "unitID")

                        idSum   = Ts.unitID;
                        typeSum = string(Ts.unitType);
                        idFit   = Ti.unitID;

                        unitTypeCol = repmat("SU", height(Ti), 1);
                        for k = 1:height(Ti)
                            match = (idSum == idFit(k));
                            if any(match)
                                unitTypeCol(k) = typeSum(find(match, 1, 'first'));
                            end
                        end
                    end
                catch ME
                    warning('Could not read unit_summary for %s: %s', dateStr, ME.message);
                end
            end
        end
    end

    Ti.unitType = unitTypeCol;
    T = [T; Ti]; %#ok<AGROW>
end

vn = string(T.Properties.VariableNames);

% session
sess = string(T.session);

% unitType as string
if any(vn == "unitType")
    unitType = string(T.unitType);
elseif any(vn == "unit_type")
    unitType = string(T.unit_type);
else
    unitType = repmat("SU", height(T), 1);
end

% phy number: always from unitID (or phy_id if that ever shows up)
if any(vn == "unitID")
    ids = T.unitID;
elseif any(vn == "phy_id")
    ids = T.phy_id;
else
    error('No unitID or phy_id column found in Wachtler fits tables.');
end

% build SU/MU + phy number tag, e.g. SU13, MU45
unitTag = strings(height(T), 1);
for j = 1:height(T)
    unitTag(j) = sprintf('%s%d', unitType(j), ids(j));
end

% define keep based on available metrics
keep = zeros(height(T), 1);

if any(vn == "isTunedR2")
    keep = T.isTunedR2 ~= 0;
elseif any(vn == "pChi2")
    keep = T.pChi2 < 0.05;
elseif any(vn == "R2")
    keep = T.R2 >= 0.2;
else
    error('No isTunedR2, pChi2, or R2 column found in the fits files.');
end

Tbl = table(sess, unitTag, keep, ...
    'VariableNames', {'session','unit','keep'});

Tbl = unique(Tbl, 'rows');
Tbl = sortrows(Tbl, {'session','unit'});

writetable(Tbl, outKeepPath);
fprintf('\n✅ Wrote ALL_keep.csv with %d units to %s\n', height(Tbl), outKeepPath);
end
% ===== END FILE: core/utils/build_all_keep_from_wachtler.m =====

% ===== FILE: core/utils/build_all_keep_vss.m =====
% ===== START =====
function build_all_keep_vss(DATES)
% Build ALL_keep_vss.csv from per-session VSS peakModel CSVs.
%
% Looks for:
%   <DiscProbe base>/vss/<date>/tables/<date>_vss_peakModel_sat1.csv
% and writes:
%   <DiscProbe base>/ALL_keep_vss.csv
%
% Each row = one unit.
% keep = 1 for unimodal/bimodal units, 0 otherwise.

clc;

rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

config = load_config();

if ~isfield(config,'paths') || ~isfield(config.paths,'base') || isempty(config.paths.base)
    error('build_all_keep_vss:NoBasePath', ...
        'config.paths.base is missing or empty; cannot locate vss folder.');
end

baseRoot = config.paths.base;          % e.g. /Users/.../DiscProbe
vssRoot  = fullfile(baseRoot, 'vss');  % e.g. /Users/.../DiscProbe/vss

% handle DATES input
if nargin < 1 || isempty(DATES)
    if ~isfolder(vssRoot)
        warning('build_all_keep_vss:NoVSSRoot', ...
            'No VSS root folder found at %s', vssRoot);
        DATES = {};
    else
        D = dir(vssRoot);
        isDir  = [D.isdir];
        names  = {D.name};
        names  = names(isDir & ~ismember(names, {'.','..'}));
        isDate = cellfun(@(s) ~isempty(regexp(s, '^\d{6}$', 'once')), names);
        DATES  = sort(names(isDate));
    end
else
    if ischar(DATES) || isstring(DATES)
        DATES = {char(DATES)};
    end
end

allKeepRows = table();  % accumulate across dates

for d = 1:numel(DATES)
    dateStr    = char(DATES{d});
    tablesRoot = fullfile(vssRoot, dateStr, 'tables');
    csvPath    = fullfile(tablesRoot, sprintf('%s_vss_peakModel_sat1.csv', dateStr));

    if ~isfile(csvPath)
        warning('build_all_keep_vss:NoCSV', ...
            'No VSS peakModel CSV for %s at %s', dateStr, csvPath);
        continue;
    end

    T = readtable(csvPath);

    if height(T) == 0
        continue;
    end

    % need unitLabel and some kind of peakClass
    if ~ismember('unitLabel', T.Properties.VariableNames)
        warning('build_all_keep_vss:NoUnitLabel', ...
            'Table %s has no unitLabel column, skipping', csvPath);
        continue;
    end

    % prefer the original peak_model classification if present
    if ismember('peakClass_orig', T.Properties.VariableNames)
        cls = string(T.peakClass_orig);
    elseif ismember('peakClass', T.Properties.VariableNames)
        cls = string(T.peakClass);
    else
        warning('build_all_keep_vss:NoPeakClass', ...
            'Table %s has no peakClass/peakClass_orig column, skipping', csvPath);
        continue;
    end

    n = height(T);

    % everyone gets a row; keep = 1 only for uni/bi
    isUniBi = ismember(cls, ["unimodal","bimodal"]);
    keepCol = double(isUniBi);

    dateCol  = repmat(string(dateStr), n, 1);
    unitCol  = string(T.unitLabel(:));

    if ismember('unitType', T.Properties.VariableNames)
        unitTypeCol = string(T.unitType(:));
    else
        unitTypeCol = repmat(missing, n, 1);
    end

    if ismember('unitID', T.Properties.VariableNames)
        unitIDCol = T.unitID(:);
    else
        unitIDCol = nan(n, 1);
    end

    peakClassCol = cls(:);

    keepRowsThisDate = table( ...
        dateCol, ...
        unitCol, ...
        keepCol, ...
        peakClassCol, ...
        unitTypeCol, ...
        unitIDCol, ...
        'VariableNames', {'session','unit','keep','peakClass','unitType','unitID'});

    allKeepRows = [allKeepRows; keepRowsThisDate]; %#ok<AGROW>
end

keepFile = fullfile(baseRoot, 'ALL_keep_vss.csv');

if isempty(allKeepRows)
    allKeepRows = table( ...
        strings(0,1), ...   % session
        strings(0,1), ...   % unit
        zeros(0,1),   ...   % keep
        strings(0,1), ...   % peakClass
        strings(0,1), ...   % unitType
        zeros(0,1),   ...   % unitID
        'VariableNames', {'session','unit','keep','peakClass','unitType','unitID'});
end

try
    writetable(allKeepRows, keepFile);
    fprintf('Wrote ALL_keep_vss.csv with %d rows to:\n  %s\n', ...
        height(allKeepRows), keepFile);
catch ME
    warning('build_all_keep_vss:WriteFailed', ...
        'Could not write ALL_keep_vss.csv: %s', ME.message);
end

end
% ===== END FILE: core/utils/build_all_keep_vss.m =====

% ===== FILE: core/utils/generate_dkl_lms_tables.m =====
% ===== START =====
% calibration/generate_dkl_lms_tables.m
function generate_dkl_lms_tables()

S = load('/Users/tellezi2/Documents/DiscProbesCode/masterRGBUpdated.mat');
fullRGB = double(S.masterRGB);

if max(fullRGB(:)) > 1
    RGB = fullRGB/255;
else
    RGB = fullRGB;
end

rx=0.6280; ry=0.3310; gx=0.3059; gy=0.5826; bx=0.1639; by=0.0617;
Wr=18.6469/2; Wg=75.8449/2; Wb=10.5313/2;

R = cie2lms(rx,ry); G = cie2lms(gx,gy); B = cie2lms(bx,by);
Lr=R(1); Lg=G(1); Lb=B(1);
Mr=R(2); Mg=G(2); Mb=B(2);
Sr=R(3); Sg=G(3); Sb=B(3);

M_rgb2lms = [Lr Lg Lb; Mr Mg Mb; Sr Sg Sb] * diag([Wr Wg Wb]);
LMS = RGB * M_rgb2lms.';

[ldrgyvMAT, lmrgyvMAT, CIS] = calibMethod2_fb_01_10_2024();
Minv = inv(ldrgyvMAT);

DKL = 2*(RGB - 0.5) * Minv.';

dklname = fullfile(pwd,'dkl.csv');
lmsname = fullfile(pwd,'lms.csv');
rgbname = fullfile(pwd,'rgb.csv');

writematrix(DKL, dklname);
writematrix(LMS, lmsname);
writematrix(RGB, rgbname);

save('calib_outputs.mat','RGB','LMS','DKL','M_rgb2lms','ldrgyvMAT','lmrgyvMAT','CIS');

end

function v = cie2lms(a,b)
x=a; y=b; z=1-x-y;
M=[ .15514 .54316 -.03286; -.15514 .45684 .03286; 0 0 .01608];
lms = (M*[x;y;z]).';
den = lms(1)+lms(2);
v = [lms(1)/den, lms(2)/den, lms(3)/den];
end
% ===== END FILE: core/utils/generate_dkl_lms_tables.m =====

% ===== FILE: core/utils/get_legacy_trial_mask.m =====
% ===== START =====
function mask = get_legacy_trial_mask(U, config)

mask = true(U.nTrials,1);

if ~isfield(config,'legacy') || ~isfield(config.legacy,'useLegacySats')
    return;
end
if ~config.legacy.useLegacySats
    return;
end

if ~isfield(U,'trials') || ~isfield(U.trials,'satID')
    return;
end

sats = config.legacy.sats(:).';
tol  = config.legacy.satTol;

satID = U.trials.satID;
maskS = false(size(satID));

for s = sats
    maskS = maskS | abs(satID - s) < tol;
end

mask = mask & maskS;

end
% ===== END FILE: core/utils/get_legacy_trial_mask.m =====

% ===== FILE: core/utils/get_session_paths.m =====
% ===== START =====
function P = get_session_paths(config, sessionID)
% Build canonical paths for a DiscProbe session.
%
% sessionID can be:
%   '250513'
%   'Jacomo_250513'
%   'Jacomo_250513_am'
%
% UPDATE: Auto-detects 'Monkey_Date' folder if only 'Date' is provided.

    info = parse_session_id(sessionID);
    base = config.paths.base;
    
    sessDir = char(info.sessionID); 

    % --- SMART FOLDER DETECTION ---
    % 1. Check if the folder simply exists as-is (e.g. '250513')
    pathAsIs = fullfile(base, sessDir);
    
    if ~exist(pathAsIs, 'dir')
        % 2. If not, and the ID looks like just a date (no underscore),
        %    search for a matching "Monkey_Date" folder.
        if ~contains(sessDir, '_')
            % Look for any folder ending in this date string (e.g. '*_250513')
            candidates = dir(fullfile(base, ['*_' sessDir]));
            candidates = candidates([candidates.isdir]);
            
            % Remove '.' and '..'
            candidates = candidates(~ismember({candidates.name}, {'.','..'}));
            
            if ~isempty(candidates)
                % Success! Use the existing Monkey_Date folder (e.g. 'Jacomo_250513')
                sessDir = candidates(1).name;
                
                % Update info to match the found folder
                info = parse_session_id(sessDir); 
                
            elseif isfield(config, 'monkey') && ~isempty(config.monkey)
                % 3. Folder doesn't exist, but we have a preferred Monkey in config.
                %    Construct the proper name for the new folder.
                sessDir = sprintf('%s_%s', config.monkey, sessDir);
            end
        end
    end
    % ------------------------------

    P = struct();

    % root session folder
    P.session = fullfile(base, sessDir);

    % standard subfolders
    P.raw     = fullfile(P.session, 'raw');
    P.units   = fullfile(P.session, 'units');
    P.figs    = fullfile(P.session, 'figs');
    P.tables  = fullfile(P.session, 'tables');
    P.stas    = fullfile(P.session, 'stas');
    P.sta_lms = fullfile(P.session, 'sta_lmschannel');

    % expose parsed metadata for convenience
    P.sessionID = sessDir; % Update this to the actual folder name used
    P.dateStr   = info.dateStr;
    P.monkey    = info.monkey;
end
% ===== END FILE: core/utils/get_session_paths.m =====

% ===== FILE: core/utils/get_unit_paths.m =====
% ===== START =====
function Upaths = get_unit_paths(config, dateStr, unitType, unitID)
    P = get_session_paths(config, dateStr);
    label        = sprintf('%s%d', unitType, unitID);  % "SU10"
    Upaths.root  = fullfile(P.units, label);
    Upaths.mats  = fullfile(Upaths.root, 'mats');
    Upaths.figures = fullfile(Upaths.root, 'figures');
    Upaths.tables  = fullfile(Upaths.root, 'tables');
end
% ===== END FILE: core/utils/get_unit_paths.m =====

% ===== FILE: core/utils/load_keep_map.m =====
% ===== START =====
function keepMap = load_keep_map(baseDiscProbeLocal, primaryName, fallbackName)
% LOAD_KEEP_MAP - Load keep-list CSV into a containers.Map
% Key: 'Session_UnitLabel' (e.g., 'Jacomo_250513_SU1' or '250513_SU1')
% Val: 1 (Keep) or 0 (Drop)
%
% Auto-searches baseDiscProbeLocal AND ../output/tables if not found.

if nargin < 2 || isempty(primaryName)
    primaryName = 'ALL_keep_vss.csv';
end
if nargin < 3 || isempty(fallbackName)
    fallbackName = 'ALL_keep.csv';
end

keepMap = containers.Map;

% Define Candidate Paths
% 1. Direct base path (data/)
p1 = fullfile(baseDiscProbeLocal, primaryName);
p2 = fullfile(baseDiscProbeLocal, fallbackName);

% 2. Output/Tables path (assuming standard ../output/tables structure relative to code or base)
% Try to deduce output/tables from the base path hierarchy or common config
% (Simple heuristic: look in sibling 'output/tables' or subfolder 'tables')
p3 = fullfile(baseDiscProbeLocal, '..', 'output', 'tables', primaryName);
p4 = fullfile(baseDiscProbeLocal, 'tables', primaryName);

if isfile(p1)
    keepFile = p1;
elseif isfile(p3) % Check output folder
    keepFile = p3;
elseif isfile(p4)
    keepFile = p4;
elseif isfile(p2) % Fallback name
    keepFile = p2;
    warning('load_keep_map:Fallback', 'Primary keep list not found. Using fallback: %s', p2);
else
    warning('load_keep_map:NotFound', ...
        'Could not find keep list (%s) in %s or standard output folders. Processing ALL units.', ...
        primaryName, baseDiscProbeLocal);
    return;
end

fprintf('Loading keep list from: %s\n', keepFile);
T_keep = readtable(keepFile);
names      = T_keep.Properties.VariableNames;
namesLower = lower(names);

% --- Detect Columns ---
sessField = '';
for cand = {'session','date','datestr'}
    idx = find(strcmp(namesLower, cand{1}), 1);
    if ~isempty(idx), sessField = names{idx}; break; end
end
if isempty(sessField), error('Keep list missing session/date column.'); end

unitField = '';
for cand = {'unit','unit_label','unitname','unitlabel'}
    idx = find(strcmp(namesLower, cand{1}), 1);
    if ~isempty(idx), unitField = names{idx}; break; end
end
if isempty(unitField), error('Keep list missing unit column.'); end

keepField = '';
for cand = {'keep_vss','keep','keep_flag'}
    idx = find(strcmp(namesLower, cand{1}), 1);
    if ~isempty(idx), keepField = names{idx}; break; end
end
if isempty(keepField), error('Keep list missing keep flag column.'); end

% --- Populate Map ---
for i = 1:height(T_keep)
    % 1. Parse Unit Name
    uName = string(T_keep.(unitField)(i));
    
    % 2. Parse Session String (Handle 250513 vs 'Jacomo_250513')
    sVal = T_keep.(sessField)(i);
    if isnumeric(sVal) && ~isnan(sVal)
        sessStr = sprintf('%06d', sVal);
    else
        sessStr = char(string(sVal));
    end
    
    % 3. Parse Keep Value (Ensure Numeric 1/0)
    rawKeep = T_keep.(keepField)(i);
    if iscell(rawKeep) || isstring(rawKeep) || ischar(rawKeep)
        % Handle "TRUE"/"FALSE" strings
        strK = string(rawKeep);
        if strcmpi(strK, "true") || strcmpi(strK, "1")
            val = 1;
        else
            val = 0;
        end
    else
        val = double(rawKeep);
    end
    
    % Generate Key
    key = sprintf('%s_%s', sessStr, uName);
    keepMap(key) = val;
end
end
% ===== END FILE: core/utils/load_keep_map.m =====

% ===== FILE: core/utils/load_palette16.m =====
% ===== START =====
function pal16 = load_palette16(csvPath)
%LOAD_PALETTE16 Load 16 full-saturation RGB colors for the hue ring.
%
%   pal16 = load_palette16(csvPath)
%   - csvPath: path to rgb.csv
%   - pal16:   16x3 matrix of RGB values in [0,1], row 1 is the first hue
%
% Assumes rgb.csv has rows arranged so that every 3rd row is a
% full-saturation color (rows 3,6,9,...).

pal16 = [];

if nargin < 1 || isempty(csvPath)
    warning('load_palette16:NoPath', 'No csvPath provided.');
    return;
end

if ~isfile(csvPath)
    warning('load_palette16:MissingFile', 'rgb.csv not found at %s', csvPath);
    return;
end

A = readmatrix(csvPath);
if isempty(A) || size(A,2) < 3
    warning('load_palette16:BadFile', 'rgb.csv has wrong shape or is empty.');
    return;
end

% every 3rd row is full saturation: 3,6,9,...
idx = 3:3:size(A,1);
if isempty(idx)
    warning('load_palette16:NoFullSatRows', ...
        'No full-saturation rows (3:3:end) found in %s', csvPath);
    return;
end

% pick the first 16 full-saturation hues (or as many as available)
if numel(idx) < 16
    warning('load_palette16:FewHues', ...
        'Only %d full-sat hues found, need 16. Using what is available.', numel(idx));
    idx = idx(1:numel(idx));
else
    idx = idx(1:16);
end

P = double(A(idx,1:3));
P(~isfinite(P)) = 0;

% rgb.csv is effectively 0–1 with occasional 255/256 values
if max(P(:)) > 1
    % assume 0–255 and normalize
    P = P / max(255, max(P(:)));
end

% clip to [0,1] just in case
P = max(0, min(P, 1));

% rotate so the last hue becomes the first (so hue 16 sits at 0°)
if size(P,1) >= 16
    P = circshift(P, 1, 1);   % [16 1 2 ... 15]
end

pal16 = P;
end
% ===== END FILE: core/utils/load_palette16.m =====

% ===== FILE: core/utils/plot_pooled_wachtler_fits_histograms.m =====
% ===== START =====
function H = plot_pooled_wachtler_fits_histograms(config)
% Pool all *_wachtler_fits.csv files and plot population histograms

    if nargin < 1 || isempty(config)
        config = load_config();
    end

    H = struct('fig', [], 'axDir', [], 'axWidth', [], ...
               'pngPath', [], 'pdfPath', []);

    if isfield(config,'paths') && isfield(config.paths,'output') && ~isempty(config.paths.output)
        outRoot = config.paths.output;
    else
        rootDir = fileparts(mfilename('fullpath'));
        outRoot = fullfile(rootDir, 'output');
    end

    wachtRoot = fullfile(outRoot, 'wachtler');
    if ~isfolder(wachtRoot)
        error('plot_pooled_wachtler_fits_histograms:NoWachtlerFolder', ...
            'No wachtler folder found at %s', wachtRoot);
    end

    D = dir(fullfile(wachtRoot, '**', '*_wachtler_fits.csv'));
    if isempty(D)
        error('plot_pooled_wachtler_fits_histograms:NoCSV', ...
            'No *_wachtler_fits.csv files found under %s', wachtRoot);
    end

    allPhi  = [];
    allFwhm = [];
    nFilesUsed = 0;

    for k = 1:numel(D)
        [dateFolder, ~] = fileparts(D(k).folder);
        [~, dateName]   = fileparts(dateFolder);

        tok = regexp(dateName, '^\d{6}$', 'match', 'once');
        if isempty(tok)
            continue;
        end

        csvPath = fullfile(D(k).folder, D(k).name);
        try
            T = readtable(csvPath);
        catch ME
            warning('Could not read %s: %s', csvPath, ME.message);
            continue;
        end

        vnames = T.Properties.VariableNames;
        needed = ismember({'prefDeg','FWHMDeg','R2'}, vnames);
        if ~all(needed)
            warning('Skipping %s (missing required columns).', csvPath);
            continue;
        end

        if ismember('isTunedR2', vnames)
            tuned = T.isTunedR2 ~= 0;
        else
            if ~isfield(config,'tuning') || ~isfield(config.tuning,'R2_thresh') ...
                    || isempty(config.tuning.R2_thresh)
                config.tuning.R2_thresh = 0.5;
            end
            tuned = T.R2 >= config.tuning.R2_thresh;
        end

        tuned = tuned & isfinite(T.prefDeg) & isfinite(T.FWHMDeg);

        allPhi  = [allPhi;  T.prefDeg(tuned)];
        allFwhm = [allFwhm; T.FWHMDeg(tuned)];
        nFilesUsed = nFilesUsed + 1;
    end

    if isempty(allPhi)
        warning('No tuned units found in any wachtler_fits files.');
        return;
    end

    fprintf('Pooled Wachtler fits from %d CSV files (%d tuned units).\n', ...
        nFilesUsed, numel(allPhi));

    % figure roughly like the paper
    H.fig = figure('Color','w', ...
                   'Units','centimeters', ...
                   'Position',[2 2 9 11]);  % [left bottom width height]

    %% ---- Panel A: tuning peak direction ----
    % ---- Panel A: tuning peak direction ----
    H.axDir = subplot(2,1,1);

    allPhiWrapped = mod(allPhi, 360);

    % 16 equal bins, centers at 0, 22.5, ..., 337.5
    nBinsDir     = 16;
    binWidthDir  = 360 / nBinsDir;      % 22.5
    halfWidthDir = binWidthDir / 2;     % 11.25

    % edges: -11.25, 11.25, ..., 348.75  -> 16 bins total
    edgesDir   = -halfWidthDir : binWidthDir : (360 - halfWidthDir);
    centersDir = edgesDir(1:end-1) + halfWidthDir;   % 0:22.5:337.5

    countsDir = histcounts(allPhiWrapped, edgesDir);

    bar(centersDir, countsDir, 0.9, ...   % 0.9 so the y-axis isn't hiding the bar
        'FaceColor', [0.8 0.8 0.8], ...
        'EdgeColor', 'k');

    ymax = max(countsDir) + 1;
    ylim([0 ymax]);
    yticks(0:5:ymax);

    xlim([0 360]);
    xticks(0:90:360);
    xticklabels({'0','90','180','270','360'});

    ylabel('number of cells');
    xlabel('tuning peak direction [deg]');

    set(H.axDir, 'Box','off', 'TickDir','out', 'LineWidth',1);
    set(H.axDir, 'Clipping','off');

    % put +L-M, +S, -L+M, -S in *normalized* coords, well below degree ticks
    hold on;
    yNorm = -0.30;   % more negative = further below x-axis / tick labels

    text(0/360,   yNorm, '+L-M', 'Units','normalized', ...
         'HorizontalAlignment','center');
    text(90/360,  yNorm, '+S',   'Units','normalized', ...
         'HorizontalAlignment','center');
    text(180/360, yNorm, '-L+M', 'Units','normalized', ...
         'HorizontalAlignment','center');
    text(270/360, yNorm, '-S',   'Units','normalized', ...
         'HorizontalAlignment','center');
    hold off;


    %% ---- Panel B: tuning width ----
    H.axWidth = subplot(2,1,2);

    edgesW   = 0:15:180;                  % 0–15, 15–30, ..., 165–180
    centersW = edgesW(1:end-1) + diff(edgesW)/2;

    % keep only finite widths in (0, 180]; discard weird / out-of-range ones
    validFwhm = allFwhm;
    validFwhm = validFwhm(isfinite(validFwhm) & validFwhm > 0 & validFwhm <= 180);

    countsW = histcounts(validFwhm, edgesW);

    bar(centersW, countsW, 1.0, ...
        'FaceColor', [0.8 0.8 0.8], 'EdgeColor','k');

    xlim([0 180]);
    xticks(0:30:180);
    xlabel('tuning width [deg]');
    ylabel('number of cells');

    set(H.axWidth, 'Box','off', 'TickDir','out', 'LineWidth',1);
    hold on;
    xline(120, 'k:');
    hold off;


    % save figure (PNG + PDF) in wachtler root
    figBase = fullfile(wachtRoot, 'wachtler_pooled_histograms');
    H.pngPath = [figBase '.png'];
    H.pdfPath = [figBase '.pdf'];

    set(H.fig, 'PaperUnits','centimeters', 'PaperPosition',[0 0 9 11]);
    print(H.fig, H.pngPath, '-dpng', '-r300');
    print(H.fig, H.pdfPath, '-dpdf', '-r300');
end
% ===== END FILE: core/utils/plot_pooled_wachtler_fits_histograms.m =====

% ===== FILE: core/utils/prepare_unit.m =====
% ===== START =====
function U = prepare_unit(S, unitIdx, Tidx, config)
% build per unit struct U from session S and trial table Tidx.

U = struct();

% basic metadata
U.dateStr = S.dateStr;
U.unitID  = S.phyIDs(unitIdx);
U.idx     = unitIdx;

% SU vs MU based on ExptInfo counts
if isfield(S, 'ExptInfo') && isfield(S.ExptInfo, 'nSU')
    if unitIdx <= S.ExptInfo.nSU
        U.unitType = 'SU';
    else
        U.unitType = 'MU';
    end
else
    U.unitType = 'unit';
end

% spikes and markers for this unit
spk_full = S.spk{unitIdx};   % cell per trial
mrk_full = S.mrk{unitIdx};   % same shape

nTrials_full = numel(spk_full);

if height(Tidx) ~= nTrials_full
    error('prepare_unit: trial count mismatch (Tidx has %d rows, spikes have %d trials).', ...
        height(Tidx), nTrials_full);
end

% start with all trials
keep = true(nTrials_full,1);

% default: keep only trials with valid color IDs
% (matches keep = ~isnan(trType_full(:,1)) in the original v1figproc script)
if ismember('hueID', Tidx.Properties.VariableNames)
    keep = keep & ~isnan(Tidx.hueID);
end

% optional gating by saturation / elevation / hue from config
if isfield(config, 'trials')
    % saturation IDs that we're using
    if isfield(config.trials, 'includeSat') && ...
            ismember('satID', Tidx.Properties.VariableNames) && ...
            ~isempty(config.trials.includeSat)
        keep = keep & ismember(Tidx.satID, config.trials.includeSat);
    end

    % elevation IDs that we're using
    if isfield(config.trials, 'includeElev') && ...
            ismember('elevID', Tidx.Properties.VariableNames) && ...
            ~isempty(config.trials.includeElev)
        keep = keep & ismember(Tidx.elevID, config.trials.includeElev);
    end

    % we wouldn't really do this but hue subset if we ever want it
    if isfield(config.trials, 'includeHue') && ...
            ismember('hueID', Tidx.Properties.VariableNames) && ...
            ~isempty(config.trials.includeHue)
        keep = keep & ismember(Tidx.hueID, config.trials.includeHue);
    end
end

if ~any(keep)
    error('prepare_unit: no trials left after applying color-ID mask and gating.');
end

spk_cell = spk_full(keep);
mrk_cell = mrk_full(keep);
Tunit    = Tidx(keep,:);

% fill or overwrite unitID column for this unit
if ismember('unitID', Tunit.Properties.VariableNames)
    Tunit.unitID(:) = U.unitID;
else
    Tunit.unitID = repmat(U.unitID, height(Tunit), 1);
end

U.nTrials = numel(spk_cell);
U.spk     = spk_cell;
U.mrk     = mrk_cell;
U.trials  = Tunit;

% time windows (pull from config if present, otherwise fall back to
% defaults)
if isfield(config, 'time')
    if isfield(config.time, 'winEarly')
        U.winEarly = config.time.winEarly;
    else
        U.winEarly = [0 0.2];
    end

    if isfield(config.time, 'winLate')
        U.winLate = config.time.winLate;
    else
        U.winLate = [0.25 0.4];
    end

    if isfield(config.time, 'fullWin')
        U.winFull = config.time.fullWin;
    else
        U.winFull = [0 0.4];
    end
else
    U.winEarly = [0 0.2];
    U.winLate  = [0.25 0.4];
    U.winFull  = [0 0.4];
end

end
% ===== END FILE: core/utils/prepare_unit.m =====

% ===== FILE: core/utils/save_unit_outputs.m =====
% ===== START =====
function save_unit_outputs(config, U, stats)
% Save per-unit DiscProbe outputs into:
%   <base>/<date>/units/<unitLabel>/mats/discprobe/DiscProbeUnit_<date>_<unitType>_<unitID>.mat
% Also optionally append a quick CSV row into tablesRoot (if set in config).

    if nargin < 3
        error('save_unit_outputs expects (config, U, stats).');
    end

    if ~isfield(U, 'unitID') || ~isfield(U, 'unitType') || ~isfield(U, 'dateStr')
        error('U is missing unitID, unitType or dateStr.');
    end

    dateStr  = char(string(U.dateStr));
    unitType = char(string(U.unitType));
    unitID   = U.unitID;

    % per-unit paths via helper
    Upaths = get_unit_paths(config, dateStr, unitType, unitID);

    % put DiscProbe mats under mats/discprobe
    discMatDir = fullfile(Upaths.mats, 'discprobe');
    if ~exist(discMatDir, 'dir')
        mkdir(discMatDir);
    end

    unitLabel = sprintf('%s%d', unitType, unitID);  % e.g. SU_10
    fileTag   = sprintf('%s_%s_%d', dateStr, unitType, unitID);
    matFile   = fullfile(discMatDir, sprintf('DiscProbeUnit_%s.mat', fileTag));

    meta = struct();
    meta.dateStr   = string(U.dateStr);
    meta.unitID    = U.unitID;
    meta.unitType  = string(U.unitType);
    if isfield(U,'nTrials'),  meta.nTrials  = U.nTrials;  end
    if isfield(U,'winEarly'), meta.winEarly = U.winEarly; end
    if isfield(U,'winLate'),  meta.winLate  = U.winLate;  end
    if isfield(U,'winFull'),  meta.winFull  = U.winFull;  end
    if isfield(U,'phyID'),    meta.phyID    = U.phyID;    end

    try
        save(matFile, 'U', 'stats', 'meta', '-v7');
    catch ME
        warning('Could not save unit outputs to %s: %s', matFile, ME.message);
    end

    % ---------- optional quick CSV summary ----------
    % we'll now use config.paths.tablesRoot (set in run_discprobe_analysis)
    tablesRoot = '';
    if isfield(config,'paths') && isfield(config.paths,'tablesRoot') ...
            && ~isempty(config.paths.tablesRoot)
        tablesRoot = config.paths.tablesRoot;
    end

    if isempty(tablesRoot)
        return;
    end

    if ~exist(tablesRoot, 'dir')
        mkdir(tablesRoot);
    end

    try
        csvFile    = fullfile(tablesRoot, sprintf('%s_unit_quickSummary.csv', dateStr));
        writeHeader = ~isfile(csvFile);

        fid = fopen(csvFile, 'a');
        if fid == -1
            error('Could not open %s for writing.', csvFile);
        end

        if writeHeader
            hdr = [
                "dateStr", "unitType", "unitID", "nTrials", ...
                "meanRateOverall", ...
                "R_rayleigh", "p_rayleigh", ...
                "R2_cosine", ...
                "p_perm", ...
                "p_anova_hue", "p_anova_sat", "p_anova_int", ...
                "peakClass" ...
            ];
            fprintf(fid, '%s\n', strjoin(hdr, ","));
        end

        meanRateOverall = NaN;
        if isfield(stats, 'hueMeans') && isfield(stats.hueMeans, 'rate_mean')
            meanRateOverall = mean(stats.hueMeans.rate_mean, 'omitnan');
        end

        R_rayleigh = NaN;
        p_rayleigh = NaN;
        if isfield(stats, 'rayleigh') && ~isempty(stats.rayleigh)
            if isfield(stats.rayleigh, 'R'), R_rayleigh = stats.rayleigh.R; end
            if isfield(stats.rayleigh, 'p'), p_rayleigh = stats.rayleigh.p; end
        end

        R2_cosine = NaN;
        if isfield(stats, 'cosine') && isfield(stats.cosine, 'R2')
            R2_cosine = stats.cosine.R2;
        end

        p_perm = NaN;
        if isfield(stats, 'permutation') && isfield(stats.permutation, 'p')
            p_perm = stats.permutation.p;
        end

        p_anova_hue = NaN;
        p_anova_sat = NaN;
        p_anova_int = NaN;
        if isfield(stats, 'anova') && ~isempty(stats.anova)
            if isfield(stats.anova,'p_hue'), p_anova_hue = stats.anova.p_hue; end
            if isfield(stats.anova,'p_sat'), p_anova_sat = stats.anova.p_sat; end
            if isfield(stats.anova,'p_int'), p_anova_int = stats.anova.p_int; end
        end

        peakClass = "";
        if isfield(stats, 'peak') && isfield(stats.peak, 'class')
            peakClass = string(stats.peak.class);
        end

        row = [
            string(U.dateStr), ...
            string(U.unitType), ...
            U.unitID, ...
            U.nTrials, ...
            meanRateOverall, ...
            R_rayleigh, ...
            p_rayleigh, ...
            R2_cosine, ...
            p_perm, ...
            p_anova_hue, ...
            p_anova_sat, ...
            p_anova_int, ...
            peakClass ...
        ];

        fmt = '%s,%s,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%s\n';
        fprintf(fid, fmt, ...
            char(row(1)), char(row(2)), ...
            row(3), row(4), row(5), row(6), row(7), row(8), ...
            row(9), row(10), row(11), row(12), char(row(13)));

        fclose(fid);

    catch ME
        warning('Quick unit CSV summary failed for unit %s_%d: %s', ...
            unitType, unitID, ME.message);
    end
end
% ===== END FILE: core/utils/save_unit_outputs.m =====

% ===== FILE: core/utils/save_vss_unit.m =====
% ===== START =====
function save_vss_unit(config, U, hm, P)
% Save per-unit VSS mat into:
%   <base>/<date>/units/<unitLabel>/mats/vss/VSSUnit_<date>_<unitType>_<unitID>.mat

    dateStr  = char(string(U.dateStr));
    unitType = char(string(U.unitType));
    unitID   = U.unitID;

    % use your helper to get unit paths
    Upaths = get_unit_paths(config, dateStr, unitType, unitID);

    % put VSS mats in a vss subfolder under mats
    vssMatDir = fullfile(Upaths.mats, 'vss');
    if ~exist(vssMatDir, 'dir')
        mkdir(vssMatDir);
    end

    fileTag = sprintf('%s_%s_%d', dateStr, unitType, unitID);
    matFile = fullfile(vssMatDir, sprintf('VSSUnit_%s.mat', fileTag));

    meta = struct();
    meta.dateStr  = dateStr;
    meta.unitType = unitType;
    meta.unitID   = unitID;
    meta.nTrials  = U.nTrials;
    if isfield(U, 'winEarly')
        meta.winEarly = U.winEarly;
    end

    save(matFile, 'U', 'hm', 'P', 'meta');
end
% ===== END FILE: core/utils/save_vss_unit.m =====

% ===== FILE: core/utils/spatial_transforms.m =====
% ===== START =====
classdef spatial_transforms
    % Utilities for mapping hues/colors into angle / DKL space.

    methods (Static)

        function theta_deg = hue_to_angle(hues, COL, config) %like index to dkl for example
        if nargin < 2 || isempty(COL)
            COL = struct();
        end
        if nargin < 3
            config = struct();
        end
    
        hues = double(hues);
        theta_deg = nan(size(hues));
    
        mode = 'index';
        if isfield(config, 'space') && isfield(config.space, 'mode')
            mode = lower(config.space.mode);
        end
    
        useDKL = strcmp(mode, 'dkl') && isfield(COL, 'dkl') && ~isempty(COL.dkl);
    
        if useDKL
            % pick saturation plane
            if isfield(config, 'space') && isfield(config.space, 'satIndexForAngle')
                satIdx = config.space.satIndexForAngle;
            elseif isfield(COL, 'nSat')
                satIdx = COL.nSat;
            else
                sz = size(COL.dkl);
                satIdx = sz(1);
            end
    
                       sz = size(COL.dkl);
            h = round(hues);
            valid = ~isnan(h) & h >= 1 & h <= sz(2);

            theta_deg(~valid) = NaN;
            if any(valid)
                % DKL is [LD RG YV] from calib script / dkl.csv
                D = squeeze(COL.dkl(satIdx, :, :));   % [nHue x 3]

                hv = h(valid);
                v  = D(hv, 2:3);   % columns 2–3: [RG YV]
                vx = v(:,1);       % RG
                vy = v(:,2);       % YV

                theta = atan2(vy, vx);               % angle in RG–YV plane
                theta_deg(valid) = mod(rad2deg(theta), 360);
            end
        else
            % index mode as before
            if isfield(COL, 'nHue')
                nHueAll = COL.nHue;
            elseif isfield(config, 'space') && isfield(config.space, 'nHue')
                nHueAll = config.space.nHue;
            else
                nHueAll = max(hues(~isnan(hues)));
            end
    
            zeroHue = 1;
            if isfield(config, 'space') && isfield(config.space, 'zeroHue')
                zeroHue = config.space.zeroHue;
            end
    
            theta_deg = (hues - zeroHue) .* (360 / nHueAll);
            theta_deg = mod(theta_deg, 360);
        end
    end


        function [L, M, S] = index_to_dkl(idx, COL)
            % Map "master row" indices into DKL coordinates (LD, RG, YV).
        
            L = nan(size(idx));
            M = nan(size(idx));
            S = nan(size(idx));
        
            if ~isfield(COL, 'dklRows') || isempty(COL.dklRows) || isempty(idx)
                return;
            end
        
            D  = COL.dklRows;      % [nProbes x 3]
            nD = size(D,1);
        
            idx   = double(idx);
            valid = ~isnan(idx) & idx >= 1 & idx <= nD;
            if ~any(valid)
                return;
            end
        
            useIdx    = idx(valid);
            L(valid)  = D(useIdx, 1);
            M(valid)  = D(useIdx, 2);
            S(valid)  = D(useIdx, 3);
        end



        function [theta_deg, r] = lm_to_angle(L, M)
            % Convert L/M coordinates into polar angle and radius.

            L = double(L);
            M = double(M);

            theta = atan2(M, L);
            theta_deg = mod(rad2deg(theta), 360);
            r = hypot(L, M);
        end

    end
end
% ===== END FILE: core/utils/spatial_transforms.m =====

% ===== FILE: core/utils/sphere/get_sphere_slice_paths.m =====
% ===== START =====
function paths = get_sphere_slice_paths(config, sessionID)
    % session-aware roots
    SPaths = get_session_paths(config, sessionID);

    % 1) under the session root
    paths.sessionRoot = fullfile(SPaths.session, 'sphere_slices');

    % 2) under figs
    paths.figRoot     = fullfile(SPaths.figs, 'sphere_slices');

    % 3) under global output
    if isfield(config, 'paths') && isfield(config.paths, 'output') ...
            && ~isempty(config.paths.output)
        paths.globalRoot = fullfile(config.paths.output, 'sphere_slices', char(SPaths.sessionID));
    else
        paths.globalRoot = '';
    end

    roots = {paths.sessionRoot, paths.figRoot, paths.globalRoot};
    for i = 1:numel(roots)
        if ~isempty(roots{i}) && ~exist(roots{i}, 'dir')
            mkdir(roots{i});
        end
    end
end
% ===== END FILE: core/utils/sphere/get_sphere_slice_paths.m =====

% ===== FILE: core/utils/sphere/write_sphere_slice_csv.m =====
% ===== START =====
function write_sphere_slice_csv(R, sessionID, config)
% Write per-slice stats from sphere_slicer into a session CSV.

    if nargin < 3 || isempty(config)
        config = load_config();
    end

    if isempty(R)
        warning('write_sphere_slice_csv: R is empty, nothing to write.');
        return;
    end

    P = get_session_paths(config, sessionID);
    tablesDir = P.tables;
    if ~exist(tablesDir,'dir')
        mkdir(tablesDir);
    end

    n = numel(R);
    sessionID_col = strings(n,1);
    dateStr_col   = strings(n,1);
    monkey_col    = strings(n,1);
    unitIdx_col   = nan(n,1);
    unitID_col    = nan(n,1);
    unitType_col  = strings(n,1);
    sat_col       = nan(n,1);
    elev_col      = nan(n,1);
    nTrials_col   = nan(n,1);
    r2_flat_col   = nan(n,1);
    r2_1_col      = nan(n,1);
    r2_12_col     = nan(n,1);
    bestR2_col    = nan(n,1);
    rayR_col      = nan(n,1);
    rayP_col      = nan(n,1);
    rayMu_col     = nan(n,1);

    for i = 1:n
        sessionID_col(i) = string(R(i).sessionID);
        dateStr_col(i)   = string(R(i).dateStr);
        monkey_col(i)    = string(R(i).monkey);
        unitIdx_col(i)   = R(i).unitIdx;
        unitID_col(i)    = R(i).unitID;
        unitType_col(i)  = string(R(i).unitType);
        sat_col(i)       = R(i).satID;
        elev_col(i)      = R(i).elevID;
        nTrials_col(i)   = R(i).nTrials;

        if isfield(R(i),'r2_flat'),   r2_flat_col(i) = R(i).r2_flat;   end
        if isfield(R(i),'r2_1'),      r2_1_col(i)    = R(i).r2_1;      end
        if isfield(R(i),'r2_12'),     r2_12_col(i)   = R(i).r2_12;     end
        if isfield(R(i),'rayleigh_R'),    rayR_col(i)  = R(i).rayleigh_R;     end
        if isfield(R(i),'rayleigh_p'),    rayP_col(i)  = R(i).rayleigh_p;     end
        if isfield(R(i),'rayleigh_mu_deg'), rayMu_col(i) = R(i).rayleigh_mu_deg; end

        % best-model R2: pick between 1st and 1st+2nd harmonic
        r1  = r2_1_col(i);
        r12 = r2_12_col(i);
        if isfinite(r1) || isfinite(r12)
            if ~isfinite(r12) || (isfinite(r1) && r1 >= r12)
                bestR2_col(i) = r1;
            else
                bestR2_col(i) = r12;
            end
        end
    end

    T = table( ...
        sessionID_col, dateStr_col, monkey_col, ...
        unitIdx_col, unitID_col, unitType_col, ...
        sat_col, elev_col, nTrials_col, ...
        r2_flat_col, r2_1_col, r2_12_col, bestR2_col, ...
        rayR_col, rayP_col, rayMu_col, ...
        'VariableNames', { ...
        'sessionID','dateStr','monkey', ...
        'unitIdx','unitID','unitType', ...
        'satID','elevID','nTrials', ...
        'r2_flat','r2_1','r2_12','bestR2', ...
        'rayleigh_R','rayleigh_p','rayleigh_mu_deg'});

    sessTag = char(sessionID);
    outCSV = fullfile(tablesDir, sprintf('%s_sphereSlices.csv', sessTag));
    writetable(T, outCSV);
    fprintf('write_sphere_slice_csv: wrote %d rows to %s\n', height(T), outCSV);
end
% ===== END FILE: core/utils/sphere/write_sphere_slice_csv.m =====

% ===== FILE: core/visualization/DrawRaster.m =====
% ===== START =====
function [varargout] = DrawRaster(spkcell,mrkcell,groupingvar,rowcolors)
% Draw a raster plot of neural spiking data for a single unit
% Syntax:
%       [H, hspk, hbhv, hzro] = DrawRaster(spkcell,mrkcell,groupingvar,rowcolors)
%
% Inputs:
%    spkcell - cell array of length==trials, each cell contains spike times
%    mrkcell - cell array of length==trials, each cell contains marker times
%    groupingvar(optional) - vector of IDs to group trials
%    rowcolors(optional) - Ntrials x 3 RGB for per-row backgrounds
%
% By RAMON BARTOLO [2016], lightly adjusted for rowcolors.

if nargin==1 && ~iscell(spkcell) && strcmp(spkcell,'test')
    [spkcell,mrkcell] = genTestData; %#ok<NASGU>
end

if nargin<3
    groupingvar(:,1:numel(spkcell)) = 1;
else
    if numel(spkcell) ~= numel(groupingvar)
        error('groupingvar must have as many elements as cells with spike times');
    end
    if numel(spkcell) ~= numel(mrkcell)
        error('markers must have as many cells as the spike times array');
    end
end

useColors = (nargin>=4) && ~isempty(rowcolors);
if useColors
    rowcolors = double(rowcolors);

    if max(rowcolors,[],'all') > 1
        rowcolors = rowcolors ./ 255;
    end

    if size(rowcolors,2) ~= 3
        error('rowcolors must be Ntrials x 3');
    end
end

maxargout = 4;

group = unique(groupingvar);
ngrps = length(group(:,1));

TrIdx = 0;
xvec = [];
yvec = [];
bhvvec = [];
row_order = zeros(numel(spkcell),1);

for gr = 1:ngrps
    idx = find(groupingvar==group(gr));
    gsc = spkcell(idx);
    gmc = mrkcell(idx);
    grtrs = numel(gsc);

    for tr = 1:grtrs
        if ~isempty(gsc{tr})
            txvec(1,:) = gsc{tr};
            tyvec(1,:) = zeros(size(txvec)) + TrIdx + 0.5;
            xvec = cat(2,xvec,txvec);
            yvec = cat(2,yvec,tyvec);
        end

        tbhvvec(1,:) = gmc{tr};
        tbhvvec(tbhvvec==0) = [];
        tbhvvec(2,:) = TrIdx+0.5;
        bhvvec = cat(2,bhvvec,tbhvvec);

        TrIdx = TrIdx + 1;
        row_order(TrIdx) = idx(tr);
        clear txvec tyvec tbhvvec
    end

    if ngrps>1 && gr~=ngrps
        divliney(gr,1:2) = [TrIdx, TrIdx]; %#ok<AGROW>
    end

    clear gsc gmc grtrs idx
end

h(1) = figure;
hold on;
xlabel("Time (s)");
ylabel("Trials");

% per-row background in the first 200 ms
if useColors
    xs = [];
    if ~isempty(xvec),   xs = [xs xvec];        end
    if ~isempty(bhvvec), xs = [xs bhvvec(1,:)]; end
    if isempty(xs), xs = [0 1]; end
    xl = [min(xs) max(xs)];

    colorWin = [0 0.20];
    x1 = max(colorWin(1), xl(1));
    x2 = min(colorWin(2), xl(2));

    if x2 > x1
        for r = 1:TrIdx
            c = rowcolors(row_order(r),:);
            patch([x1 x2 x2 x1], [r-0.5 r-0.5 r+0.5 r+0.5], c, ...
                  'EdgeColor','none','FaceAlpha',0.25);
        end
    end
end

h(2) = plot(xvec,yvec,'|','Color','k','MarkerSize',1);
if ~isempty(bhvvec)
    h(3) = plot(bhvvec(1,:),bhvvec(2,:),'.','Color',[0.9,0.2,0.1],'MarkerSize',1);
end
axis('tight');
h(4) = line([0,0],[0,TrIdx],'Color',[0.9,0.2,0.2],'LineWidth',1);

if ngrps>1
    A = get(gca,'XLim');
    divlinex = [ones(ngrps-1,1)*A(1), ones(ngrps-1,1)*A(2)];
    if exist('divliney','var') && ~isempty(divlinex)
        line(divlinex',divliney','Color','k','Linewidth',1);
    end
end

set(gca,'YTick',[1,TrIdx],'TickDir','out');
hold off;

na = nargout;
if na > 0
    if na>maxargout
        warning('too many output arguments, ignoring the extra arguments');
        na = maxargout;
    end
    for k = 1:na
        varargout{k} = h(k);
    end
end

end
% ===== END FILE: core/visualization/DrawRaster.m =====

% ===== FILE: core/visualization/plot_3d_tuning_lms.m =====
% ===== START =====
function ax = plot_3d_tuning_lms(tuning3D, varargin)
% Plot 3D tuning contour in [L-M, S, Lum] space,
% similar to Wachtler Fig 1C/D.

p = inputParser;
addParameter(p,'Levels',[0.3 0.6 0.9]);  % iso-response levels (fraction of max)
addParameter(p,'Axes',[]);
addParameter(p,'Title','');
parse(p,varargin{:});

levelsFrac = p.Results.Levels;
ax         = p.Results.Axes;
ttl        = p.Results.Title;

LM  = tuning3D.LM(:);
S   = tuning3D.S(:);
Lum = tuning3D.Lum(:);
R   = tuning3D.rate(:);

ok = isfinite(LM) & isfinite(S) & isfinite(Lum) & isfinite(R);
LM  = LM(ok);
S   = S(ok);
Lum = Lum(ok);
R   = R(ok);

if isempty(LM)
    warning('No valid data for 3D tuning.');
    return;
end

% normalize so max response = 1
R = R - min(R);
if max(R) > 0
    R = R ./ max(R);
end

pad = 0.05;
lm_grid  = linspace(min(LM)-pad,  max(LM)+pad, 30);
s_grid   = linspace(min(S)-pad,   max(S)+pad,  30);
lum_grid = linspace(min(Lum)-pad, max(Lum)+pad,30);

[LMg, Sg, Lumg] = ndgrid(lm_grid, s_grid, lum_grid);

F  = scatteredInterpolant(LM, S, Lum, R, 'natural','none');
Rg = F(LMg, Sg, Lumg);

if isempty(ax) || ~isvalid(ax)
    figure('Color','w');
    ax = axes;
end
axes(ax);
hold(ax,'on');

levels = levelsFrac;

for k = 1:numel(levels)
    lvl = levels(k);
    try
        pch = patch(isosurface(LMg, Sg, Lumg, Rg, lvl));
    catch
        continue;
    end
    isonormals(LMg, Sg, Lumg, Rg, pch);
    pch.FaceColor = [0.7 0.7 0.7];
    pch.EdgeColor = 'none';
    pch.FaceAlpha = 0.25 + 0.15*k;  % more opaque at higher response
end

scatter3(ax, LM, S, Lum, 50, R, 'filled', 'MarkerEdgeColor','k');

xlabel(ax,'L - M');
ylabel(ax,'S');
zlabel(ax,'Lum (L + M)');

grid(ax,'on');
axis(ax,'equal');
view(ax, 30, 20);
box(ax,'on');

if ~isempty(ttl)
    title(ax, ttl);
end

end
% ===== END FILE: core/visualization/plot_3d_tuning_lms.m =====

% ===== FILE: core/visualization/plot_boxplots.m =====
% ===== START =====
function plot_boxplots(U, stats, COL, config, outDir)
% PLOT_BOXPLOTS - Boxplots of rate vs Hue per Saturation.
% FIX: Uses Synthetic Color Scaling (Vivid * Sat) for accurate RGB colors.

    if U.nTrials == 0
        return;
    end

    % --- DATA PREP ---
    win = U.winEarly;
    dur = diff(win);
    nTr = numel(U.spk);
    rateEarly = nan(nTr,1);
    for tt = 1:nTr
        spks = U.spk{tt};
        if isempty(spks)
            rateEarly(tt) = 0;
        else
            spks = spks(spks >= win(1) & spks < win(2));
            rateEarly(tt) = numel(spks) / dur;
        end
    end

    hueID = U.trials.hueID;
    satID = U.trials.satID;
    elevID = U.trials.elevID;

    % Determine Elevation (Mode) for color lookup
    uElevs = unique(elevID(~isnan(elevID)));
    if isempty(uElevs), currentElev = 0; else, currentElev = mode(uElevs); end

    % defaults matching original
    USE_NORM = false;
    METHOD   = 'tukey';
    MIN_N    = 5;
    if isfield(config,'boxPlots')
        bp = config.boxPlots;
        if isfield(bp,'useNorm'), USE_NORM = logical(bp.useNorm); end
        if isfield(bp,'method'),  METHOD   = lower(bp.method);    end
        if isfield(bp,'minN'),    MIN_N    = bp.minN;             end
    end

    if isfield(COL,'nHue')
        nHue = COL.nHue;
    else
        nHue = max(hueID(~isnan(hueID)));
    end

    ZERO_HUE = 1;
    if isfield(config,'space') && isfield(config.space,'zeroHue')
        ZERO_HUE = config.space.zeroHue;
    end

    % saturation list and indices per trial
    saturIDs = unique(satID(~isnan(satID)));
    saturIDs = saturIDs(:).';
    nS       = numel(saturIDs);
    [~, satIdx_u] = ismember(satID, saturIDs);
    hueIdx_u = hueID;
    
    if isempty(saturIDs), maxSat = 1; else, maxSat = max(saturIDs); end

    % choose values and y label
    if USE_NORM
        r = rateEarly;
        r = r - min(r);
        denom = max(r);
        if denom <= 0
            vals = zeros(size(r));
        else
            vals = r ./ denom;
        end
        ylab = 'Normalized rate (0–1)';
    else
        vals = rateEarly;
        ylab = 'Rate (Hz)';
    end

    % figure visibility toggle
    makePlots = true;
    if isfield(config,'plot') && isfield(config.plot,'makePlots')
        makePlots = logical(config.plot.makePlots);
    end
    figVis = 'on';
    if ~makePlots
        figVis = 'off';
    end

    % ---------- paths: per-unit, per-session, global ----------
    dateStr  = char(string(U.dateStr));
    unitType = char(string(U.unitType));
    unitID   = U.unitID;

    Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
    unitDir = Upaths.figures;
    if ~exist(unitDir,'dir')
        mkdir(unitDir);
    end

    % per-session boxplots dir under figs/discprobe/boxplots
    if nargin < 5 || isempty(outDir)
        outDir = '';
    end
    sessionDir = '';
    if ~isempty(outDir)
        sessionDir = fullfile(outDir, 'boxplots');
        if ~exist(sessionDir,'dir')
            mkdir(sessionDir);
        end
    end

    % global "overall" dir under output/figs/discprobe/boxplots
    globalDir = '';
    if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
            && ~isempty(config.paths.globalDiscProbeFigRoot)
        globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'boxplots');
        if ~exist(globalDir,'dir')
            mkdir(globalDir);
        end
    end

    % --- PLOTTING ---
    nPlotSat = nS;
    figBP = figure('Color','w','Visible',figVis,'Name','Hue box plots');
    TL = tiledlayout(figBP, 1, nPlotSat, 'Padding','compact','TileSpacing','compact');

    if isfield(U,'exptName')
        unitLabel = sprintf('%s | Unit %d (%s) — Box plots', string(U.exptName), U.unitID, U.unitType);
    else
        unitLabel = sprintf('%s | Unit %d (%s) — Box plots', string(U.dateStr), U.unitID, U.unitType);
    end
    sgtitle(figBP, unitLabel, 'Interpreter','none');

    for si = 1:nPlotSat
        ax = nexttile(TL);
        hold(ax,'on');
        sVal = saturIDs(si);
        
        msk  = (satIdx_u == si) & isfinite(hueIdx_u) & isfinite(vals);
        if ~any(msk)
            title(ax, sprintf('sat=%.2f (no data)', sVal));
            axis(ax,'off');
            continue;
        end
        
        gHue = hueIdx_u(msk);
        x    = vals(msk);
        
        % --- FIX: CALCULATE COLORS DYNAMICALLY ---
        % Generate color matrix for this specific saturation (nHue x 3)
        C = zeros(nHue, 3);
        for h = 1:nHue
            C(h, :) = get_synthetic_color(COL, h, sVal, maxSat, currentElev);
        end
        
        if exist('boxchart','file')
            % Modern MATLAB boxchart
            for h = 1:nHue
                j = find(msk & hueIdx_u == h);
                if isempty(j), continue; end
                
                b = boxchart(hueIdx_u(j), vals(j), 'Parent', ax, ...
                    'MarkerStyle','.', 'BoxFaceAlpha',0.6);
                
                rgb = C(h,:);
                rgb = min(max(rgb,0),1);
                
                b.BoxFaceColor = rgb;
                b.BoxEdgeColor = rgb;
                b.MarkerColor  = rgb;
            end
        else
            % Fallback for older MATLAB
            [~,~,grp] = unique(gHue);
            boxplot(ax, x, grp, 'Symbol','.', 'Colors', C(1:max(grp),:));
            set(ax,'XTick',1:nHue,'XLim',[0.5 nHue+0.5]);
        end
        
        title(ax, sprintf('sat=%.2f', sVal));
        xlabel(ax,'Hue');
        ylabel(ax, ylab);
        
        % label x-axis as degrees if DKL
        if isfield(config,'space') && isfield(config.space,'mode') && strcmpi(config.space.mode,'dkl')
            degLabels = mod((1:nHue) - ZERO_HUE, nHue) * (360/nHue);
            set(ax,'XTick',1:nHue,'XTickLabel', ...
                arrayfun(@(d)sprintf('%d',round(d)),degLabels,'UniformOutput',false));
            xlabel(ax,'Angle (deg)');
        else
            set(ax,'XTick',1:nHue);
        end
        
        ax.XLim = [0.5, nHue+0.5];
        if USE_NORM, ylim(ax,[0 1]); end
        grid(ax,'on');
        
        % outliers overlay
        if isfield(U,'isOutlier') && numel(U.isOutlier) == nTr
            out_msk = U.isOutlier & msk;
            if any(out_msk)
                plot(ax, hueIdx_u(out_msk), vals(out_msk), 'ro', 'MarkerSize',5, 'LineWidth',1.2);
            end
        end
    end

    pngDpi = 200;
    if isfield(config,'plot') && isfield(config.plot,'dpi')
        pngDpi = config.plot.dpi;
    end
    
    fileTag = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);
    
    % per-unit saves
    pngName_unit = fullfile(unitDir, sprintf('BoxPlots_%s.png', fileTag));
    figName_unit = fullfile(unitDir, sprintf('BoxPlots_%s.fig', fileTag));
    exportgraphics(figBP, pngName_unit, 'Resolution', pngDpi);
    savefig(figBP, figName_unit);
    
    % per-session saves
    if ~isempty(sessionDir)
        pngName_sess = fullfile(sessionDir, sprintf('BoxPlots_%s.png', fileTag));
        figName_sess = fullfile(sessionDir, sprintf('BoxPlots_%s.fig', fileTag));
        exportgraphics(figBP, pngName_sess, 'Resolution', pngDpi);
        savefig(figBP, figName_sess);
    end
    
    % global / overall saves
    if ~isempty(globalDir)
        pngName_glob = fullfile(globalDir, sprintf('BoxPlots_%s.png', fileTag));
        figName_glob = fullfile(globalDir, sprintf('BoxPlots_%s.fig', fileTag));
        exportgraphics(figBP, pngName_glob, 'Resolution', pngDpi);
        savefig(figBP, figName_glob);
    end
    
    if ~makePlots
        close(figBP);
    end
end

% -------------------------------------------------------------------------
% Helper: Synthetic Color Scaling (Vivid * Saturation)
% -------------------------------------------------------------------------
function c = get_synthetic_color(COL, h, sVal, maxSat, eVal)
    % 1. Get Vivid Color (Max Saturation)
    cVivid = get_vivid_color(COL, h, maxSat, eVal);
    
    % 2. Scale brightness by Saturation factor
    if maxSat > 0
        scaleFactor = sVal / maxSat;
    else
        scaleFactor = 0;
    end
    
    c = cVivid * scaleFactor;
end

function c = get_vivid_color(COL, h, maxSat, e)
    c = [0.5 0.5 0.5]; 
    if ~isfield(COL, 'probeIDs') || ~isfield(COL, 'probeCols'), return; end
    tol = 1e-4; 
    
    % Try strict match for Max Sat
    idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-maxSat)<tol & abs(COL.probeIDs(:,3)-e)<tol, 1);
    
    % Fallback to Equator
    if isempty(idx)
        idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-maxSat)<tol & abs(COL.probeIDs(:,3)-0)<tol, 1);
    end
    
    % Fallback to Hue only (any elevation/sat if max sat missing)
    if isempty(idx)
         idx = find(abs(COL.probeIDs(:,1)-h)<tol, 1);
    end

    if ~isempty(idx)
        rawC = double(COL.probeCols(idx,:));
        if max(rawC) > 1, rawC = rawC / 255; end
        c = rawC;
    end
end
% ===== END FILE: core/visualization/plot_boxplots.m =====

% ===== FILE: core/visualization/plot_dkl_suite.m =====
% ===== START =====
function plot_dkl_suite(U, stats, COL, config, outDir)
% PLOT_DKL_SUITE - Polar visualization of tuning in DKL space.
% FINAL FIXES:
% 1. Zero Alignment: Uses config.space.zeroHue to set which Hue is at 0°.
% 2. Spacing: Pushes Labels OUTSIDE the Hue Ring.
% 3. Cleanliness: Removes redundant subplot title.

    if U.nTrials == 0
        return;
    end
    
    % --- CONFIG ---
    makePlots = true;
    if isfield(config,'plot') && isfield(config.plot,'makePlots')
        makePlots = logical(config.plot.makePlots);
    end
    figVis = 'on';
    if ~makePlots, figVis = 'off'; end

    pngDpi = 300;
    if isfield(config,'plot') && isfield(config.plot,'dpi')
        pngDpi = config.plot.dpi;
    end
    
    doSaveFig = true;
    if isfield(config, 'plot') && isfield(config.plot, 'saveFigs')
        doSaveFig = config.plot.saveFigs;
    end

    % --- PATHS ---
    dateStr  = char(string(U.dateStr));
    unitType = char(string(U.unitType));
    unitID   = U.unitID;

    Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
    unitDir = Upaths.figures;
    if ~exist(unitDir,'dir'), mkdir(unitDir); end

    if nargin < 5 || isempty(outDir), outDir = ''; end
    sessionDir = '';
    if ~isempty(outDir)
        useSub = true;
        if isfield(config, 'plot') && isfield(config.plot, 'suppressSubfolders') && config.plot.suppressSubfolders
            useSub = false;
        end
        if useSub
            sessionDir = fullfile(outDir, 'dkl_suite');
        else
            sessionDir = outDir; 
        end
        if ~exist(sessionDir,'dir'), mkdir(sessionDir); end
    end

    globalDir = '';
    if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
            && ~isempty(config.paths.globalDiscProbeFigRoot)
        globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'dkl_suite');
        if ~exist(globalDir,'dir'), mkdir(globalDir); end
    end

    % --- DATA PREP ---
    win = U.winEarly;
    dur = diff(win);
    
    nTr = numel(U.spk);
    rates = nan(nTr,1);
    for tt = 1:nTr
        spks = U.spk{tt};
        if isempty(spks)
            rates(tt) = 0;
        else
            spks = spks(spks >= win(1) & spks < win(2));
            rates(tt) = numel(spks) / dur;
        end
    end
    
    hueID = U.trials.hueID; satID = U.trials.satID; elevID = U.trials.elevID;
    
    if isfield(COL, 'nHue')
        nHue = COL.nHue;
    else
        nHue = max(hueID(~isnan(hueID)));
    end
    
    uS = unique(satID(~isnan(satID)));
    uE = unique(elevID(~isnan(elevID)));
    if isempty(uE), defE = 0; else, defE = mode(uE); end
    if isempty(uS), maxS = 1; else, maxS = max(uS); end

    % --- ROTATION FIX: Handle Zero Hue ---
    ZERO_HUE = 1; % Default
    if isfield(config, 'space') && isfield(config.space, 'zeroHue')
        ZERO_HUE = config.space.zeroHue;
    end

    hue_indices = (1:nHue)';
    
    % Calculate Angle relative to Zero Hue
    % mod(h - zero, n) ensures correct rotation
    % e.g. if Zero=16, Hue 16 becomes 0 deg, Hue 1 becomes 22.5 deg
    hue_angles = 2*pi * mod(hue_indices - ZERO_HUE, nHue) / nHue;
    
    r_per_hue = zeros(nHue, 1);
    for hVal = 1:nHue
        mask = (hueID == hVal);
        if nnz(mask) > 0
            r_per_hue(hVal) = mean(rates(mask), 'omitnan');
        else
            r_per_hue(hVal) = 0;
        end
    end
    
    % --- PLOTTING ---
    f = figure('Color','w','Visible',figVis,'Name','DKL suite');
    f.Units = 'normalized'; f.Position = [0.2 0.2 0.5 0.75]; 
    
    axP = polaraxes('Parent', f);
    hold(axP, 'on');
    
    % 1. ORIENTATION
    axP.ThetaZeroLocation = 'right';
    axP.ThetaDir = 'counterclockwise';
    axP.FontSize = 10; 
    
    % Sort by angle for proper line drawing
    [sortedAngles, sortIdx] = sort(hue_angles);
    sortedRates = r_per_hue(sortIdx);
    sortedHues  = hue_indices(sortIdx);
    
    % Close loop
    if ~isempty(sortedAngles)
        sortedAngles(end+1) = sortedAngles(1) + 2*pi;
        sortedRates(end+1)  = sortedRates(1);
    end
    
    % --- SCALING LAYERS ---
    maxRate = max(sortedRates, [], 'omitnan');
    if maxRate <= 0, maxRate = 1; end
    
    ringCenter  = maxRate * 1.15;  
    viewLimit   = maxRate * 1.25;  
    labelRadius = maxRate * 1.55; 
    
    rlim(axP, [0 viewLimit]);
    
    % 2. Draw Tuning Curve (Red)
    polarplot(axP, sortedAngles, sortedRates, 'o-', ...
        'LineWidth', 2.5, 'Color', 'r', 'MarkerFaceColor', 'r', 'MarkerSize', 5);
    
    % 3. Draw Colored Ring (Flush with edge)
    hueWidth = 2*pi / nHue;
    
    for k = 1:nHue
        % Use sorted indices to match the angles
        hVal = sortedHues(k);
        thisAngle = sortedAngles(k);
        
        [~, ringC] = get_coords_from_meta(COL, hVal, maxS, defE);
        
        thStart = thisAngle - hueWidth/2 * 0.98;
        thEnd   = thisAngle + hueWidth/2 * 0.98;
        thArc   = linspace(thStart, thEnd, 20); 
        rArc    = repmat(ringCenter, size(thArc));
        
        polarplot(axP, thArc, rArc, '-', 'Color', ringC, 'LineWidth', 20); 
    end
    
    % 4. Preferred Direction
    if ~isempty(r_per_hue)
        % Calculate vector sum using original angles
        V = sum(r_per_hue .* exp(1i * hue_angles));
        prefAng = angle(V);
        polarplot(axP, [0, prefAng], [0, maxRate], '--', ...
            'Color', [0.9 0.7 0], 'LineWidth', 2);
    end
    
    % 5. DKL Labels (Outside everything)
    fontSz = 11;
    text(axP, 0,    labelRadius, '+[L-M]', 'HorizontalAlignment','center', 'FontWeight','bold', 'FontSize', fontSz, 'Clipping', 'off');
    text(axP, pi/2, labelRadius, '+S',     'HorizontalAlignment','center', 'FontWeight','bold', 'FontSize', fontSz, 'Clipping', 'off');
    text(axP, pi,   labelRadius, '-[L-M]', 'HorizontalAlignment','center', 'FontWeight','bold', 'FontSize', fontSz, 'Clipping', 'off');
    text(axP, 3*pi/2, labelRadius, '-S',   'HorizontalAlignment','center', 'FontWeight','bold', 'FontSize', fontSz, 'Clipping', 'off');

    % --- TITLE & SAVING ---
    if isfield(U,'exptName')
        ttl = sprintf('%s | Unit %d (%s) - DKL Polar', string(U.exptName), U.unitID, U.unitType);
    else
        ttl = sprintf('%s | Unit %d (%s) - DKL Polar', string(U.dateStr), U.unitID, U.unitType);
    end
    
    % Safe title positioning (axes title with newlines)
    title(axP, {ttl, ''}, 'Interpreter','none', 'FontSize', 12, 'FontWeight', 'bold');

    fileTag = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);
    exportgraphics(f, fullfile(unitDir, sprintf('DKL_suite_%s.png', fileTag)), 'Resolution', pngDpi);
    if doSaveFig, savefig(f, fullfile(unitDir, sprintf('DKL_suite_%s.fig', fileTag))); end
    
    if ~isempty(sessionDir)
        exportgraphics(f, fullfile(sessionDir, sprintf('DKL_suite_%s.png', fileTag)), 'Resolution', pngDpi);
        if doSaveFig, savefig(f, fullfile(sessionDir, sprintf('DKL_suite_%s.fig', fileTag))); end
    end
    
    if ~isempty(globalDir)
        exportgraphics(f, fullfile(globalDir, sprintf('DKL_suite_%s.png', fileTag)), 'Resolution', pngDpi);
        if doSaveFig, savefig(f, fullfile(globalDir, sprintf('DKL_suite_%s.fig', fileTag))); end
    end
    
    if ~makePlots, close(f); end
end

% --- HELPER ---
function [dkl, rgb] = get_coords_from_meta(COL, h, s, e)
    dkl = [NaN NaN NaN]; rgb = [0.5 0.5 0.5];
    if ~isfield(COL, 'probeIDs') || ~isfield(COL, 'dklRows'), return; end
    tol = 1e-4;
    idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-s)<tol & abs(COL.probeIDs(:,3)-e)<tol, 1);
    
    % Fallback 1: Ignore Elev
    if isempty(idx)
         idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-s)<tol, 1);
    end
    % Fallback 2: Any Hue match (useful for Vivid lookup)
    if isempty(idx)
        idx = find(abs(COL.probeIDs(:,1)-h)<tol, 1);
    end
    
    if ~isempty(idx)
        dkl = double(COL.dklRows(idx, :));
        if isfield(COL, 'probeCols'), rawC = double(COL.probeCols(idx, :)); if max(rawC)>1, rawC=rawC/255; end; rgb=rawC; end
    end
end
% ===== END FILE: core/visualization/plot_dkl_suite.m =====

% ===== FILE: core/visualization/plot_fourier.m =====
% ===== START =====
function plot_fourier(U, stats, COL, config, outDir)

if ~isfield(stats, 'fourier') || isempty(stats.fourier)
    return;
end

FT       = stats.fourier;
FT_over  = FT.over;
FT_sat   = FT.perSat;
saturIDs = FT.saturIDs;

% figure visibility
makePlots = true;
if isfield(config, 'plot') && isfield(config.plot, 'makePlots')
    makePlots = logical(config.plot.makePlots);
end
figVis = 'on';
if ~makePlots
    figVis = 'off';
end

% ---------- paths: per-unit, per-session, global ----------

dateStr  = char(string(U.dateStr));
unitType = char(string(U.unitType));
unitID   = U.unitID;


% per-unit dir: units/<unit>/figures/discprobe/fourier
Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
unitDir = Upaths.figures;
if ~exist(unitDir,'dir')
    mkdir(unitDir);
end


% per-session dir: <date>/figs/discprobe/fourier
if nargin < 5 || isempty(outDir)
    outDir = '';
end
sessionDir = '';
if ~isempty(outDir)
    sessionDir = fullfile(outDir, 'fourier');
    if ~exist(sessionDir,'dir')
        mkdir(sessionDir);
    end
end

% global dir: output/figs/discprobe/fourier
globalDir = '';
if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
        && ~isempty(config.paths.globalDiscProbeFigRoot)
    globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'fourier');
    if ~exist(globalDir,'dir')
        mkdir(globalDir);
    end
end

% ---------- plotting ----------

figF = figure('Color','w','Visible',figVis,'Name','Hue Fourier');
TLf  = tiledlayout(figF,2,2,'Padding','compact','TileSpacing','compact');

if isfield(U,'exptName')
    unitLabel = sprintf('%s | Unit %d (%s) — Hue Fourier', ...
        string(U.exptName), U.unitID, U.unitType);
else
    unitLabel = sprintf('%s | Unit %d (%s) — Hue Fourier', ...
        string(U.dateStr), U.unitID, U.unitType);
end
sgtitle(figF, unitLabel, 'Interpreter','none');

% amplitude spectrum (overall)
ax = nexttile(TLf);
bar(ax, FT_over.harmonics, FT_over.amp);
grid(ax,'on');
xlabel(ax,'Harmonic k');
ylabel(ax,'Amplitude');
title(ax,'Amplitude spectrum');

% variance explained (overall, no-DC fraction)
ax = nexttile(TLf);
bar(ax, FT_over.harmonics, FT_over.varExp);
grid(ax,'on');
xlabel(ax,'Harmonic k');
ylabel(ax,'Variance explained (noDC frac)');
title(ax,'Variance explained');

% first harmonic amplitude per sat
nS = numel(FT_sat);
ax = nexttile(TLf);
a1 = NaN(1, nS);
for si = 1:nS
    if isfield(FT_sat(si),'amp') && numel(FT_sat(si).amp) >= 1
        a1(si) = FT_sat(si).amp(1);
    end
end
bar(ax, 1:nS, a1);
set(ax,'XTick',1:nS,'XTickLabel',compose('sat=%.2f',saturIDs));
ylabel(ax,'Amp k=1');
title(ax,'First-harmonic amplitude (per sat)');
grid(ax,'on');

% first harmonic phase per sat
ax = nexttile(TLf);
ph1 = NaN(1, nS);
for si = 1:nS
    if isfield(FT_sat(si),'phase_deg') && numel(FT_sat(si).phase_deg) >= 1
        ph1(si) = FT_sat(si).phase_deg(1);
    end
end
bar(ax, 1:nS, ph1);
set(ax,'XTick',1:nS,'XTickLabel',compose('sat=%.2f',saturIDs));
ylabel(ax,'Phase k=1 (deg)');
title(ax,'First-harmonic phase (per sat)');
grid(ax,'on');

% ---------- save to all three locations ----------

pngDpi = 200;
if isfield(config, 'plot') && isfield(config.plot, 'dpi')
    pngDpi = config.plot.dpi;
end

fileTag = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);

% per-unit
png_unit = fullfile(unitDir, sprintf('FourierHue_quicklook_%s.png', fileTag));
fig_unit = fullfile(unitDir, sprintf('FourierHue_quicklook_%s.fig', fileTag));
exportgraphics(figF, png_unit, 'Resolution', pngDpi);
savefig(figF, fig_unit);

% per-session
if ~isempty(sessionDir)
    png_sess = fullfile(sessionDir, sprintf('FourierHue_quicklook_%s.png', fileTag));
    fig_sess = fullfile(sessionDir, sprintf('FourierHue_quicklook_%s.fig', fileTag));
    exportgraphics(figF, png_sess, 'Resolution', pngDpi);
    savefig(figF, fig_sess);
end

% global
if ~isempty(globalDir)
    png_glob = fullfile(globalDir, sprintf('FourierHue_quicklook_%s.png', fileTag));
    fig_glob = fullfile(globalDir, sprintf('FourierHue_quicklook_%s.fig', fileTag));
    exportgraphics(figF, png_glob, 'Resolution', pngDpi);
    savefig(figF, fig_glob);
end

if ~makePlots
    close(figF);
end

end
% ===== END FILE: core/visualization/plot_fourier.m =====

% ===== FILE: core/visualization/plot_planes_rayleigh_spike.m =====
% ===== START =====
function plot_planes_rayleigh_spike(sessionID, config)
% For each isoluminant plane (elevID), plot:
%   - Rayleigh R vs saturation (with significance stars)
%   - best-model R^2 vs saturation (spike accounting)

    if nargin < 2 || isempty(config)
        config = load_config();
    end

    makePlots = true;
    if isfield(config,'plot') && isfield(config.plot,'makePlots')
        makePlots = logical(config.plot.makePlots);
    end
    figVis = 'on';
    if ~makePlots
        figVis = 'off';
    end

    pngDpi = 300;
    if isfield(config,'plot') && isfield(config.plot,'dpi')
        pngDpi = config.plot.dpi;
    end

    % Rayleigh alpha (per-unit)
    alphaRay = 0.05;
    if isfield(config,'tuning') && isfield(config.tuning,'alphaRayleigh') ...
            && ~isempty(config.tuning.alphaRayleigh)
        alphaRay = config.tuning.alphaRayleigh;
    end

    P = get_session_paths(config, sessionID);
    tablesDir = P.tables;
    figsDir   = P.figs;

    sessTag = char(sessionID);
    csvFile = fullfile(tablesDir, sprintf('%s_sphereSlices.csv', sessTag));

    if ~isfile(csvFile)
        warning('plot_planes_rayleigh_spike: CSV not found: %s', csvFile);
        return;
    end

    T = readtable(csvFile);
    if isempty(T)
        warning('plot_planes_rayleigh_spike: empty table in %s', csvFile);
        return;
    end

    if ~ismember('elevID', T.Properties.VariableNames) || ...
       ~ismember('satID',  T.Properties.VariableNames)
        error('plot_planes_rayleigh_spike: CSV missing satID/elevID.');
    end

    % bestR2 column may or may not exist; if not, build it from r2_1/r2_12
    if ismember('bestR2', T.Properties.VariableNames)
        bestR2_all = T.bestR2;
    else
        r2_1_all  = NaN(height(T),1);
        r2_12_all = NaN(height(T),1);
        if ismember('r2_1', T.Properties.VariableNames)
            r2_1_all = T.r2_1;
        end
        if ismember('r2_12', T.Properties.VariableNames)
            r2_12_all = T.r2_12;
        end
        bestR2_all = r2_1_all;
        use12 = isfinite(r2_12_all) & (r2_12_all > r2_1_all | ~isfinite(r2_1_all));
        bestR2_all(use12) = r2_12_all(use12);
        T.bestR2 = bestR2_all;
    end

    elevVals = unique(T.elevID);
    satVals  = unique(T.satID);
    satVals  = satVals(isfinite(satVals));

    outDir = fullfile(figsDir, 'discprobe', 'planes');
    if ~exist(outDir,'dir')
        mkdir(outDir);
    end

    globalDir = '';
    if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
            && ~isempty(config.paths.globalDiscProbeFigRoot)
        globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'planes');
        if ~exist(globalDir,'dir')
            mkdir(globalDir);
        end
    end

    for ei = 1:numel(elevVals)
        e = elevVals(ei);
        usePlane = T.elevID == e;

        if ~any(usePlane)
            continue;
        end

        satList = satVals;
        mRay        = nan(size(satList));
        seRay       = nan(size(satList));
        mBestR2     = nan(size(satList));
        seBestR2    = nan(size(satList));
        fracTuned   = nan(size(satList));
        nUnits      = zeros(size(satList));
        nUnitsTuned = zeros(size(satList));

        for si = 1:numel(satList)
            s = satList(si);
            use = usePlane & abs(T.satID - s) < 1e-6;

            if ~any(use)
                continue;
            end

            rayVals = T.rayleigh_R(use);
            r2Vals  = T.bestR2(use);

            % Rayleigh p-values for significance
            rayP = NaN(sum(use),1);
            if ismember('rayleigh_p', T.Properties.VariableNames)
                rayP = T.rayleigh_p(use);
            end

            rayVals = rayVals(isfinite(rayVals));
            r2Vals  = r2Vals(isfinite(r2Vals));

            if ~isempty(rayVals)
                mRay(si)  = mean(rayVals);
                seRay(si) = std(rayVals) / sqrt(numel(rayVals));
            end
            if ~isempty(r2Vals)
                mBestR2(si)   = mean(r2Vals);
                seBestR2(si)  = std(r2Vals) / sqrt(numel(r2Vals));
            end

            if ~isempty(rayP)
                tunedMask = isfinite(rayP) & rayP < alphaRay;
                nUnits(si)      = numel(rayP);
                nUnitsTuned(si) = sum(tunedMask);
                if nUnits(si) > 0
                    fracTuned(si) = nUnitsTuned(si) / nUnits(si);
                end
            end
        end

        fig = figure('Name', sprintf('%s elev=%g', sessTag, e), ...
                     'Color','w','Visible',figVis);
        fig.Units = 'normalized';
        fig.Position = [0.2 0.2 0.5 0.6];

        % ---- Rayleigh vs saturation ----
        ax1 = subplot(2,1,1);
        hold(ax1,'on');
        errorbar(ax1, satList, mRay, seRay, 'o-', 'LineWidth', 1.5);
        xlabel(ax1, 'saturation');
        ylabel(ax1, 'Rayleigh R');
        title(ax1, sprintf('%s: Rayleigh vs sat (elev=%g)', sessTag, e), ...
              'Interpreter','none');
        grid(ax1,'on');

        % place stars where there are any tuned units at that sat/plane
        yMax = max(mRay + seRay, [], 'omitnan');
        if isfinite(yMax) && yMax > 0
            yStar = yMax * 1.05;
            for si = 1:numel(satList)
                if nUnitsTuned(si) > 0
                    plot(ax1, satList(si), yStar, 'k*', 'MarkerSize', 6);
                end
            end
            ylim(ax1, [0, yStar * 1.1]);
        end

        % small legend note for alpha
        txtAlpha = sprintf('\\alpha_{Rayleigh} = %.3f; star = any tuned units', alphaRay);
        text(ax1, 0.01, 0.97, txtAlpha, ...
            'Units','normalized', ...
            'HorizontalAlignment','left', ...
            'VerticalAlignment','top');

        % ---- best-model R^2 vs saturation ----
        ax2 = subplot(2,1,2);
        hold(ax2,'on');
        errorbar(ax2, satList, mBestR2, seBestR2, 'o-', 'LineWidth', 1.5);
        xlabel(ax2, 'saturation');
        ylabel(ax2, 'best-model R^2');
        title(ax2, sprintf('%s: spike accounting (best R^2) vs sat (elev=%g)', sessTag, e), ...
              'Interpreter','none');
        grid(ax2,'on');

        % optional text with how many units per sat
        for si = 1:numel(satList)
            if nUnits(si) > 0
                txt = sprintf('%d/%d tuned', nUnitsTuned(si), nUnits(si));
                text(ax2, satList(si), mBestR2(si), txt, ...
                    'HorizontalAlignment','center', ...
                    'VerticalAlignment','bottom', ...
                    'FontSize',8);
            end
        end

        sgtitle(fig, sprintf('%s – plane elev=%g', sessTag, e), 'Interpreter','none');

        baseName = sprintf('%s_plane_elev%+0.2f', sessTag, e);
        png_plane = fullfile(outDir, [baseName '.png']);
        fig_plane = fullfile(outDir, [baseName '.fig']);
        exportgraphics(fig, png_plane, 'Resolution', pngDpi);
        savefig(fig, fig_plane);

        if ~isempty(globalDir)
            png_glob = fullfile(globalDir, [baseName '.png']);
            fig_glob = fullfile(globalDir, [baseName '.fig']);
            exportgraphics(fig, png_glob, 'Resolution', pngDpi);
            savefig(fig, fig_glob);
        end

        if ~makePlots
            close(fig);
        end
    end
end
% ===== END FILE: core/visualization/plot_planes_rayleigh_spike.m =====

% ===== FILE: core/visualization/plot_rasters.m =====
% ===== START =====
function plot_rasters(U, stats, COL, config, outDir, mode)

if U.nTrials == 0
    return;
end

if nargin < 6 || isempty(mode)
    mode = "canonical";
end
mode = string(mode);

% figure visibility
makePlots = true;
if isfield(config,'plot') && isfield(config.plot,'makePlots')
    makePlots = logical(config.plot.makePlots);
end
figVis = 'on';
if ~makePlots
    figVis = 'off';
end

pngDpi = 300;
if isfield(config,'plot') && isfield(config.plot,'dpi')
    pngDpi = config.plot.dpi;
end

% ---------- paths: per-unit, per-session, global ----------

dateStr  = char(string(U.dateStr));
unitType = char(string(U.unitType));
unitID   = U.unitID;

% per-unit dir: units/<unit>/figures (flat, no subfolders)
Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
unitDir = Upaths.figures;
if ~exist(unitDir,'dir')
    mkdir(unitDir);
end


% per-session dir: <date>/figs/discprobe/rasters
if nargin < 5 || isempty(outDir)
    outDir = '';
end
sessionDir = '';
if ~isempty(outDir)
    sessionDir = fullfile(outDir, 'rasters');
    if ~exist(sessionDir,'dir')
        mkdir(sessionDir);
    end
end

% global dir: output/figs/discprobe/rasters
globalDir = '';
if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
        && ~isempty(config.paths.globalDiscProbeFigRoot)
    globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'rasters');
    if ~exist(globalDir,'dir')
        mkdir(globalDir);
    end
end

% ---------- data prep ----------

spkcell_u = U.spk(:);
mrkcell_u = U.mrk(:);

if isempty(spkcell_u)
    return;
end

% row colors per trial (pastel bands)
rowRGB = [];
if isfield(U.trials,'rowRGB')
    rowRGB = double(U.trials.rowRGB);
elseif all(isfield(U.trials,{'R','G','B'}))
    rowRGB = double([U.trials.R, U.trials.G, U.trials.B]);
end
if ~isempty(rowRGB)
    if max(rowRGB,[],'all') > 1
        rowRGB = rowRGB ./ 255;
    end
else
    if isfield(COL,'colsRGB') && ~isempty(COL.colsRGB)
        cols = double(COL.colsRGB);
        if max(cols(:))>1, cols = cols/255; end
        nT   = numel(spkcell_u);
        rowRGB = cols(mod((1:nT)-1,size(cols,1))+1, :);
    else
        rowRGB = repmat([0.9 0.9 0.9], numel(spkcell_u), 1);
    end
end

% trial-type grouping variable
if isfield(U.trials,'trialTypeID')
    gid_base = U.trials.trialTypeID(:);
elseif isfield(U.trials,'trType')
    gid_base = U.trials.trType(:,1);
elseif isfield(U.trials,'hueID')
    gid_base = U.trials.hueID(:);
else
    gid_base = (1:U.nTrials).';
end

% early window rate per trial
win = U.winEarly;
dur = diff(win);
nTr = numel(spkcell_u);
spk_early_hz = nan(nTr,1);
for tt = 1:nTr
    sp = spkcell_u{tt};
    if isempty(sp)
        spk_early_hz(tt) = 0;
    else
        sp = sp(sp >= win(1) & sp < win(2));
        spk_early_hz(tt) = numel(sp) / dur;
    end
end

nTrials_now = numel(spkcell_u);
nNonzero    = sum(cellfun(@(x) ~isempty(x), spkcell_u));
nSpikes_tot = sum(cellfun(@numel, spkcell_u));

% labels
if strcmpi(U.unitType,'SU')
    unitLabel = sprintf('UnitID %d (SU)', U.unitID);
else
    unitLabel = sprintf('MUA ID %d', U.unitID);
end

if isfield(U,'unitIdx')
    unitNumStr = sprintf('UnitNUM %d', U.unitIdx);
else
    unitNumStr = '';
end

sessionStamp = string(U.dateStr);
fileBaseTag  = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);

% ---------- plotting modes ----------

switch mode
    case "canonical"
        groupvar = gid_base;

        H = DrawRaster(spkcell_u, mrkcell_u, groupvar, rowRGB);
        set(H,'Color','w','Visible',figVis,'Name','Raster — canonical');

        if ~isempty(unitNumStr)
            ttl = sprintf('%s | %s — %s | Sorted by trial type order | trials=%d (nonzero=%d) | spikes=%d', ...
                sessionStamp, unitLabel, unitNumStr, nTrials_now, nNonzero, nSpikes_tot);
        else
            ttl = sprintf('%s | %s | Sorted by trial type order | trials=%d (nonzero=%d) | spikes=%d', ...
                sessionStamp, unitLabel, nTrials_now, nNonzero, nSpikes_tot);
        end
        title(ttl,'Interpreter','none','FontWeight','bold');

        baseName = sprintf('Raster_canonical_%s', fileBaseTag);

        % per-unit
        png_unit = fullfile(unitDir, [baseName '.png']);
        fig_unit = fullfile(unitDir, [baseName '.fig']);
        exportgraphics(H, png_unit, 'Resolution', pngDpi);
        savefig(H, fig_unit);

        % per-session
        if ~isempty(sessionDir)
            png_sess = fullfile(sessionDir, [baseName '.png']);
            fig_sess = fullfile(sessionDir, [baseName '.fig']);
            exportgraphics(H, png_sess, 'Resolution', pngDpi);
            savefig(H, fig_sess);
        end

        % global
        if ~isempty(globalDir)
            png_glob = fullfile(globalDir, [baseName '.png']);
            fig_glob = fullfile(globalDir, [baseName '.fig']);
            exportgraphics(H, png_glob, 'Resolution', pngDpi);
            savefig(H, fig_glob);
        end

        if ~makePlots && ishghandle(H)
            close(H);
        end

    case "mean"
        % group by trial type, sort by mean early rate
        gid = gid_base;
        [ug,~,gix] = unique(gid,'stable');
        m_by_group = accumarray(gix, spk_early_hz, [numel(ug) 1], @mean, NaN);

        [~, gorder] = sort(m_by_group, 'descend', 'MissingPlacement','last');

        ix = cell2mat(arrayfun(@(k) find(gix==gorder(k)).', 1:numel(gorder), 'UniformOutput', false));

        rank_of_group         = zeros(numel(ug),1);
        rank_of_group(gorder) = 1:numel(gorder);
        grp_sort              = rank_of_group(gix(ix));

        spk_sort = spkcell_u(ix);
        mrk_sort = mrkcell_u(ix);
        rgb_sort = rowRGB(ix,:);

        H2 = DrawRaster(spk_sort, mrk_sort, grp_sort, rgb_sort);
        set(H2,'Color','w','Visible',figVis,'Name','Raster — mean spikes');

        if ~isempty(unitNumStr)
            ttl = sprintf('%s | %s — %s | Sorted by mean spikes (high→low) | trials=%d (nonzero=%d) | spikes=%d', ...
                sessionStamp, unitLabel, unitNumStr, nTrials_now, nNonzero, nSpikes_tot);
        else
            ttl = sprintf('%s | %s | Sorted by mean spikes (high→low) | trials=%d (nonzero=%d) | spikes=%d', ...
                sessionStamp, unitLabel, nTrials_now, nNonzero, nSpikes_tot);
        end
        title(ttl,'Interpreter','none','FontWeight','bold');

        baseName = sprintf('Raster_byGroupMean_%s', fileBaseTag);

        % per-unit
        png_unit = fullfile(unitDir, [baseName '.png']);
        fig_unit = fullfile(unitDir, [baseName '.fig']);
        exportgraphics(H2, png_unit, 'Resolution', pngDpi);
        savefig(H2, fig_unit);

        % per-session
        if ~isempty(sessionDir)
            png_sess = fullfile(sessionDir, [baseName '.png']);
            fig_sess = fullfile(sessionDir, [baseName '.fig']);
            exportgraphics(H2, png_sess, 'Resolution', pngDpi);
            savefig(H2, fig_sess);
        end

        % global
        if ~isempty(globalDir)
            png_glob = fullfile(globalDir, [baseName '.png']);
            fig_glob = fullfile(globalDir, [baseName '.fig']);
            exportgraphics(H2, png_glob, 'Resolution', pngDpi);
            savefig(H2, fig_glob);
        end

        if ~makePlots && ishghandle(H2)
            close(H2);
        end

    otherwise
        warning('plot_rasters: unknown mode "%s"', mode);
end

end
% ===== END FILE: core/visualization/plot_rasters.m =====

% ===== FILE: core/visualization/plot_rayleigh.m =====
% ===== START =====
function plot_rayleigh(U, stats, COL, config, outDir)
% PLOT_RAYLEIGH - Polar tuning plots.
% UPDATES:
% 1. Orientation: 0° Right, 90° Top (Counter-Clockwise).
% 2. Alignment: Angles calculated relative to config.space.zeroHue.
% 3. Cleanliness: Axis lines and grids are hidden (only data shown).

    if U.nTrials == 0
        return;
    end
    
    % Check stats
    if ~isfield(stats, 'rayleigh') || isempty(stats.rayleigh)
        % proceed anyway
    end
    
    % --- CONFIG ---
    makePlots = true;
    if isfield(config, 'plot') && isfield(config.plot, 'makePlots')
        makePlots = logical(config.plot.makePlots);
    end
    figVis = 'on';
    if ~makePlots, figVis = 'off'; end
    
    pngDpi = 300;
    if isfield(config, 'plot') && isfield(config.plot, 'dpi')
        pngDpi = config.plot.dpi;
    end
    
    doSaveFig = true;
    if isfield(config, 'plot') && isfield(config.plot, 'saveFigs')
        doSaveFig = config.plot.saveFigs;
    end
    
    % --- PATHS ---
    dateStr  = char(string(U.dateStr));
    unitType = char(string(U.unitType));
    unitID   = U.unitID;
    
    Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
    unitDir = Upaths.figures;
    if ~exist(unitDir,'dir'), mkdir(unitDir); end
    
    if nargin < 5 || isempty(outDir), outDir = ''; end
    sessionDir = '';
    if ~isempty(outDir)
        useSub = true;
        if isfield(config, 'plot') && isfield(config.plot, 'suppressSubfolders') && config.plot.suppressSubfolders
            useSub = false;
        end
        if useSub
            sessionDir = fullfile(outDir, 'rayleigh');
        else
            sessionDir = outDir; 
        end
        if ~exist(sessionDir,'dir'), mkdir(sessionDir); end
    end
    
    globalDir = '';
    if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
            && ~isempty(config.paths.globalDiscProbeFigRoot)
        globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'rayleigh');
        if ~exist(globalDir,'dir'), mkdir(globalDir); end
    end
    
    % --- DATA PREP ---
    win = U.winEarly;
    nTr = numel(U.spk);
    spk_early_count = nan(nTr,1);
    for tt = 1:nTr
        spks = U.spk{tt};
        if isempty(spks)
            spk_early_count(tt) = 0;
        else
            spks = spks(spks >= win(1) & spks < win(2));
            spk_early_count(tt) = numel(spks);
        end
    end
    
    if sum(spk_early_count) > 0
        w_spk = spk_early_count / sum(spk_early_count);
    else
        w_spk = zeros(size(spk_early_count));
    end
    
    hueID  = U.trials.hueID;
    satID  = U.trials.satID;
    elevID = U.trials.elevID;
    
    uElevs = unique(elevID(~isnan(elevID)));
    if isempty(uElevs), currentElev = 0; else, currentElev = mode(uElevs); end
    
    if isfield(COL, 'nHue')
        nHue = COL.nHue;
    else
        nHue = max(hueID(~isnan(hueID)));
    end
    
    % --- ANGLE ALIGNMENT ---
    % Default to 16 if not specified, per your request
    ZERO_HUE = 16; 
    if isfield(config, 'space') && isfield(config.space, 'zeroHue')
        ZERO_HUE = config.space.zeroHue;
    end
    
    thetaIdx        = hueID;
    % Calculate radians relative to Zero Hue
    % e.g. if Zero=16, then Hue 16 -> 0 rad. Hue 4 -> pi/2 rad (90 deg)
    thetaRad_trials = 2*pi * mod(thetaIdx - ZERO_HUE, nHue) / nHue;
    
    % Pre-calculate angles for drawing bars
    hueAngles       = 2*pi * mod((1:nHue) - ZERO_HUE, nHue) / nHue;
    hStep           = 360 / nHue;
    
    saturIDs = unique(satID(~isnan(satID)));
    saturIDs = saturIDs(:).';
    nSat     = numel(saturIDs);
    if isempty(saturIDs), maxSat = 1; else, maxSat = max(saturIDs); end
    
    valid     = isfinite(thetaRad_trials) & isfinite(w_spk);
    theta_all = thetaRad_trials(valid);
    w_all     = w_spk(valid);
    
    if isempty(theta_all) || sum(w_all) == 0, return; end
    
    % Statistics
    [Rbar, mu_deg, z_all, p_all] = local_rayleigh(theta_all, w_all);
    
    spikes_total = sum(spk_early_count);
    trials_total = numel(spk_early_count);
    
    ws_overall   = normalize_to_one(sum_per_hue(thetaIdx(valid), w_all, nHue));
    prefHue_over = mod(round(mu_deg/hStep), nHue) + 1;
    
    % --- Overall Color Map (Full Vivid) ---
    C_over = zeros(nHue, 3);
    for h = 1:nHue
        C_over(h, :) = get_synthetic_color(COL, h, maxSat, maxSat, currentElev);
    end
    
    % ---------- Figure Layout ----------
    figRay = figure('Name','Rayleigh (bars)','Color','w','Visible',figVis);
    
    nCols = min(nSat, 4); if nCols < 1, nCols = 1; end
    nRowsSat = ceil(nSat / nCols);
    totalRows = 1 + nRowsSat;
    
    t = tiledlayout(figRay, totalRows, nCols, 'TileSpacing','normal', 'Padding','compact');

    if isfield(U,'exptName')
        unitTag = sprintf('%s | Unit %d (%s)', string(U.exptName), U.unitID, U.unitType);
    else
        unitTag = sprintf('%s | Unit %d (%s)', string(U.dateStr), U.unitID, U.unitType);
    end
    sgtitle(figRay, unitTag, 'Interpreter','none');
    
    figHeight = 350 + (nRowsSat * 300); 
    figWidth  = 300 * nCols;
    figRay.Position = [100, 100, min(figWidth, 1600), min(figHeight, 1000)];

    SPOKE_LW = 3.5;
    MU_LW    = 3.0;
    ANG_EPS  = 1e-3;
    
    % --- Plot 1: Overall ---
    ax0 = nexttile(t, 1, [1, nCols]); 
    ax0 = polaraxes('Parent', t);
    ax0.Layout.Tile = 1;
    ax0.Layout.TileSpan = [1, nCols];
    
    title(ax0, 'Overall', 'FontWeight','bold');
    hold(ax0,'on');
    style_polar(ax0);
    
    draw_spoke_bars_line(ax0, ws_overall, hueAngles, C_over, SPOKE_LW);
    
    mu = deg2rad(mu_deg);
    polarplot(ax0, [mu-ANG_EPS mu+ANG_EPS], [0 Rbar], '-', 'LineWidth', MU_LW, 'Color','k');
    polarplot(ax0, mu, Rbar, 'ko', 'MarkerFaceColor','k', 'MarkerSize',5);
    
    txt_over = sprintf('R=%.3f, p=%.4g, z=%.1f, \\mu=%0.0f^\\circ (hue %d)\nspikes=%d, trials=%d', ...
        Rbar, p_all, z_all, mu_deg, prefHue_over, spikes_total, trials_total);
    title(ax0, { 'Overall', txt_over }, 'FontWeight','bold', 'FontSize', 9);
    
    % --- Per-Sat Panels ---
    for si = 1:nSat
        ax = nexttile(t);
        ax = polaraxes('Parent', t);
        ax.Layout.Tile = nCols + si; 
        
        sVal = saturIDs(si);
        hold(ax,'on');
        style_polar(ax);
    
        sel  = satID == sVal & isfinite(thetaRad_trials) & isfinite(w_spk);
        th_i = thetaRad_trials(sel);
        w_i  = w_spk(sel);
        
        tr_si_count = sum(sel);
        sp_si_count = sum(spk_early_count(sel));
    
        if isempty(th_i) || sum(w_i)==0
            Rsi = 0; mu_si = 0; z_si = NaN; p_si = NaN; ws_si = zeros(nHue,1);
        else
            [Rsi, mu_si, z_si, p_si] = local_rayleigh(th_i, w_i);
            ws_si = normalize_to_one(sum_per_hue(thetaIdx(sel), w_i, nHue));
        end
    
        % --- Synthetic Color for this Saturation ---
        C_si = zeros(nHue, 3);
        for h = 1:nHue
            C_si(h, :) = get_synthetic_color(COL, h, sVal, maxSat, currentElev);
        end
        
        draw_spoke_bars_line(ax, ws_si, hueAngles, C_si, SPOKE_LW);
        
        mu = deg2rad(mu_si);
        polarplot(ax,[mu-ANG_EPS mu+ANG_EPS],[0 Rsi],'-','LineWidth',MU_LW,'Color','k');
        polarplot(ax,mu,Rsi,'ko','MarkerFaceColor','k','MarkerSize',5);
        
        txt_si = sprintf('R=%.2f, p=%.3g\n\\mu=%0.0f^\\circ, n=%d', Rsi, p_si, mu_si, sp_si_count);
        title(ax, { sprintf('sat = %.2f', sVal), txt_si }, 'FontWeight','normal', 'FontSize', 8);
    end
    
    % ---------- Saving ----------
    fileTag  = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);
    baseName = sprintf('Rayleigh_%s', fileTag);
    
    exportgraphics(figRay, fullfile(unitDir, [baseName '.png']), 'Resolution', pngDpi);
    if doSaveFig, savefig(figRay, fullfile(unitDir, [baseName '.fig'])); end
    
    if ~isempty(sessionDir)
        exportgraphics(figRay, fullfile(sessionDir, [baseName '.png']), 'Resolution', pngDpi);
        if doSaveFig, savefig(figRay, fullfile(sessionDir, [baseName '.fig'])); end
    end
    
    if ~isempty(globalDir)
        exportgraphics(figRay, fullfile(globalDir, [baseName '.png']), 'Resolution', pngDpi);
        if doSaveFig, savefig(figRay, fullfile(globalDir, [baseName '.fig'])); end
    end
    
    if ~makePlots, close(figRay); end
end

% ---------- Helpers ----------

function [Rbar, mu_deg, z, p] = local_rayleigh(thetaRad, w)
    thetaRad = thetaRad(:); w = w(:);
    C = sum(w .* cos(thetaRad)); S = sum(w .* sin(thetaRad)); W = sum(w);
    Rbar = hypot(C,S) / max(W, eps); mu = atan2(S, C); mu_deg = mod(rad2deg(mu), 360);
    z = W * Rbar.^2; p = exp(-z);
end

function x = normalize_to_one(x)
    x = x(:); if all(~isfinite(x)) || all(x==0 | isnan(x)), x(:)=0; return; end
    x(x < 0) = 0; m = max(x); if m > 0, x = x ./ m; end
end

function ws = sum_per_hue(hueIdx, w, nHue)
    hueIdx = hueIdx(:); w = w(:); valid = isfinite(hueIdx) & isfinite(w) & hueIdx>=1 & hueIdx<=nHue;
    ws = accumarray(hueIdx(valid), w(valid), [nHue 1], @sum, 0);
end

% -------------------------------------------------------------------------
% POLAR STYLE: DKL Space (0 Right, 90 Top, No Axes)
% -------------------------------------------------------------------------
function style_polar(ax)
    % Orientation
    ax.ThetaZeroLocation = 'right';
    ax.ThetaDir = 'counterclockwise';
    
    % Remove axis lines, grids, and ticks for clean look
    ax.ThetaAxis.Visible = 'off';
    ax.RAxis.Visible = 'off';
    ax.GridColor = 'none';
    ax.GridAlpha = 0;
    
    rlim(ax, [0 1]);
end

function draw_spoke_bars_line(ax, ws, hueAngles, C, lw)
    ws = ws(:); hueAngles = hueAngles(:);
    for k = 1:numel(ws)
        if ws(k) <= 0, continue; end
        c = C(min(k, size(C,1)),:);
        polarplot(ax, [hueAngles(k) hueAngles(k)], [0 ws(k)], '-', 'LineWidth', lw, 'Color', c);
    end
end

% -------------------------------------------------------------------------
% Helper: Synthetic Color Scaling (Guarantees consistency)
% -------------------------------------------------------------------------
function c = get_synthetic_color(COL, h, sVal, maxSat, eVal)
    % 1. Get Vivid Color (Max Saturation)
    cVivid = get_vivid_color(COL, h, maxSat, eVal);
    
    % 2. Scale brightness by Saturation factor
    if maxSat > 0
        scaleFactor = sVal / maxSat;
    else
        scaleFactor = 0;
    end
    
    c = cVivid * scaleFactor;
end

function c = get_vivid_color(COL, h, maxSat, e)
    c = [0.5 0.5 0.5]; 
    if ~isfield(COL, 'probeIDs') || ~isfield(COL, 'probeCols'), return; end
    tol = 1e-4; 
    idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-maxSat)<tol & abs(COL.probeIDs(:,3)-e)<tol, 1);
    if isempty(idx), idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-maxSat)<tol & abs(COL.probeIDs(:,3)-0)<tol, 1); end
    if isempty(idx), idx = find(abs(COL.probeIDs(:,1)-h)<tol, 1); end
    if ~isempty(idx), rawC = double(COL.probeCols(idx,:)); if max(rawC)>1, rawC=rawC/255; end; c=rawC; end
end
% ===== END FILE: core/visualization/plot_rayleigh.m =====

% ===== FILE: core/visualization/plot_spike_accounting.m =====
% ===== START =====
function plot_spike_accounting(U, stats, COL, config, outDir, varargin)
% PLOT_SPIKE_ACCOUNTING
% FIXES: 
% 1. Stats: Prints R^2, Amp, Peak on all panels.
% 2. Labels: X-axis shows sparse DKL angles (0, 90, etc) instead of Hue Index.
% 3. Colors: Uses Synthetic Scaling (VividColor * Saturation).

    if U.nTrials == 0
        return;
    end
    
    % --- 1. CONFIG CHECK ---
    makePlots = true;
    if isfield(config,'plot') && isfield(config.plot,'makePlots')
        makePlots = logical(config.plot.makePlots);
    end
    
    figVis = 'on';
    if ~makePlots, figVis = 'off'; end
    
    pngDpi = 300;
    if isfield(config,'plot') && isfield(config.plot,'dpi')
        pngDpi = config.plot.dpi;
    end
    
    doSaveFig = true;
    if isfield(config, 'plot') && isfield(config.plot, 'saveFigs')
        doSaveFig = config.plot.saveFigs;
    end

    sessionSubdir = 'spikeaccounting';
    if nargin >= 6 && ~isempty(varargin{1})
        sessionSubdir = varargin{1};
    end
    
    % --- 2. PATH SETUP ---
    dateStr  = char(string(U.dateStr));
    unitType = char(string(U.unitType));
    unitID   = U.unitID;
    
    Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
    unitDir = Upaths.figures;
    if ~exist(unitDir,'dir'), mkdir(unitDir); end
    
    if nargin < 5 || isempty(outDir), outDir = ''; end
    sessionDir = '';
    if ~isempty(outDir)
        if contains(outDir, 'sphere_slices')
            sessionDir = outDir;
        else
            if isempty(sessionSubdir)
                sessionDir = outDir;
            else
                sessionDir = fullfile(outDir, sessionSubdir);
            end
        end
        if ~exist(sessionDir,'dir'), mkdir(sessionDir); end
    end
    
    globalDir = '';
    if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
            && ~isempty(config.paths.globalDiscProbeFigRoot)
        globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'spikeaccounting');
        if ~exist(globalDir,'dir'), mkdir(globalDir); end
    end
    
    % --- 3. DATA PROCESSING ---
    win = U.winEarly;
    dur = diff(win);
    nTr = numel(U.spk);
    rateEarly = nan(nTr,1);
    for tt = 1:nTr
        spks = U.spk{tt};
        if isempty(spks)
            rateEarly(tt) = 0;
        else
            spks = spks(spks >= win(1) & spks < win(2));
            rateEarly(tt) = numel(spks) / dur;
        end
    end
    r = rateEarly;
    r = r - min(r);
    denom = max(r);
    if denom <= 0
        spk_early_norm = zeros(size(r));
    else
        spk_early_norm = r ./ denom;
    end
    
    hueID = U.trials.hueID;
    satID = U.trials.satID;
    elevID = U.trials.elevID;
    
    uElevs = unique(elevID(~isnan(elevID)));
    if numel(uElevs) == 1
        currentElev = uElevs(1);
        elevStr = sprintf('Elev=%.2f', currentElev);
    elseif numel(uElevs) > 1
        currentElev = mode(uElevs); 
        elevStr = sprintf('Elev=[%.2f..%.2f]', min(uElevs), max(uElevs));
    else
        currentElev = 0;
        elevStr = 'Elev=?';
    end
    
    if isfield(COL,'nHue')
        nHue = COL.nHue;
    else
        nHue = max(hueID(~isnan(hueID)));
    end
    
    hue_all = U.trials.hueID;
    sat_all = U.trials.satID;
    
    saturIDs = unique(satID(~isnan(satID)));
    saturIDs = saturIDs(:).';
    nSat = numel(saturIDs);
    
    if isempty(saturIDs), maxSat = 1; else, maxSat = max(saturIDs); end

    % --- Pre-Calculate Stats ---
    N_hs = zeros(nHue, nSat);
    R_hs = nan(nHue, nSat);
    R_h  = nan(nHue, 1);
    
    for h = 1:nHue
        sel = (hue_all == h);
        R_h(h) = mean(spk_early_norm(sel), 'omitnan');
    end
    
    for si = 1:nSat
        sVal = saturIDs(si);
        selS = (sat_all == sVal);
        for h = 1:nHue
            sel  = selS & (hue_all == h);
            R_hs(h,si) = mean(spk_early_norm(sel), 'omitnan');
            N_hs(h,si) = sum(sel);
        end
    end
    R_h(~isfinite(R_h)) = 0;
    R_hs(~isfinite(R_hs)) = 0;
    
    % --- 4. FIGURE CREATION ---
    figAcc = figure('Name','Spike accounting','Color','w','Visible',figVis);
    figAcc.Units = 'normalized';
    figAcc.Position = [0.1 0.1 0.8 0.8];
    
    nColsTop = 3; 
    nCols    = 3;
    nRowsSat = max(1, ceil(nSat / nCols));
    totalRows = 1 + nRowsSat;
    
    t = tiledlayout(figAcc, totalRows, nCols, 'TileSpacing','normal', 'Padding','compact');
    
    if ~makePlots, set(figAcc, 'Visible', 'off'); end
    
    % --- AXIS LABELING ---
    xtick_vals = 1:nHue;
    xtick_labs = string(xtick_vals);
    xlab_str   = 'Hue Index';
    
    isDKL = false;
    ZERO_HUE = 1; 
    
    if isfield(config,'space') && isfield(config.space,'mode') && strcmpi(config.space.mode,'dkl')
        isDKL = true;
        if isfield(config.space, 'zeroHue'), ZERO_HUE = config.space.zeroHue; end
        
        stepDeg = 360 / nHue;
        % Calculate angle for each hue index relative to Zero Hue
        degrees = mod((xtick_vals - ZERO_HUE) * stepDeg, 360);
        
        % Sparse ticks: Label every 4th hue (assuming 16 total -> 0, 90, 180, 270)
        xtick_labs = strings(1, nHue);
        for i = 1:nHue
            if mod(i-1, 4) == 0 % e.g. indices 1, 5, 9, 13
                d = degrees(i);
                xtick_labs(i) = sprintf('%.0f°', d);
            end
        end
        xlab_str = 'Angle (deg)';
    end
    
    % --- TOP ROW ---
    ax1 = nexttile(t, 1);
    ax2 = nexttile(t, 2);
    ax3 = nexttile(t, 3);
    
    % Panel 1: GROUPED Mean Rates
    axes(ax1); hold(ax1,'on'); %#ok<LAXES>
    b1 = bar(ax1, 1:nHue, R_hs, 'grouped'); 
    for si = 1:nSat
        if si <= numel(b1)
            thisSat = saturIDs(si);
            cDataGroup = get_color_matrix_synthetic(COL, nHue, thisSat, maxSat, currentElev);
            b1(si).CData = cDataGroup;
            b1(si).FaceColor = 'flat';
        end
    end
    title(ax1,'Rate per Hue (Grouped)'); ylabel(ax1,'Norm. Rate');
    grid(ax1,'on'); xlim(ax1,[0.5, nHue+0.5]);
    xticks(ax1, xtick_vals); xticklabels(ax1, xtick_labs); xlabel(ax1, xlab_str);
    
    % Panel 2: GROUPED Trial Counts
    axes(ax2); hold(ax2,'on'); %#ok<LAXES>
    b2 = bar(ax2, 1:nHue, N_hs, 'grouped');
    for si = 1:nSat
        if si <= numel(b2)
            thisSat = saturIDs(si);
            cDataGroup = get_color_matrix_synthetic(COL, nHue, thisSat, maxSat, currentElev);
            b2(si).CData = cDataGroup;
            b2(si).FaceColor = 'flat';
        end
    end
    title(ax2,'Trials per Hue (Grouped)'); ylabel(ax2,'Trials');
    grid(ax2,'on'); xlim(ax2,[0.5, nHue+0.5]);
    xticks(ax2, xtick_vals); xticklabels(ax2, xtick_labs); xlabel(ax2, xlab_str);
    
    % Panel 3: Overall Tuning
    axes(ax3); hold(ax3,'on'); %#ok<LAXES>
    b3 = bar(ax3, 1:nHue, R_h);
    cDataOverall = get_color_matrix_synthetic(COL, nHue, maxSat, maxSat, currentElev);
    b3.CData = cDataOverall;
    b3.FaceColor = 'flat';
    title(ax3,'Overall Tuning'); ylabel(ax3,'Norm. Rate');
    grid(ax3,'on'); xlim(ax3,[0.5, nHue+0.5]);
    xticks(ax3, xtick_vals); xticklabels(ax3, xtick_labs); xlabel(ax3, xlab_str);
    
    % Fit Cosine for Overall + Stats (Amp, Peak, R2)
    hx = linspace(1, nHue, 300);
    x_hue = (0:(nHue-1)).';
    if nHue >= 3
        y_hue = R_h(:);
        Xcos = [ones(nHue,1), cos(2*pi*x_hue/nHue), sin(2*pi*x_hue/nHue)];
        beta = Xcos \ y_hue;
        th_smooth = 2*pi*(hx-1)/nHue; 
        y_recon = beta(1) + beta(2)*cos(th_smooth) + beta(3)*sin(th_smooth);
        plot(ax3, hx, y_recon, 'k-','LineWidth',1.5);
        
        % Calculate Stats
        y_hat = Xcos * beta;
        SS_res = sum((y_hue - y_hat).^2, 'omitnan');
        SS_tot = sum((y_hue - mean(y_hue, 'omitnan')).^2, 'omitnan');
        R2 = 1 - (SS_res / SS_tot);
        if SS_tot < 1e-9, R2 = NaN; end
        
        B = beta(2) + 1i*beta(3);
        
        if isDKL
             % Calculate Peak in DKL Degrees
             pkPh = angle(B); 
             if pkPh < 0, pkPh = pkPh + 2*pi; end
             % Convert Phase (0..2pi) to Index Scale (0..360) then shift by ZeroHue
             pkDegIndex = rad2deg(pkPh); 
             % Shift: If ZeroHue is 16, Index 16 is 0 deg.
             % Angle = (Index - ZeroHue) * Step
             % Phase corresponds to "Index - 1".
             % So: DKL = PhaseDeg - (ZeroHue-1)*Step
             peakDegDisplay = mod(pkDegIndex - (ZERO_HUE-1)*(360/nHue), 360);
        else
             peakDeg = rad2deg(angle(B)); if peakDeg<0, peakDeg=peakDeg+360; end
             peakDegDisplay = peakDeg;
        end
        
        txtStats = sprintf('amp=%.2f, pk=%.0f°, R^2=%.2f', abs(B), peakDegDisplay, R2);
        text(ax3, 0.02, 0.98, txtStats, 'Units','normalized','VerticalAlignment','top','FontSize',9,'EdgeColor','none');
    end
    
    % --- BOTTOM ROWS: Per-Sat Slices ---
    for si = 1:nSat
        tileIdx = nCols + si;
        ax = nexttile(t, tileIdx);
        axes(ax); hold(ax,'on'); %#ok<LAXES>
        
        sVal = saturIDs(si);
        yy = R_hs(:,si);
        bSat = bar(ax, 1:nHue, yy);
        
        cDataSat = get_color_matrix_synthetic(COL, nHue, sVal, maxSat, currentElev);
        bSat.CData = cDataSat;
        bSat.FaceColor = 'flat';
        
        if nHue >= 3
            y_s = yy(:);
            beta_i = Xcos \ y_s;
            y_recon_i = beta_i(1) + beta_i(2)*cos(th_smooth) + beta_i(3)*sin(th_smooth);
            plot(ax, hx, y_recon_i, 'k-','LineWidth',1.0);
            
            % Calc R2 & Stats per sat
            y_hat_s = Xcos * beta_i;
            SS_res_s = sum((y_s - y_hat_s).^2, 'omitnan');
            SS_tot_s = sum((y_s - mean(y_s, 'omitnan')).^2, 'omitnan');
            R2_s = 1 - (SS_res_s / SS_tot_s);
            if SS_tot_s < 1e-9, R2_s = NaN; end
            
            Bi = beta_i(2) + 1i*beta_i(3);
            
            if isDKL
                 pkPh = angle(Bi); if pkPh<0, pkPh=pkPh+2*pi; end
                 pkDegIndex = rad2deg(pkPh);
                 pkDegDisplay = mod(pkDegIndex - (ZERO_HUE-1)*(360/nHue), 360);
            else
                 pkDegI = rad2deg(angle(Bi)); if pkDegI<0, pkDegI=pkDegI+360; end
                 peakDegDisplay = pkDegI;
            end
            
            txtI = sprintf('amp=%.2f, pk=%.0f°, R^2=%.2f', abs(Bi), peakDegDisplay, R2_s);
            text(ax, 0.02, 0.98, txtI, 'Units','normalized','VerticalAlignment','top','FontSize',8,'EdgeColor','none');
        end
        
        title(ax, sprintf('Sat=%.2f', sVal));
        grid(ax,'on'); xlim(ax,[0.5, nHue+0.5]);
        xticks(ax, xtick_vals); xticklabels(ax, xtick_labs); 
        if si > nSat - 3, xlabel(ax, xlab_str); end
    end
    
    % --- TITLE & SAVING ---
    if isfield(U, 'sessionID') && ~isempty(U.sessionID), sessStr = U.sessionID; else, sessStr = dateStr; end
    if isfield(U, 'idx'), idxStr = num2str(U.idx); else, idxStr = '?'; end
    ttl = sprintf('%s | UnitID %d (%s) - UnitNUM %s | %s', sessStr, U.unitID, U.unitType, idxStr, elevStr);
    sgtitle(t, ttl, 'FontWeight','bold', 'Interpreter', 'none');
    
    if ~makePlots, set(figAcc, 'Visible', 'off'); end
    
    baseName = sprintf('%s_%s_%d_spikeaccounting', dateStr, unitType, unitID);
    exportgraphics(figAcc, fullfile(unitDir, [baseName '.png']), 'Resolution', pngDpi);
    if doSaveFig, savefig(figAcc, fullfile(unitDir, [baseName '.fig'])); end
    
    if ~isempty(sessionDir)
        exportgraphics(figAcc, fullfile(sessionDir, [baseName '.png']), 'Resolution', pngDpi);
        if doSaveFig, savefig(figAcc, fullfile(sessionDir, [baseName '.fig'])); end
    end
    if ~isempty(globalDir)
        exportgraphics(figAcc, fullfile(globalDir, [baseName '.png']), 'Resolution', pngDpi);
        if doSaveFig, savefig(figAcc, fullfile(globalDir, [baseName '.fig'])); end
    end
    
    if ~makePlots, close(figAcc); end
end

% -------------------------------------------------------------------------
% Helper: Synthetic Color Scaling (Guarantees consistency)
% -------------------------------------------------------------------------
function cMat = get_color_matrix_synthetic(COL, nHue, sVal, maxSat, eVal)
    cMat = repmat([0.5 0.5 0.5], nHue, 1);
    
    for h = 1:nHue
        % 1. Get Vivid Color (Max Saturation)
        cVivid = get_vivid_color(COL, h, maxSat, eVal);
        
        % 2. Scale brightness by Saturation factor
        % (Assuming Sat=0 is dark/black context, common for bar plots on white)
        if maxSat > 0
            scaleFactor = sVal / maxSat;
        else
            scaleFactor = 0;
        end
        
        cMat(h, :) = cVivid * scaleFactor; 
    end
end

function c = get_vivid_color(COL, h, maxSat, e)
    c = [0.5 0.5 0.5]; 
    if ~isfield(COL, 'probeIDs') || ~isfield(COL, 'probeCols'), return; end
    tol = 1e-4; 
    
    % Try strict match for Max Sat
    idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-maxSat)<tol & abs(COL.probeIDs(:,3)-e)<tol, 1);
    
    % Fallback to Equator
    if isempty(idx)
        idx = find(abs(COL.probeIDs(:,1)-h)<tol & abs(COL.probeIDs(:,2)-maxSat)<tol & abs(COL.probeIDs(:,3)-0)<tol, 1);
    end
    
    % Fallback to Hue only (any elevation/sat if max sat missing)
    if isempty(idx)
         idx = find(abs(COL.probeIDs(:,1)-h)<tol, 1);
    end

    if ~isempty(idx)
        rawC = double(COL.probeCols(idx,:));
        if max(rawC) > 1, rawC = rawC / 255; end
        c = rawC;
    end
end
% ===== END FILE: core/visualization/plot_spike_accounting.m =====

% ===== FILE: core/visualization/plot_tuning_curves.m =====
% ===== START =====
function plot_tuning_curves(U, stats, COL, config, outDir)
% Tuning curve figure: mean rate per hue + screen colors
% loosely based on DO_TUNING_FIG block in Analyze_DiscProbePSTHs_v1figproc.m

if ~isfield(stats, 'hueMeans') || isempty(stats.hueMeans)
    return;
end

hm   = stats.hueMeans;
hues = hm.hues;
y    = hm.rate_mean;
e    = hm.rate_sem;

if isempty(hues) || all(~isfinite(y))
    return;
end

% plotting flags
makePlots = true;
if isfield(config, 'plot') && isfield(config.plot, 'makePlots')
    makePlots = logical(config.plot.makePlots);
end
figVis = 'on';
if ~makePlots
    figVis = 'off';
end

pngDpi = 300;
if isfield(config, 'plot') && isfield(config.plot, 'dpi')
    pngDpi = config.plot.dpi;
end

% ---------- paths: per-unit, per-session, global ----------

dateStr  = char(string(U.dateStr));
unitType = char(string(U.unitType));
unitID   = U.unitID;

% per-unit dir: units/<unit>/figures (flat)
Upaths  = get_unit_paths(config, dateStr, unitType, unitID);
unitDir = Upaths.figures;
if ~exist(unitDir,'dir')
    mkdir(unitDir);
end


% per-session dir: <date>/figs/discprobe/tuning
if nargin < 5 || isempty(outDir)
    outDir = '';
end
sessionDir = '';
if ~isempty(outDir)
    sessionDir = fullfile(outDir, 'tuning');
    if ~exist(sessionDir,'dir')
        mkdir(sessionDir);
    end
end

% global dir: output/figs/discprobe/tuning
globalDir = '';
if isfield(config,'paths') && isfield(config.paths,'globalDiscProbeFigRoot') ...
        && ~isempty(config.paths.globalDiscProbeFigRoot)
    globalDir = fullfile(config.paths.globalDiscProbeFigRoot, 'tuning');
    if ~exist(globalDir,'dir')
        mkdir(globalDir);
    end
end

% ---------- figure + plots ----------

f = figure('Visible',figVis,'Color','w');
t = tiledlayout(f, 2, 1, 'TileSpacing','compact', 'Padding','compact');

% tuning panel
ax1 = nexttile(t,1);
hold(ax1,'on');

if all(isfinite(e))
    errorbar(ax1, hues, y, e, 'o-', 'LineWidth',1.2);
else
    plot(ax1, hues, y, 'o-', 'LineWidth',1.2);
end

xlabel(ax1,'Hue index');
ylabel(ax1,'Mean firing (Hz)');
set(ax1,'XTick',hues);
grid(ax1,'on');

title(ax1, sprintf('Color tuning | %s unit %d (%s)', ...
    string(U.dateStr), U.unitID, U.unitType), ...
    'Interpreter','none');

% color swatches
ax2 = nexttile(t,2);
hold(ax2,'on');

nH = numel(hues);
for i = 1:nH
    h = hues(i);
    c = [0.5 0.5 0.5];

    if isfield(COL, 'colsSatur') && ~isempty(COL.colsSatur)
        satIdx = size(COL.colsSatur,1); % highest saturation row
        if h >= 1 && h <= size(COL.colsSatur,2)
            rgb = squeeze(COL.colsSatur(satIdx, h, :));
            rgb = double(rgb(:)');
            if max(rgb) > 1
                rgb = rgb / 255;
            end
            rgb(~isfinite(rgb)) = 0;
            c = rgb;
        end
    end

    patch(ax2, [i-0.4 i+0.4 i+0.4 i-0.4], [0 0 1 1], c, ...
        'EdgeColor','none');
end

xlim(ax2,[min(hues)-0.5 max(hues)+0.5]);
ylim(ax2,[0 1]);
set(ax2,'XTick',hues,'YTick',[]);
xlabel(ax2,'Hue index');
title(ax2, 'Screen colors (max sat)');

% ---------- save in all three locations ----------

fileTag  = sprintf('%s_%s_%d', string(U.dateStr), U.unitType, U.unitID);
baseName = sprintf('TuningCurve_%s', fileTag);

% per-unit
png_unit = fullfile(unitDir, [baseName '.png']);
fig_unit = fullfile(unitDir, [baseName '.fig']);
exportgraphics(f, png_unit, 'Resolution', pngDpi);
savefig(f, fig_unit);

% per-session
if ~isempty(sessionDir)
    png_sess = fullfile(sessionDir, [baseName '.png']);
    fig_sess = fullfile(sessionDir, [baseName '.fig']);
    exportgraphics(f, png_sess, 'Resolution', pngDpi);
    savefig(f, fig_sess);
end

% global
if ~isempty(globalDir)
    png_glob = fullfile(globalDir, [baseName '.png']);
    fig_glob = fullfile(globalDir, [baseName '.fig']);
    exportgraphics(f, png_glob, 'Resolution', pngDpi);
    savefig(f, fig_glob);
end

if ~makePlots
    close(f);
end

end
% ===== END FILE: core/visualization/plot_tuning_curves.m =====

% ===== FILE: core/visualization/plot_tuning_population_histograms.m =====
% ===== START =====
function H = plot_tuning_population_histograms(pop, config)
% Histograms of preferred direction and tuning width


set(0,'DefaultFigureVisible','off');

    phi  = pop.phi0_deg(pop.good);
    fwhm = pop.fwhm_deg(pop.good);

    H.fig = figure('Color','w');

    subplot(1,2,1);
    edges = 0:30:360;
    histogram(phi, edges);
    xlabel('Preferred direction (deg)');
    ylabel('Count');
    title('Tuning peak directions');

    subplot(1,2,2);
    edgesW = 0:15:180;
    histogram(fwhm, edgesW);
    xlabel('FWHM (deg)');
    ylabel('Count');
    title('Tuning widths');

    % optional: draw vertical line for cosine width reference if you want
end
% ===== END FILE: core/visualization/plot_tuning_population_histograms.m =====

% ===== FILE: core/visualization/vss/plot_vss_unit_harmonics.m =====
% ===== START =====
function H = plot_vss_unit_harmonics(U, hm, P, COL, config, outDir)

H = struct('fig',[], 'ax',[]);

if U.nTrials == 0
    return;
end

makePlots = true;
if isfield(config,'plot') && isfield(config.plot,'makePlots')
    makePlots = logical(config.plot.makePlots);
end

figVis = 'on';
if ~makePlots
    figVis = 'off';
end

pngDpi = 300;
if isfield(config,'plot') && isfield(config.plot,'dpi')
    pngDpi = config.plot.dpi;
end

dateStrStr  = string(U.dateStr);
unitTypeStr = string(U.unitType);
unitIDVal   = U.unitID;
unitLabel   = unitTypeStr + unitIDVal;    % "SU13", "MU269"

if nargin < 2 || isempty(hm)
    hm = compute_hue_means(U);
end

hues = hm.hues(:);
y    = hm.rate_mean(:);

good = isfinite(hues) & isfinite(y);
hues = hues(good);
y    = y(good);

[hues, idx] = sort(hues);
y = y(idx);

nH = numel(hues);
if nH < 4
    return;
end

cols_satur2 = [];
if isfield(COL,'colsSatur') && ~isempty(COL.colsSatur)
    sz = size(COL.colsSatur);          % nSat x nHue x 3
    cols_satur2 = reshape(double(COL.colsSatur), sz(1), sz(2), 3);
end

cHue = [];
if ~isempty(cols_satur2)
    satRow = size(cols_satur2,1);      % highest saturation row
    c = squeeze(cols_satur2(satRow, hues, :));
    c = double(c);
    if max(c(:)) > 1
        c = c/255;
    end
    cHue = c;
end

F = fit_first_second_harmonics(y);

peakClass = "";
if nargin >= 3 && ~isempty(P) && isfield(P,'class')
    peakClass = string(P.class);
end

ttl = sprintf('%s%d %s %s', char(unitTypeStr), unitIDVal, ...
    char(peakClass), char(dateStrStr));

if ~exist(outDir, 'dir')
    mkdir(outDir);
end

unitFigDir = fullfile(outDir, char(unitLabel));
if ~exist(unitFigDir, 'dir')
    mkdir(unitFigDir);
end

fig = figure('Visible', figVis, 'Color', 'w', 'Position', [100 100 900 600]);
H.fig = fig;

ax = axes('Parent', fig);
H.ax = ax;
hold(ax, 'on');

b = bar(ax, 1:nH, y);
if ~isempty(cHue)
    b.FaceColor = 'flat';
    b.CData     = cHue;
end

xlabel(ax, 'Hue index');
ylabel(ax, 'Mean rate (spikes/s)');
title(ax, ttl, 'Interpreter','none');
grid(ax, 'on');
xlim(ax, [0.5, nH+0.5]);

hx = linspace(1, nH, 400);

y1 = F.a0 + F.amp1 * cos(2*pi*(hx-1)/nH + deg2rad(F.ph1));
y2 = F.a0 + F.amp2 * cos(4*pi*(hx-1)/nH + deg2rad(F.ph2));

if peakClass == "bimodal"
    plot(ax, hx, y1, 'k--', 'LineWidth', 1.5);
    plot(ax, hx, y2, 'k:',  'LineWidth', 1.5);
    legend(ax, {'data','1st harmonic','2nd harmonic'}, 'Location','best');
else
    plot(ax, hx, y1, 'k--', 'LineWidth', 1.5);
    legend(ax, {'data','1st harmonic'}, 'Location','best');
end

txtBox = sprintf(['R^2_1 = %.2f\nR^2_{1+2} = %.2f\n' ...
                  'P_1 = %.2f\nP_2 = %.2f'], ...
                 F.R2_1, F.R2_12, F.pow1, F.pow2);

annotation(fig, 'textbox', [0.65 0.65 0.3 0.25], ...
    'String', txtBox, ...
    'HorizontalAlignment','left', ...
    'VerticalAlignment','top', ...
    'EdgeColor','none', ...
    'Interpreter','tex');

fileTag = sprintf('%s_%s_%d', char(dateStrStr), char(unitTypeStr), unitIDVal);
pngName = fullfile(unitFigDir, sprintf('VSS_Harmonics_%s.png', fileTag));
figName = fullfile(unitFigDir, sprintf('VSS_Harmonics_%s.fig', fileTag));

exportgraphics(fig, pngName, 'Resolution', pngDpi);
savefig(fig, figName);

if ~makePlots
    close(fig);
end

end


function F = fit_first_second_harmonics(y)
y = y(:);
n = numel(y);
h = (1:n).';

X1  = [ones(n,1), cos(2*pi*(h-1)/n),   sin(2*pi*(h-1)/n)];
X12 = [ones(n,1), cos(2*pi*(h-1)/n),   sin(2*pi*(h-1)/n), ...
                 cos(4*pi*(h-1)/n),   sin(4*pi*(h-1)/n)];

beta1  = X1  \ y;
beta12 = X12 \ y;

a0   = beta12(1);
B1   = beta12(2);
C1   = beta12(3);
B2   = beta12(4);
C2   = beta12(5);

amp1 = sqrt(B1.^2 + C1.^2);
amp2 = sqrt(B2.^2 + C2.^2);

ph1  = atan2(-C1, B1);
ph2  = atan2(-C2, B2);
ph1  = rad2deg(ph1);
ph2  = rad2deg(ph2);

yhat1  = X1  * beta1;
yhat12 = X12 * beta12;

mu    = mean(y);
SStot = sum((y - mu).^2);

if SStot > 0
    R2_1  = 1 - sum((y - yhat1 ).^2) / SStot;
    R2_12 = 1 - sum((y - yhat12).^2) / SStot;
else
    R2_1  = NaN;
    R2_12 = NaN;
end

y1_only = a0 + X1(:,2:3) * beta12(2:3);
y2_only = a0 + [cos(4*pi*(h-1)/n), sin(4*pi*(h-1)/n)] * beta12(4:5);

if SStot > 0
    pow1 = sum((y1_only - mu).^2) / SStot;
    pow2 = sum((y2_only - mu).^2) / SStot;
else
    pow1 = NaN;
    pow2 = NaN;
end

F = struct();
F.a0    = a0;
F.amp1  = amp1;
F.amp2  = amp2;
F.ph1   = ph1;
F.ph2   = ph2;
F.R2_1  = R2_1;
F.R2_12 = R2_12;
F.pow1  = pow1;
F.pow2  = pow2;

end
% ===== END FILE: core/visualization/vss/plot_vss_unit_harmonics.m =====

% ===== FILE: core/visualization/vss/run_vss_spike_accounting.m =====
% ===== START =====
function run_vss_spike_accounting(DATES)
% VSS harmonic figures for sat=1 units

clc;

rootDir = fileparts(mfilename('fullpath'));
addpath(genpath(rootDir));

config = load_config();
COL    = load_color_metadata(config);

% handle DATES / "all" style
if nargin < 1
    DATES = [];
end

if ischar(DATES) || isstring(DATES)
    dstr = strtrim(char(DATES));
    if strcmpi(dstr, 'all')
        DATES = [];
    else
        DATES = {dstr};
    end
end

if isfield(config, 'paths') && isfield(config.paths, 'output') && ~isempty(config.paths.output)
    outRoot = config.paths.output;
else
    outRoot = fullfile(rootDir, 'output');
end

vssRoot = fullfile(outRoot, 'vss');

% if no DATES provided, infer all 6-digit date folders under vssRoot
if isempty(DATES)
    if ~isfolder(vssRoot)
        warning('No VSS root folder found at %s', vssRoot);
        return;
    end

    D = dir(vssRoot);
    isDir = [D.isdir];
    names = {D.name};
    names = names(isDir & ~ismember(names, {'.','..'}));

    isDate = cellfun(@(s) ~isempty(regexp(s, '^\d{6}$', 'once')), names);
    dateNames = names(isDate);

    if isempty(dateNames)
        warning('No 6-digit VSS date folders found in %s', vssRoot);
        return;
    end

    DATES = sort(dateNames(:).');
end

DATES = normalize_dates(DATES);

for d = 1:numel(DATES)
    dateStr = char(DATES{d});
    fprintf('\nVSS harmonic figures: %s\n', dateStr);

    sessionRoot = fullfile(vssRoot, dateStr);
    unitsRoot   = fullfile(sessionRoot, 'units');
    figRoot     = fullfile(sessionRoot, 'spikeAccounting');

    if ~isfolder(unitsRoot)
        warning('No VSS units folder found for %s at %s', dateStr, unitsRoot);
        continue;
    end
    if ~isfolder(figRoot)
        mkdir(figRoot);
    end

    Dunits = dir(unitsRoot);
    isDir = [Dunits.isdir];
    names = {Dunits.name};
    keep = isDir & ~ismember(names, {'.','..'});
    Dunits = Dunits(keep);

    for i = 1:numel(Dunits)
        unitLabel = Dunits(i).name;           % e.g. 'SU13', 'MU269'
        unitDir   = fullfile(unitsRoot, unitLabel);

        mats = dir(fullfile(unitDir, 'VSSUnit_*.mat'));
        if isempty(mats)
            continue;
        end

        matPath = fullfile(unitDir, mats(1).name);
        S = load(matPath);

        if ~isfield(S, 'U')
            warning('No U struct in %s, skipping', matPath);
            continue;
        end

        U = S.U;
        if ~isfield(U,'nTrials') || U.nTrials == 0
            continue;
        end

        if isfield(S,'hm')
            hm = S.hm;
        else
            hm = compute_hue_means(U);
        end

        if isfield(S,'P')
            P = S.P;
        else
            P = peak_model(U, config);
        end

        fprintf('  %s: VSS harmonics for %s%d (%d trials, class=%s)\n', ...
            dateStr, U.unitType, U.unitID, U.nTrials, string(P.class));

        % robust plotting: never let a bad fig kill the "all" run
        try
            plot_vss_unit_harmonics(U, hm, P, COL, config, figRoot);
        catch ME
            warning('run_vss_spike_accounting:PlotFailed', ...
                'Failed to plot %s%d on %s: %s', ...
                U.unitType, U.unitID, dateStr, ME.message);
            try
                if ishghandle(gcf)
                    close(gcf);
                end
            catch
            end
        end
    end
end

end
% ===== END FILE: core/visualization/vss/run_vss_spike_accounting.m =====

% ===== FILE: core/visualization/wachtler/plot_unit_3d_blob_lms.m =====
% ===== START =====
function H = plot_unit_3d_blob_lms(U, tuning3D, config)
% One 3D response blob per unit in [L-M, S, Lum] space.

H = struct('fig',[], 'ax',[]);

LM  = tuning3D.LM(:);
S   = tuning3D.S(:);
Lum = tuning3D.Lum(:);
R   = tuning3D.rate(:);

ok = isfinite(LM) & isfinite(S) & isfinite(Lum) & isfinite(R);
LM  = LM(ok);
S   = S(ok);
Lum = Lum(ok);
R   = R(ok);

if isempty(LM)
    return;
end

% normalize responses 0–1
R = R - min(R);
if max(R) > 0
    R = R ./ max(R);
end

% grid limits with padding
pad = 0.05;
lm_grid  = linspace(min(LM)-pad,  max(LM)+pad, 20);
s_grid   = linspace(min(S)-pad,   max(S)+pad,  20);
lum_grid = linspace(min(Lum)-pad, max(Lum)+pad,20);

% IMPORTANT: use meshgrid (what isonormals/interp3 expect)
[LMg, Sg, Lumg] = meshgrid(lm_grid, s_grid, lum_grid);

% interpolate responses onto grid
F  = scatteredInterpolant(LM, S, Lum, R, 'natural','none');
Rg = F(LMg, Sg, Lumg);

H.fig = figure('Color','w');
H.ax  = axes('Parent',H.fig);
ax    = H.ax;
hold(ax,'on');

levels = [0.3 0.6 0.9];

for k = 1:numel(levels)
    lvl = levels(k);
    try
        pch = patch(isosurface(LMg, Sg, Lumg, Rg, lvl));
    catch
        continue;
    end
    % skip isonormals to avoid interp3 headaches; surfaces still look fine
    pch.FaceColor = [0.7 0.7 0.7];
    pch.EdgeColor = 'none';
    pch.FaceAlpha = 0.25 + 0.15*k;
end

% overlay sample points
scatter3(ax, LM, S, Lum, 40, R, 'filled', 'MarkerEdgeColor','k');

xlabel(ax,'L - M');
ylabel(ax,'S');
zlabel(ax,'Lum (L + M)');
grid(ax,'on');
axis(ax,'equal');
view(ax, 35, 20);
box(ax,'on');

ttl = sprintf('%s %s %d', string(U.dateStr), U.unitType, U.unitID);
title(ax, ttl);

end
% ===== END FILE: core/visualization/wachtler/plot_unit_3d_blob_lms.m =====

% ===== FILE: core/visualization/wachtler/plot_unit_color_tuning_wachtler.m =====
% ===== START =====
function H = plot_unit_color_tuning_wachtler(U, unitTuning, COL, config)
% Wachtler-style figure: central polar tuning + surrounding PSTHs.

H = struct('fig',[], 'axPolar',[], 'axPSTH',[]);

thetaDeg = unitTuning.thetaDeg(:);
satIDs   = unitTuning.saturIDs(:).';
meanRate = unitTuning.meanRate;
fit      = [];
if isfield(unitTuning,'fit')
    fit = unitTuning.fit;
end

nH = numel(thetaDeg);
if nH == 0 || isempty(meanRate)
    return;
end

useSats = [];
if isfield(config,'tuning') && isfield(config.tuning,'useSaturIDs') ...
        && ~isempty(config.tuning.useSaturIDs)
    useSats = config.tuning.useSaturIDs(:).';
end

satTol = 1e-3;
if isfield(config,'legacy') && isfield(config.legacy,'satTol')
    satTol = config.legacy.satTol;
end

% choose best saturation for tuning curve
if isempty(satIDs)
    bestSatIdx = 1;
else
    mask = true(size(satIDs));
    if ~isempty(useSats)
        mask = false(size(satIDs));
        for s = useSats
            mask = mask | abs(satIDs - s) < satTol;
        end
    end
    idx = find(mask);
    if isempty(idx)
        idx = 1:numel(satIDs);
    end
    [~, kLocal] = max(satIDs(idx));
    bestSatIdx = idx(kLocal);
end
bestSatIdx = max(1, min(bestSatIdx, size(meanRate,2)));

if ~isempty(satIDs) && bestSatIdx <= numel(satIDs)
    bestSatVal = satIDs(bestSatIdx);
else
    bestSatVal = NaN;
end

resp = meanRate(:, bestSatIdx);
baselineHz = NaN;
if isfield(unitTuning,'baselineHz')
    baselineHz = unitTuning.baselineHz;
end

if all(~isfinite(resp))
    resp(:) = 0;
end

maxR_data = max(resp(:));
if isfinite(baselineHz)
    maxR_data = max(maxR_data, baselineHz);
end

maxR_fit = 0;
if ~isempty(fit)
    phi_tmp = linspace(0,2*pi,360).';
    fitRate_tmp = fit.A0 + fit.A * exp((cos(phi_tmp - deg2rad(fit.phi0_deg)) - 1) / (fit.sigma.^2));
    fitRate_tmp(fitRate_tmp < 0) = 0;
    maxR_fit = max(fitRate_tmp);
end

maxR = max(maxR_data, maxR_fit);
if ~isfinite(maxR) || maxR <= 0
    maxR = 10;
end
maxR = ceil(maxR/10)*10;

thetaRad = deg2rad(thetaDeg);

% ================= central polar axis =================
H.fig = figure('Color','w');
cx = 0.5; cy = 0.5;

polSize = 0.32;
H.axPolar = polaraxes('Parent',H.fig,'Units','normalized', ...
    'Position',[cx-polSize/2 cy-polSize/2 polSize polSize]);

ax = H.axPolar;
hold(ax,'on');
ax.ThetaZeroLocation = 'right';
ax.ThetaDir          = 'counterclockwise';
ax.ThetaTick         = [0 90 180 270];
rlim(ax,[0 maxR]);
rticks(ax,0:20:maxR);

if isfinite(baselineHz) && baselineHz > 0
    phi = linspace(0,2*pi,360).';
    polarplot(ax, phi, baselineHz*ones(size(phi)), 'k:','LineWidth',1);
end

% tuning curve: fit if we have it, else data
if ~isempty(fit)
    phi = linspace(0,2*pi,360).';
    fitRate = fit.A0 + fit.A * exp((cos(phi - deg2rad(fit.phi0_deg)) - 1) / (fit.sigma.^2));
    fitRate(fitRate < 0) = 0;
    polarplot(ax, phi, fitRate, 'k-','LineWidth',3);
else
    respPlot = resp;
    respPlot(~isfinite(respPlot) | respPlot < 0) = 0;
    [thetaSort, ordSort] = sort(thetaRad);
    rSort = respPlot(ordSort);
    polarplot(ax, [thetaSort; thetaSort(1)], [rSort; rSort(1)], ...
        'k-','LineWidth',3);
end

for k = 1:nH
    r = resp(k);
    if ~isfinite(r) || r <= 0
        continue;
    end
    ang = thetaRad(k);
    r0  = max(baselineHz,0);
    if ~isfinite(r0) || r0 < 0
        r0 = 0;
    end
    polarplot(ax, [ang ang], [r0 r], 'k-', 'LineWidth', 1.5);
end

rLbl = maxR * 1.05;
text(ax, deg2rad(90), rLbl, 'S',   'HorizontalAlignment','center', 'VerticalAlignment','bottom');
text(ax, deg2rad(0),  rLbl, 'L-M', 'HorizontalAlignment','left',   'VerticalAlignment','middle');

% ================= title =================
if strcmpi(U.unitType,'SU')
    unitLabel = sprintf('UnitID %d (SU)', U.unitID);
else
    unitLabel = sprintf('MUA ID %d', U.unitID);
end

if isfield(U,'unitIdx')
    unitNumStr = sprintf('UnitNUM %d', U.unitIdx);
elseif isfield(U,'idx')
    unitNumStr = sprintf('UnitNUM %d', U.idx);
else
    unitNumStr = '';
end

if isfield(U,'sessionStamp')
    sessionStamp = string(U.sessionStamp);
elseif isfield(U,'sessionName')
    sessionStamp = sprintf('%s_%s', string(U.dateStr), string(U.sessionName));
elseif isfield(config,'monkey') && ~isempty(config.monkey)
    sessionStamp = sprintf('%s_%s', string(U.dateStr), string(config.monkey));
else
    sessionStamp = string(U.dateStr);
end

prefStr = 'pref=?°';
fwhmStr = 'FWHM=?°';
if ~isempty(fit)
    prefStr = sprintf('pref=%.0f°', fit.phi0_deg);
    fwhmStr = sprintf('FWHM=%.0f°', fit.fwhm_deg);
end

if isfinite(bestSatVal)
    if ~isempty(unitNumStr)
        ttl = sprintf('%s | %s - %s | sat=%.2f | %s | %s', ...
            sessionStamp, unitLabel, unitNumStr, bestSatVal, prefStr, fwhmStr);
    else
        ttl = sprintf('%s | %s | sat=%.2f | %s | %s', ...
            sessionStamp, unitLabel, bestSatVal, prefStr, fwhmStr);
    end
else
    if ~isempty(unitNumStr)
        ttl = sprintf('%s | %s - %s | %s | %s', ...
            sessionStamp, unitLabel, unitNumStr, prefStr, fwhmStr);
    else
        ttl = sprintf('%s | %s | %s | %s', ...
            sessionStamp, unitLabel, prefStr, fwhmStr);
    end
end

title(ax, ttl,'Interpreter','none','FontWeight','bold');
% ===================== PSTHs around the circle =====================

hueTrial = U.trials.hueID;
nTr      = numel(hueTrial);

hasOutliers = isfield(U,'isOutlier') && numel(U.isOutlier)==nTr;

baseMask = isfinite(hueTrial);
if hasOutliers
    baseMask = baseMask & ~U.isOutlier(:);
end

% restrict to isoluminant plane if we have a lum/elev field
if isfield(U.trials,'lumID')
    lumTrial = U.trials.lumID;
    isoVal   = 0;
    lumTol   = 1e-3;
    baseMask = baseMask & abs(lumTrial - isoVal) < lumTol;
elseif isfield(U.trials,'elevID')
    elevTrial = U.trials.elevID;
    isoVal    = 0;
    elevTol   = 1e-3;
    baseMask  = baseMask & abs(elevTrial - isoVal) < elevTol;
end

% unique hues on that plane
huesAvail = unique(hueTrial(baseMask));
huesAvail(isnan(huesAvail)) = [];

if isempty(huesAvail)
    return;
end

% map those hue IDs to angles (same convention as elsewhere)
thetaAvail_deg = spatial_transforms.hue_to_angle(huesAvail, COL, config);
valid = isfinite(thetaAvail_deg);
huesAvail     = huesAvail(valid);
thetaAvail_deg = mod(thetaAvail_deg(valid), 360);

if isempty(huesAvail)
    return;
end

% we WANT 8 PSTHs at 8 target angles, always
nTarget      = 8;
targetTheta  = linspace(0, 360-360/nTarget, nTarget);  % 0,45,...,315

huesShow  = nan(1, nTarget);
thetaShow = targetTheta;   % where to place each PSTH around the circle

for k = 1:nTarget
    % circular distance between available angles and this target
    d = abs(mod(thetaAvail_deg - targetTheta(k) + 180, 360) - 180);
    [~, idxBest] = min(d);
    huesShow(k) = huesAvail(idxBest);   % use nearest hue for this slot
end

nShow = nTarget;

% PSTH binning
binMs   = 10;
tWinMs  = [0 500];
tEdgesMs   = tWinMs(1):binMs:tWinMs(2);
tEdgesSec  = tEdgesMs / 1000;
tCentersMs = tEdgesMs(1:end-1) + binMs/2;
nBins      = numel(tCentersMs);

psthRates = nan(nShow, nBins);

for ii = 1:nShow
    hID = huesShow(ii);
    if isnan(hID)
        continue;
    end

    mask  = baseMask & (hueTrial == hID);
    trIdx = find(mask);
    if isempty(trIdx)
        continue;
    end

    counts = zeros(1,nBins);
    for jj = 1:numel(trIdx)
        sp = U.spk{trIdx(jj)};
        if isempty(sp), continue; end
        counts = counts + histcounts(sp, tEdgesSec);
    end
    psthRates(ii,:) = counts / (numel(trIdx) * (binMs/1000));   % spikes/s
end

% common y-scale
maxPSTH = max(psthRates(:));
if ~isfinite(maxPSTH) || maxPSTH <= 0
    maxPSTH = 1;
end
maxPSTH = ceil(maxPSTH/10)*10;

% geometry: 8 PSTHs around the polar
psthSize = 0.18;
rAxes    = 0.36;

H.axPSTH = gobjects(nShow,1);

for ii = 1:nShow
    th = deg2rad(thetaShow(ii));
    x = cx + rAxes*cos(th) - psthSize/2;
    y = cy + rAxes*sin(th) - psthSize/2;

    H.axPSTH(ii) = axes('Parent',H.fig,'Units','normalized', ...
        'Position',[x y psthSize psthSize]);
    hold(H.axPSTH(ii),'on');

    rates = psthRates(ii,:);
    if any(isfinite(rates))
        bar(H.axPSTH(ii), tCentersMs, rates, 1.0, 'k');
    end
    xlim(H.axPSTH(ii), tWinMs);
    ylim(H.axPSTH(ii), [0 maxPSTH]);
    set(H.axPSTH(ii),'Box','off','TickDir','out','FontSize',7);
    set(H.axPSTH(ii),'XTick',[0 250 500]);
    set(H.axPSTH(ii),'YTick',[0 maxPSTH]);

    if ii ~= 1
        set(H.axPSTH(ii),'XTickLabel',[],'YTickLabel',[]);
    end
end

if ~isempty(H.axPSTH)
    xlabel(H.axPSTH(1),'time [ms]');
    ylabel(H.axPSTH(1),'rate [spikes/s]');
end


end
% ===== END FILE: core/visualization/wachtler/plot_unit_color_tuning_wachtler.m =====

